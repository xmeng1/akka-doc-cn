<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Modularity, Composition and Hierarchy &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/stream/stream-composition.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html#modularity-composition-and-hierarchy" class="active page">Modularity, Composition and Hierarchy</a>
    <ul>
      <li><a href="../stream/stream-composition.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-composition.html#introduction" class="header">Introduction</a></li>
      <li><a href="../stream/stream-composition.html#basics-of-composition-and-modularity" class="header">Basics of composition and modularity</a></li>
      <li><a href="../stream/stream-composition.html#composing-complex-systems" class="header">Composing complex systems</a></li>
      <li><a href="../stream/stream-composition.html#materialized-values" class="header">Materialized values</a></li>
      <li><a href="../stream/stream-composition.html#attributes" class="header">Attributes</a></li>
    </ul></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html#modularity-composition-and-hierarchy" class="active page">Modularity, Composition and Hierarchy</a>
    <ul>
      <li><a href="../stream/stream-composition.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-composition.html#introduction" class="header">Introduction</a></li>
      <li><a href="../stream/stream-composition.html#basics-of-composition-and-modularity" class="header">Basics of composition and modularity</a></li>
      <li><a href="../stream/stream-composition.html#composing-complex-systems" class="header">Composing complex systems</a></li>
      <li><a href="../stream/stream-composition.html#materialized-values" class="header">Materialized values</a></li>
      <li><a href="../stream/stream-composition.html#attributes" class="header">Attributes</a></li>
    </ul></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#modularity-composition-and-hierarchy" name="modularity-composition-and-hierarchy" class="anchor"><span class="anchor-link"></span></a>Modularity, Composition and Hierarchy</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-stream" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-stream_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-stream_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Akka Streams provide a uniform model of stream processing graphs, which allows flexible composition of reusable components. In this chapter we show how these look like from the conceptual and API perspective, demonstrating the modularity aspects of the library.</p>
<h2><a href="#basics-of-composition-and-modularity" name="basics-of-composition-and-modularity" class="anchor"><span class="anchor-link"></span></a>Basics of composition and modularity</h2>
<p>Every operator used in Akka Streams can be imagined as a &ldquo;box&rdquo; with input and output ports where elements to be processed arrive and leave the operator. In this view, a <code>Source</code> is nothing else than a &ldquo;box&rdquo; with a single output port, or, a <code>BidiFlow</code> is a &ldquo;box&rdquo; with exactly two input and two output ports. In the figure below we illustrate the most commonly used operators viewed as &ldquo;boxes&rdquo;.</p>
<p><img src="../images/compose_shapes.png" alt="compose_shapes.png" /></p>
<p>The <em>linear</em> operators are <code>Source</code>, <code>Sink</code> and <code>Flow</code>, as these can be used to compose strict chains of operators. Fan-in and Fan-out operators have usually multiple input or multiple output ports, therefore they allow to build more complex graph layouts, not only chains. <code>BidiFlow</code> operators are usually useful in IO related tasks, where there are input and output channels to be handled. Due to the specific shape of <code>BidiFlow</code> it is easy to stack them on top of each other to build a layered protocol for example. The <code>TLS</code> support in Akka is for example implemented as a <code>BidiFlow</code>.</p>
<p>These reusable components already allow the creation of complex processing networks. What we have seen so far does not implement modularity though. It is desirable for example to package up a larger graph entity into a reusable component which hides its internals only exposing the ports that are meant to the users of the module to interact with. One good example is the <code>Http</code> server component, which is encoded internally as a <code>BidiFlow</code> which interfaces with the client TCP connection using an input-output port pair accepting and sending <code>ByteString</code> s, while its upper ports emit and receive <code>HttpRequest</code> and <code>HttpResponse</code> instances.</p>
<p>The following figure demonstrates various composite operators, that contain various other type of operators internally, but hiding them behind a <em>shape</em> that looks like a <code>Source</code>, <code>Flow</code>, etc.</p>
<p><img src="../images/compose_composites.png" alt="compose_composites.png" /></p>
<p>One interesting example above is a <code>Flow</code> which is composed of a disconnected <code>Sink</code> and <code>Source</code>. This can be achieved by using the <code>fromSinkAndSource()</code> constructor method on <code>Flow</code> which takes the two parts as parameters.</p>
<p>Please note that when combining a <code>Flow</code> using that method, the termination signals are not carried &ldquo;through&rdquo; as the <code>Sink</code> and <code>Source</code> are assumed to be fully independent. If however you want to construct a <code>Flow</code> like this but need the termination events to trigger &ldquo;the other side&rdquo; of the composite flow, you can use <code>CoupledTerminationFlow.fromSinkAndSource</code> which does just that. For example the cancelation of the composite flows source-side will then lead to completion of its sink-side. Read <code>CoupledTerminationFlow</code>&rsquo;s scaladoc for a detailed explanation how this works.</p>
<p>The example <code>BidiFlow</code> demonstrates that internally a module can be of arbitrary complexity, and the exposed ports can be wired in flexible ways. The only constraint is that all the ports of enclosed modules must be either connected to each other, or exposed as interface ports, and the number of such ports needs to match the requirement of the shape, for example a <code>Source</code> allows only one exposed output port, the rest of the internal ports must be properly connected.</p>
<p>These mechanics allow arbitrary nesting of modules. For example the following figure demonstrates a <code>RunnableGraph</code> that is built from a composite <code>Source</code> and a composite <code>Sink</code> (which in turn contains a composite <code>Flow</code>).</p>
<p><img src="../images/compose_nested_flow.png" alt="compose_nested_flow.png" /></p>
<p>The above diagram contains one more shape that we have not seen yet, which is called <code>RunnableGraph</code>. It turns out, that if we wire all exposed ports together, so that no more open ports remain, we get a module that is <em>closed</em>. This is what the <code>RunnableGraph</code> class represents. This is the shape that a <code>Materializer</code> can take and turn into a network of running entities that perform the task described. In fact, a <code>RunnableGraph</code> is a module itself, and (maybe somewhat surprisingly) it can be used as part of larger graphs. It is rarely useful to embed a closed graph shape in a larger graph (since it becomes an isolated island as there are no open port for communication with the rest of the graph), but this demonstrates the uniform underlying model.</p>
<p>If we try to build a code snippet that corresponds to the above diagram, our first try might look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L23-L29" target="_blank" title="Go to snippet source"></a><code class="language-scala">Source.single(0)
  .map(_ + 1)
  .filter(_ != 0)
  .map(_ - 2)
  .to(Sink.fold(0)(_ + _))

// ... where is the nesting?</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L48-L54" target="_blank" title="Go to snippet source"></a><code class="language-java">Source.single(0)
    .map(i -&gt; i + 1)
    .filter(i -&gt; i != 0)
    .map(i -&gt; i - 2)
    .to(Sink.fold(0, (acc, i) -&gt; acc + i));

// ... where is the nesting?</code></pre></dd>
</dl>
<p>It is clear however that there is no nesting present in our first attempt, since the library cannot figure out where we intended to put composite module boundaries, it is our responsibility to do that. If we are using the DSL provided by the <code>Flow</code>, <code>Source</code>, <code>Sink</code> classes then nesting can be achieved by calling one of the methods <code>withAttributes()</code> or <code>named()</code> (where the latter is a shorthand for adding a name attribute).</p>
<p>The following code demonstrates how to achieve the desired nesting:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L35-L50" target="_blank" title="Go to snippet source"></a><code class="language-scala">val nestedSource =
  Source.single(0) // An atomic source
    .map(_ + 1) // an atomic processing stage
    .named(&quot;nestedSource&quot;) // wraps up the current Source and gives it a name

val nestedFlow =
  Flow[Int].filter(_ != 0) // an atomic processing stage
    .map(_ - 2) // another atomic processing stage
    .named(&quot;nestedFlow&quot;) // wraps up the Flow, and gives it a name

val nestedSink =
  nestedFlow.to(Sink.fold(0)(_ + _)) // wire an atomic sink to the nestedFlow
    .named(&quot;nestedSink&quot;) // wrap it up

// Create a RunnableGraph
val runnableGraph = nestedSource.to(nestedSink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L61-L78" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;Integer, NotUsed&gt; nestedSource =
    Source.single(0) // An atomic source
        .map(i -&gt; i + 1) // an atomic processing stage
        .named(&quot;nestedSource&quot;); // wraps up the current Source and gives it a name

final Flow&lt;Integer, Integer, NotUsed&gt; nestedFlow =
    Flow.of(Integer.class)
        .filter(i -&gt; i != 0) // an atomic processing stage
        .map(i -&gt; i - 2) // another atomic processing stage
        .named(&quot;nestedFlow&quot;); // wraps up the Flow, and gives it a name

final Sink&lt;Integer, NotUsed&gt; nestedSink =
    nestedFlow
        .to(Sink.fold(0, (acc, i) -&gt; acc + i)) // wire an atomic sink to the nestedFlow
        .named(&quot;nestedSink&quot;); // wrap it up

// Create a RunnableGraph
final RunnableGraph&lt;NotUsed&gt; runnableGraph = nestedSource.to(nestedSink);</code></pre></dd>
</dl>
<p>Once we have hidden the internals of our components, they act like any other built-in component of similar shape. If we hide some of the internals of our composites, the result looks just like if any other predefine component has been used:</p>
<p><img src="../images/compose_nested_flow_opaque.png" alt="compose_nested_flow_opaque.png" /></p>
<p>If we look at usage of built-in components, and our custom components, there is no difference in usage as the code snippet below demonstrates.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L70-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Create a RunnableGraph from our components
val runnableGraph = nestedSource.to(nestedSink)

// Usage is uniform, no matter if modules are composite or atomic
val runnableGraph2 = Source.single(0).to(Sink.fold(0)(_ + _))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L101-L106" target="_blank" title="Go to snippet source"></a><code class="language-java">// Create a RunnableGraph from our components
final RunnableGraph&lt;NotUsed&gt; runnableGraph = nestedSource.to(nestedSink);

// Usage is uniform, no matter if modules are composite or atomic
final RunnableGraph&lt;NotUsed&gt; runnableGraph2 =
    Source.single(0).to(Sink.fold(0, (acc, i) -&gt; acc + i));</code></pre></dd>
</dl>
<h2><a href="#composing-complex-systems" name="composing-complex-systems" class="anchor"><span class="anchor-link"></span></a>Composing complex systems</h2>
<p>In the previous section we explored the possibility of composition, and hierarchy, but we stayed away from non-linear, generalized operators. There is nothing in Akka Streams though that enforces that stream processing layouts can only be linear. The DSL for <code>Source</code> and friends is optimized for creating such linear chains, as they are the most common in practice. There is a more advanced DSL for building complex graphs, that can be used if more flexibility is needed. We will see that the difference between the two DSLs is only on the surface: the concepts they operate on are uniform across all DSLs and fit together nicely.</p>
<p>As a first example, let&rsquo;s look at a more complex layout:</p>
<p><img src="../images/compose_graph.png" alt="compose_graph.png" /></p>
<p>The diagram shows a <code>RunnableGraph</code> (remember, if there are no unwired ports, the graph is closed, and therefore can be materialized) that encapsulates a non-trivial stream processing network. It contains fan-in, fan-out operators, directed and non-directed cycles. The <code>runnable()</code> method of the <code>GraphDSL</code> object allows the creation of a general, closed, and runnable graph. For example the network on the diagram can be realized like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L81-L97" target="_blank" title="Go to snippet source"></a><code class="language-scala">import GraphDSL.Implicits._
RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =&gt;
  val A: Outlet[Int]                  = builder.add(Source.single(0)).out
  val B: UniformFanOutShape[Int, Int] = builder.add(Broadcast[Int](2))
  val C: UniformFanInShape[Int, Int]  = builder.add(Merge[Int](2))
  val D: FlowShape[Int, Int]          = builder.add(Flow[Int].map(_ + 1))
  val E: UniformFanOutShape[Int, Int] = builder.add(Balance[Int](2))
  val F: UniformFanInShape[Int, Int]  = builder.add(Merge[Int](2))
  val G: Inlet[Any]                   = builder.add(Sink.foreach(println)).in

                C     &lt;~      F
  A  ~&gt;  B  ~&gt;  C     ~&gt;      F
         B  ~&gt;  D  ~&gt;  E  ~&gt;  F
                       E  ~&gt;  G

  ClosedShape
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L113-L130" target="_blank" title="Go to snippet source"></a><code class="language-java">RunnableGraph.fromGraph(
    GraphDSL.create(
        builder -&gt; {
          final Outlet&lt;Integer&gt; A = builder.add(Source.single(0)).out();
          final UniformFanOutShape&lt;Integer, Integer&gt; B = builder.add(Broadcast.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; C = builder.add(Merge.create(2));
          final FlowShape&lt;Integer, Integer&gt; D =
              builder.add(Flow.of(Integer.class).map(i -&gt; i + 1));
          final UniformFanOutShape&lt;Integer, Integer&gt; E = builder.add(Balance.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; F = builder.add(Merge.create(2));
          final Inlet&lt;Integer&gt; G = builder.add(Sink.&lt;Integer&gt;foreach(System.out::println)).in();

          builder.from(F).toFanIn(C);
          builder.from(A).viaFanOut(B).viaFanIn(C).toFanIn(F);
          builder.from(B).via(D).viaFanOut(E).toFanIn(F);
          builder.from(E).toInlet(G);
          return ClosedShape.getInstance();
        }));</code></pre></dd>
</dl>
<p>In the code above we used the implicit port numbering feature (to make the graph more readable and similar to the diagram) and we imported <code>Source</code> s, <code>Sink</code> s and <code>Flow</code> s explicitly. It is possible to refer to the ports explicitly, and it is not necessary to import our linear operators via <code>add()</code>, so another version might look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L101-L114" target="_blank" title="Go to snippet source"></a><code class="language-scala">import GraphDSL.Implicits._
RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =&gt;
  val B = builder.add(Broadcast[Int](2))
  val C = builder.add(Merge[Int](2))
  val E = builder.add(Balance[Int](2))
  val F = builder.add(Merge[Int](2))

  Source.single(0) ~&gt; B.in; B.out(0) ~&gt; C.in(1); C.out ~&gt; F.in(0)
  C.in(0) &lt;~ F.out

  B.out(1).map(_ + 1) ~&gt; E.in; E.out(0) ~&gt; F.in(1)
  E.out(1) ~&gt; Sink.foreach(println)
  ClosedShape
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L134-L154" target="_blank" title="Go to snippet source"></a><code class="language-java">RunnableGraph.fromGraph(
    GraphDSL.create(
        builder -&gt; {
          final SourceShape&lt;Integer&gt; A = builder.add(Source.single(0));
          final UniformFanOutShape&lt;Integer, Integer&gt; B = builder.add(Broadcast.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; C = builder.add(Merge.create(2));
          final FlowShape&lt;Integer, Integer&gt; D =
              builder.add(Flow.of(Integer.class).map(i -&gt; i + 1));
          final UniformFanOutShape&lt;Integer, Integer&gt; E = builder.add(Balance.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; F = builder.add(Merge.create(2));
          final SinkShape&lt;Integer&gt; G = builder.add(Sink.foreach(System.out::println));

          builder.from(F.out()).toInlet(C.in(0));
          builder.from(A).toInlet(B.in());
          builder.from(B.out(0)).toInlet(C.in(1));
          builder.from(C.out()).toInlet(F.in(0));
          builder.from(B.out(1)).via(D).toInlet(E.in());
          builder.from(E.out(0)).toInlet(F.in(1));
          builder.from(E.out(1)).to(G);
          return ClosedShape.getInstance();
        }));</code></pre></dd>
</dl>
<p>Similar to the case in the first section, so far we have not considered modularity. We created a complex graph, but the layout is flat, not modularized. We will modify our example, and create a reusable component with the graph DSL. The way to do it is to use the <code>create()</code> factory method on <code>GraphDSL</code>. If we remove the sources and sinks from the previous example, what remains is a partial graph:</p>
<p><img src="../images/compose_graph_partial.png" alt="compose_graph_partial.png" /></p>
<p>We can recreate a similar graph in code, using the DSL in a similar way than before:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L122-L133" target="_blank" title="Go to snippet source"></a><code class="language-scala">import GraphDSL.Implicits._
val partial = GraphDSL.create() { implicit builder =&gt;
  val B = builder.add(Broadcast[Int](2))
  val C = builder.add(Merge[Int](2))
  val E = builder.add(Balance[Int](2))
  val F = builder.add(Merge[Int](2))

                                   C  &lt;~  F
  B  ~&gt;                            C  ~&gt;  F
  B  ~&gt;  Flow[Int].map(_ + 1)  ~&gt;  E  ~&gt;  F
  FlowShape(B.in, E.out(1))
}.named(&quot;partial&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L161-L179" target="_blank" title="Go to snippet source"></a><code class="language-java">final Graph&lt;FlowShape&lt;Integer, Integer&gt;, NotUsed&gt; partial =
    GraphDSL.create(
        builder -&gt; {
          final UniformFanOutShape&lt;Integer, Integer&gt; B = builder.add(Broadcast.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; C = builder.add(Merge.create(2));
          final UniformFanOutShape&lt;Integer, Integer&gt; E = builder.add(Balance.create(2));
          final UniformFanInShape&lt;Integer, Integer&gt; F = builder.add(Merge.create(2));

          builder.from(F.out()).toInlet(C.in(0));
          builder.from(B).viaFanIn(C).toFanIn(F);
          builder
              .from(B)
              .via(builder.add(Flow.of(Integer.class).map(i -&gt; i + 1)))
              .viaFanOut(E)
              .toFanIn(F);

          return new FlowShape&lt;Integer, Integer&gt;(B.in(), E.out(1));
        });
</code></pre></dd>
</dl>
<p>The only new addition is the return value of the builder block, which is a <code>Shape</code>. All operators (including <code>Source</code>, <code>BidiFlow</code>, etc) have a shape, which encodes the <em>typed</em> ports of the module. In our example there is exactly one input and output port left, so we can declare it to have a <code>FlowShape</code> by returning an instance of it. While it is possible to create new <code>Shape</code> types, it is usually recommended to use one of the matching built-in ones.</p>
<p>The resulting graph is already a properly wrapped module, so there is no need to call <em>named()</em> to encapsulate the graph, but it is a good practice to give names to modules to help debugging.</p>
<p><img src="../images/compose_graph_shape.png" alt="compose_graph_shape.png" /></p>
<p>Since our partial graph has the right shape, it can be already used in the simpler, linear DSL:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L138" target="_blank" title="Go to snippet source"></a><code class="language-scala">Source.single(0).via(partial).to(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L183" target="_blank" title="Go to snippet source"></a><code class="language-java">Source.single(0).via(partial).to(Sink.ignore());</code></pre></dd>
</dl>
<p>It is not possible to use it as a <code>Flow</code> yet, though (i.e. we cannot call <code>.filter()</code> on it), but <code>Flow</code> has a <code>fromGraph()</code> method that adds the DSL to a <code>FlowShape</code>. There are similar methods on <code>Source</code>, <code>Sink</code> and <code>BidiShape</code>, so it is easy to get back to the simpler DSL if an operator has the right shape. For convenience, it is also possible to skip the partial graph creation, and use one of the convenience creator methods. To demonstrate this, we will create the following graph:</p>
<p><img src="../images/compose_graph_flow.png" alt="compose_graph_flow.png" /></p>
<p>The code version of the above closed graph might look like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L143-L164" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Convert the partial graph of FlowShape to a Flow to get
// access to the fluid DSL (for example to be able to call .filter())
val flow = Flow.fromGraph(partial)

// Simple way to create a graph backed Source
val source = Source.fromGraph( GraphDSL.create() { implicit builder =&gt;
  val merge = builder.add(Merge[Int](2))
  Source.single(0)      ~&gt; merge
  Source(List(2, 3, 4)) ~&gt; merge

  // Exposing exactly one output port
  SourceShape(merge.out)
})

// Building a Sink with a nested Flow, using the fluid DSL
val sink = {
  val nestedFlow = Flow[Int].map(_ * 2).drop(10).named(&quot;nestedFlow&quot;)
  nestedFlow.to(Sink.head)
}

// Putting all together
val closed = source.via(flow.filter(_ &gt; 1)).to(sink)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L187-L208" target="_blank" title="Go to snippet source"></a><code class="language-java">// Convert the partial graph of FlowShape to a Flow to get
// access to the fluid DSL (for example to be able to call .filter())
final Flow&lt;Integer, Integer, NotUsed&gt; flow = Flow.fromGraph(partial);

// Simple way to create a graph backed Source
final Source&lt;Integer, NotUsed&gt; source =
    Source.fromGraph(
        GraphDSL.create(
            builder -&gt; {
              final UniformFanInShape&lt;Integer, Integer&gt; merge = builder.add(Merge.create(2));
              builder.from(builder.add(Source.single(0))).toFanIn(merge);
              builder.from(builder.add(Source.from(Arrays.asList(2, 3, 4)))).toFanIn(merge);
              // Exposing exactly one output port
              return new SourceShape&lt;Integer&gt;(merge.out());
            }));

// Building a Sink with a nested Flow, using the fluid DSL
final Sink&lt;Integer, NotUsed&gt; sink =
    Flow.of(Integer.class).map(i -&gt; i * 2).drop(10).named(&quot;nestedFlow&quot;).to(Sink.head());

// Putting all together
final RunnableGraph&lt;NotUsed&gt; closed = source.via(flow.filter(i -&gt; i &gt; 1)).to(sink);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>All graph builder sections check if the resulting graph has all ports connected except the exposed ones and will throw an exception if this is violated.</p></div>
<p>We are still in debt of demonstrating that <code>RunnableGraph</code> is a component like any other, which can be embedded in graphs. In the following snippet we embed one closed graph in another:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L171-L176" target="_blank" title="Go to snippet source"></a><code class="language-scala">val closed1 = Source.single(0).to(Sink.foreach(println))
val closed2 = RunnableGraph.fromGraph(GraphDSL.create() { implicit builder ⇒
  val embeddedClosed: ClosedShape = builder.add(closed1)
  // …
  embeddedClosed
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L215-L222" target="_blank" title="Go to snippet source"></a><code class="language-java">final RunnableGraph&lt;NotUsed&gt; closed1 = Source.single(0).to(Sink.foreach(System.out::println));
final RunnableGraph&lt;NotUsed&gt; closed2 =
    RunnableGraph.fromGraph(
        GraphDSL.create(
            builder -&gt; {
              final ClosedShape embeddedClosed = builder.add(closed1);
              return embeddedClosed; // Could return ClosedShape.getInstance()
            }));</code></pre></dd>
</dl>
<p>The type of the imported module indicates that the imported module has a <code>ClosedShape</code>, and so we are not able to wire it to anything else inside the enclosing closed graph. Nevertheless, this &ldquo;island&rdquo; is embedded properly, and will be materialized just like any other module that is part of the graph.</p>
<p>As we have demonstrated, the two DSLs are fully interoperable, as they encode a similar nested structure of &ldquo;boxes with ports&rdquo;, it is only the DSLs that differ to be as much powerful as possible on the given abstraction level. It is possible to embed complex graphs in the fluid DSL, and it is just as easy to import and embed a <code>Flow</code>, etc, in a larger, complex structure.</p>
<p>We have also seen, that every module has a <code>Shape</code> (for example a <code>Sink</code> has a <code>SinkShape</code>) independently which DSL was used to create it. This uniform representation enables the rich composability of various stream processing entities in a convenient way.</p>
<h2><a href="#materialized-values" name="materialized-values" class="anchor"><span class="anchor-link"></span></a>Materialized values</h2>
<p>After realizing that <code>RunnableGraph</code> is nothing more than a module with no unused ports (it is an island), it becomes clear that after materialization the only way to communicate with the running stream processing logic is via some side-channel. This side channel is represented as a <em>materialized value</em>. The situation is similar to <code>Actor</code> s, where the <code>Props</code> instance describes the actor logic, but it is the call to <code>actorOf()</code> that creates an actually running actor, and returns an <code>ActorRef</code> that can be used to communicate with the running actor itself. Since the <code>Props</code> can be reused, each call will return a different reference.</p>
<p>When it comes to streams, each materialization creates a new running network corresponding to the blueprint that was encoded in the provided <code>RunnableGraph</code>. To be able to interact with the running network, each materialization needs to return a different object that provides the necessary interaction capabilities. In other words, the <code>RunnableGraph</code> can be seen as a factory, which creates:</p>
<ul>
  <li>a network of running processing entities, inaccessible from the outside</li>
  <li>a materialized value, optionally providing a controlled interaction capability with the network</li>
</ul>
<p>Unlike actors though, each of the operators might provide a materialized value, so when we compose multiple operators or modules, we need to combine the materialized value as well (there are default rules which make this easier, for example <em>to()</em> and <em>via()</em> takes care of the most common case of taking the materialized value to the left. See <a href="stream-flows-and-basics.html#flow-combine-mat">Combining materialized values</a> for details). We demonstrate how this works by a code example and a diagram which graphically demonstrates what is happening.</p>
<p>The propagation of the individual materialized values from the enclosed modules towards the top will look like this:</p>
<p><img src="../images/compose_mat.png" alt="compose_mat.png" /></p>
<p>To implement the above, first, we create a composite <code>Source</code>, where the enclosed <code>Source</code> have a materialized type of <span class="group-scala"><code>Promise[[Option[Int]]</code></span> <span class="group-java"><code>CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt;</code></span>. By using the combiner function <code>Keep.left</code>, the resulting materialized type is of the nested module (indicated by the color <em>red</em> on the diagram):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L182-L190" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Materializes to Promise[Option[Int]]                                   (red)
val source: Source[Int, Promise[Option[Int]]] = Source.maybe[Int]

// Materializes to NotUsed                                               (black)
val flow1: Flow[Int, Int, NotUsed] = Flow[Int].take(100)

// Materializes to Promise[Int]                                          (red)
val nestedSource: Source[Int, Promise[Option[Int]]] =
  source.viaMat(flow1)(Keep.left).named(&quot;nestedSource&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L253-L261" target="_blank" title="Go to snippet source"></a><code class="language-java">// Materializes to CompletableFuture&lt;Optional&lt;Integer&gt;&gt;                   (red)
final Source&lt;Integer, CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt; source = Source.&lt;Integer&gt;maybe();

// Materializes to NotUsed                                                (black)
final Flow&lt;Integer, Integer, NotUsed&gt; flow1 = Flow.of(Integer.class).take(100);

// Materializes to CompletableFuture&lt;Optional&lt;Integer&gt;&gt;                  (red)
final Source&lt;Integer, CompletableFuture&lt;Optional&lt;Integer&gt;&gt;&gt; nestedSource =
    source.viaMat(flow1, Keep.left()).named(&quot;nestedSource&quot;);</code></pre></dd>
</dl>
<p>Next, we create a composite <code>Flow</code> from two smaller components. Here, the second enclosed <code>Flow</code> has a materialized type of <span class="group-scala"><code>Future[OutgoingConnection]</code></span> <span class="group-java"><code>CompletionStage&lt;OutgoingConnection&gt;</code></span>, and we propagate this to the parent by using <code>Keep.right</code> as the combiner function (indicated by the color <em>yellow</em> on the diagram):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L194-L203" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Materializes to NotUsed                                                (orange)
val flow2: Flow[Int, ByteString, NotUsed] = Flow[Int].map { i ⇒ ByteString(i.toString) }

// Materializes to Future[OutgoingConnection]                             (yellow)
val flow3: Flow[ByteString, ByteString, Future[OutgoingConnection]] =
  Tcp().outgoingConnection(&quot;localhost&quot;, 8080)

// Materializes to Future[OutgoingConnection]                             (yellow)
val nestedFlow: Flow[Int, ByteString, Future[OutgoingConnection]] =
  flow2.viaMat(flow3)(Keep.right).named(&quot;nestedFlow&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L265-L275" target="_blank" title="Go to snippet source"></a><code class="language-java">// Materializes to NotUsed                                                (orange)
final Flow&lt;Integer, ByteString, NotUsed&gt; flow2 =
    Flow.of(Integer.class).map(i -&gt; ByteString.fromString(i.toString()));

// Materializes to Future&lt;OutgoingConnection&gt;                             (yellow)
final Flow&lt;ByteString, ByteString, CompletionStage&lt;OutgoingConnection&gt;&gt; flow3 =
    Tcp.get(system).outgoingConnection(&quot;localhost&quot;, 8080);

// Materializes to Future&lt;OutgoingConnection&gt;                             (yellow)
final Flow&lt;Integer, ByteString, CompletionStage&lt;OutgoingConnection&gt;&gt; nestedFlow =
    flow2.viaMat(flow3, Keep.right()).named(&quot;nestedFlow&quot;);</code></pre></dd>
</dl>
<p>As a third step, we create a composite <code>Sink</code>, using our <code>nestedFlow</code> as a building block. In this snippet, both the enclosed <code>Flow</code> and the folding <code>Sink</code> has a materialized value that is interesting for us, so we use <code>Keep.both</code> to get a <code>Pair</code> of them as the materialized type of <code>nestedSink</code> (indicated by the color <em>blue</em> on the diagram)</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L207-L212" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Materializes to Future[String]                                         (green)
val sink: Sink[ByteString, Future[String]] = Sink.fold(&quot;&quot;)(_ + _.utf8String)

// Materializes to (Future[OutgoingConnection], Future[String])           (blue)
val nestedSink: Sink[Int, (Future[OutgoingConnection], Future[String])] =
  nestedFlow.toMat(sink)(Keep.both)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L279-L285" target="_blank" title="Go to snippet source"></a><code class="language-java">// Materializes to Future&lt;String&gt;                                         (green)
final Sink&lt;ByteString, CompletionStage&lt;String&gt;&gt; sink =
    Sink.&lt;String, ByteString&gt;fold(&quot;&quot;, (acc, i) -&gt; acc + i.utf8String());

// Materializes to Pair&lt;Future&lt;OutgoingConnection&gt;, Future&lt;String&gt;&gt;       (blue)
final Sink&lt;Integer, Pair&lt;CompletionStage&lt;OutgoingConnection&gt;, CompletionStage&lt;String&gt;&gt;&gt;
    nestedSink = nestedFlow.toMat(sink, Keep.both());</code></pre></dd>
</dl>
<p>As the last example, we wire together <code>nestedSource</code> and <code>nestedSink</code> and we use a custom combiner function to create a yet another materialized type of the resulting <code>RunnableGraph</code>. This combiner function ignores the <span class="group-scala"><code>Future[String]</code></span> <span class="group-java"><code>CompletionStage&lt;String&gt;</code></span> part, and wraps the other two values in a custom case class <code>MyClass</code> (indicated by color <em>purple</em> on the diagram):</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L216-L230" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class MyClass(private val p: Promise[Option[Int]], conn: OutgoingConnection) {
  def close() = p.trySuccess(None)
}

def f(
  p:    Promise[Option[Int]],
  rest: (Future[OutgoingConnection], Future[String])): Future[MyClass] = {

  val connFuture = rest._1
  connFuture.map(MyClass(p, _))
}

// Materializes to Future[MyClass]                                        (purple)
val runnableGraph: RunnableGraph[Future[MyClass]] =
  nestedSource.toMat(nestedSink)(f)</code></pre></dd>
  <dt>Java</dt>
  <dd>
    <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L227-L247" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyClass {
  private CompletableFuture&lt;Optional&lt;Integer&gt;&gt; p;
  private OutgoingConnection conn;

  public MyClass(CompletableFuture&lt;Optional&lt;Integer&gt;&gt; p, OutgoingConnection conn) {
    this.p = p;
    this.conn = conn;
  }

  public void close() {
    p.complete(Optional.empty());
  }
}

static class Combiner {
  static CompletionStage&lt;MyClass&gt; f(
      CompletableFuture&lt;Optional&lt;Integer&gt;&gt; p,
      Pair&lt;CompletionStage&lt;OutgoingConnection&gt;, CompletionStage&lt;String&gt;&gt; rest) {
    return rest.first().thenApply(c -&gt; new MyClass(p, c));
  }
}</code></pre>
    <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L289-L291" target="_blank" title="Go to snippet source"></a><code class="language-java">// Materializes to Future&lt;MyClass&gt;                                        (purple)
final RunnableGraph&lt;CompletionStage&lt;MyClass&gt;&gt; runnableGraph =
    nestedSource.toMat(nestedSink, Combiner::f);</code></pre>
  </dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>The nested structure in the above example is not necessary for combining the materialized values, it demonstrates how the two features work together. See <a href="stream-flows-and-basics.html#flow-combine-mat">Combining materialized values</a> for further examples of combining materialized values without nesting and hierarchy involved.</p></div>
<h2><a href="#attributes" name="attributes" class="anchor"><span class="anchor-link"></span></a>Attributes</h2>
<p>We have seen that we can use <code>named()</code> to introduce a nesting level in the fluid DSL (and also explicit nesting by using <code>create()</code> from <code>GraphDSL</code>). Apart from having the effect of adding a nesting level, <code>named()</code> is actually a shorthand for calling <code>withAttributes(Attributes.name(&quot;someName&quot;))</code>. Attributes provide a way to fine-tune certain aspects of the materialized running entity. For example buffer sizes for asynchronous operators can be controlled via attributes (see <a href="stream-rate.html#async-stream-buffers">Buffers for asynchronous operators</a>). When it comes to hierarchic composition, attributes are inherited by nested modules, unless they override them with a custom value.</p>
<p>The code below, a modification of an earlier example sets the <code>inputBuffer</code> attribute on certain modules, but not on others:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/CompositionDocSpec.scala#L236-L249" target="_blank" title="Go to snippet source"></a><code class="language-scala">import Attributes._
val nestedSource =
  Source.single(0)
    .map(_ + 1)
    .named(&quot;nestedSource&quot;) // Wrap, no inputBuffer set

val nestedFlow =
  Flow[Int].filter(_ != 0)
    .via(Flow[Int].map(_ - 2).withAttributes(inputBuffer(4, 4))) // override
    .named(&quot;nestedFlow&quot;) // Wrap, no inputBuffer set

val nestedSink =
  nestedFlow.to(Sink.fold(0)(_ + _)) // wire an atomic sink to the nestedFlow
    .withAttributes(name(&quot;nestedSink&quot;) and inputBuffer(3, 3)) // override</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/CompositionDocTest.java#L298-L314" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;Integer, NotUsed&gt; nestedSource =
    Source.single(0).map(i -&gt; i + 1).named(&quot;nestedSource&quot;); // Wrap, no inputBuffer set

final Flow&lt;Integer, Integer, NotUsed&gt; nestedFlow =
    Flow.of(Integer.class)
        .filter(i -&gt; i != 0)
        .via(
            Flow.of(Integer.class)
                .map(i -&gt; i - 2)
                .withAttributes(Attributes.inputBuffer(4, 4))) // override
        .named(&quot;nestedFlow&quot;); // Wrap, no inputBuffer set

final Sink&lt;Integer, NotUsed&gt; nestedSink =
    nestedFlow
        .to(Sink.fold(0, (acc, i) -&gt; acc + i)) // wire an atomic sink to the nestedFlow
        .withAttributes(
            Attributes.name(&quot;nestedSink&quot;).and(Attributes.inputBuffer(3, 3))); // override</code></pre></dd>
</dl>
<p>The effect is, that each module inherits the <code>inputBuffer</code> attribute from its enclosing parent, unless it has the same attribute explicitly set. <code>nestedSource</code> gets the default attributes from the materializer itself. <code>nestedSink</code> on the other hand has this attribute set, so it will be used by all nested modules. <code>nestedFlow</code> will inherit from <code>nestedSink</code> except the <code>map</code> operator which has again an explicitly provided attribute overriding the inherited one.</p>
<p><img src="../images/compose_attributes.png" alt="compose_attributes.png" /></p>
<p>This diagram illustrates the inheritance process for the example code (representing the materializer default attributes as the color <em>red</em>, the attributes set on <code>nestedSink</code> as <em>blue</em> and the attributes set on <code>nestedFlow</code> as <em>green</em>).</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../stream/stream-graphs.html"><i class="icon-prev"></i> <span class="link-prev">Working with Graphs</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../stream/stream-rate.html">Buffers and working with rate <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/stream/stream-composition.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
