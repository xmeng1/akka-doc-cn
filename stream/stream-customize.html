<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Custom stream processing &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/stream/stream-customize.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html#custom-stream-processing" class="active page">Custom stream processing</a>
    <ul>
      <li><a href="../stream/stream-customize.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-customize.html#introduction" class="header">Introduction</a></li>
      <li><a href="../stream/stream-customize.html#custom-processing-with-graphstage" class="header">Custom processing with GraphStage</a></li>
      <li><a href="../stream/stream-customize.html#thread-safety-of-custom-operators" class="header">Thread safety of custom operators</a></li>
      <li><a href="../stream/stream-customize.html#resources-and-the-operator-lifecycle" class="header">Resources and the operator lifecycle</a></li>
      <li><a href="../stream/stream-customize.html#extending-flow-operators-with-custom-operators" class="header group-scala">Extending Flow Operators with Custom Operators</a></li>
    </ul></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html#custom-stream-processing" class="active page">Custom stream processing</a>
    <ul>
      <li><a href="../stream/stream-customize.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-customize.html#introduction" class="header">Introduction</a></li>
      <li><a href="../stream/stream-customize.html#custom-processing-with-graphstage" class="header">Custom processing with GraphStage</a></li>
      <li><a href="../stream/stream-customize.html#thread-safety-of-custom-operators" class="header">Thread safety of custom operators</a></li>
      <li><a href="../stream/stream-customize.html#resources-and-the-operator-lifecycle" class="header">Resources and the operator lifecycle</a></li>
      <li><a href="../stream/stream-customize.html#extending-flow-operators-with-custom-operators" class="header group-scala">Extending Flow Operators with Custom Operators</a></li>
    </ul></li>
    <li><a href="../stream/stream-integrations.html" class="page">Integration</a></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#custom-stream-processing" name="custom-stream-processing" class="anchor"><span class="anchor-link"></span></a>Custom stream processing</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-stream" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-stream_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-stream_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>While the processing vocabulary of Akka Streams is quite rich (see the <a href="stream-cookbook.html">Streams Cookbook</a> for examples) it is sometimes necessary to define new transformation operators either because some functionality is missing from the stock operations, or for performance reasons. In this part we show how to build custom operators and graph junctions of various kinds.</p><div class="callout note "><div class="callout-title">Note</div>
<p>A custom operator should not be the first tool you reach for, defining operators using flows and the graph DSL is in general easier and does to a larger extent protect you from mistakes that might be easy to make with a custom <a href="stream-customize.html"><code>GraphStage</code></a></p></div>
<a id="graphstage"></a>
<h2><a href="#custom-processing-with-graphstage" name="custom-processing-with-graphstage" class="anchor"><span class="anchor-link"></span></a>Custom processing with GraphStage</h2>
<p>The <code>GraphStage</code> abstraction can be used to create arbitrary operators with any number of input or output ports. It is a counterpart of the <code>GraphDSL.create()</code> method which creates new stream processing operators by composing others. Where <code>GraphStage</code> differs is that it creates an operator that is itself not divisible into smaller ones, and allows state to be maintained inside it in a safe way.</p>
<p>As a first motivating example, we will build a new <code>Source</code> that will emit numbers from 1 until it is cancelled. To start, we need to define the &ldquo;interface&rdquo; of our operator, which is called <em>shape</em> in Akka Streams terminology (this is explained in more detail in the section <a href="stream-composition.html">Modularity, Composition and Hierarchy</a>). This is how this looks like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L25-L36" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.stream.SourceShape
import akka.stream.stage.GraphStage

class NumbersSource extends GraphStage[SourceShape[Int]] {
  // Define the (sole) output port of this stage
  val out: Outlet[Int] = Outlet(&quot;NumbersSource&quot;)
  // Define the shape of this stage, which is SourceShape with the port we defined above
  override val shape: SourceShape[Int] = SourceShape(out)

  // This is where the actual (possibly stateful) logic will live
  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = ???
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L55-L91" target="_blank" title="Go to snippet source"></a><code class="language-java">public class NumbersSource extends GraphStage&lt;SourceShape&lt;Integer&gt;&gt; {
  // Define the (sole) output port of this stage
  public final Outlet&lt;Integer&gt; out = Outlet.create(&quot;NumbersSource.out&quot;);

  // Define the shape of this stage, which is SourceShape with the port we defined above
  private final SourceShape&lt;Integer&gt; shape = SourceShape.of(out);

  @Override
  public SourceShape&lt;Integer&gt; shape() {
    return shape;
  }

  // This is where the actual (possibly stateful) logic is created
  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape()) {
      // All state MUST be inside the GraphStageLogic,
      // never inside the enclosing GraphStage.
      // This state is safe to access and modify from all the
      // callbacks that are provided by GraphStageLogic and the
      // registered handlers.
      private int counter = 1;

      {
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                push(out, counter);
                counter += 1;
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>As you see, in itself the <code>GraphStage</code> only defines the ports of this operator and a shape that contains the ports. It also has, a currently unimplemented method called <code>createLogic</code>. If you recall, operators are reusable in multiple materializations, each resulting in a different executing entity. In the case of <code>GraphStage</code> the actual running logic is modeled as an instance of a <code>GraphStageLogic</code> which will be created by the materializer by calling the <code>createLogic</code> method. In other words, all we need to do is to create a suitable logic that will emit the numbers we want.</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is very important to keep the GraphStage object itself immutable and reusable. All mutable state needs to be confined to the GraphStageLogic that is created for every materialization.</p></div>
<p>In order to emit from a <code>Source</code> in a backpressured stream one needs first to have demand from downstream. To receive the necessary events one needs to register a subclass of <span class="group-scala"><code>OutHandler</code></span> <span class="group-java"><code>AbstractOutHandler</code></span> with the output port (<code>Outlet</code>). This handler will receive events related to the lifecycle of the port. In our case we need to override <code>onPull()</code> which indicates that we are free to emit a single element. There is another callback, <code>onDownstreamFinish()</code> which is called if the downstream cancelled. Since the default behavior of that callback is to stop the operator, we don&rsquo;t need to override it. In the <code>onPull</code> callback we will emit the next number. This is how it looks like in the end:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L43-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.stream.Attributes
import akka.stream.Outlet
import akka.stream.SourceShape
import akka.stream.stage.GraphStage
import akka.stream.stage.GraphStageLogic
import akka.stream.stage.OutHandler

class NumbersSource extends GraphStage[SourceShape[Int]] {
  val out: Outlet[Int] = Outlet(&quot;NumbersSource&quot;)
  override val shape: SourceShape[Int] = SourceShape(out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {
      // All state MUST be inside the GraphStageLogic,
      // never inside the enclosing GraphStage.
      // This state is safe to access and modify from all the
      // callbacks that are provided by GraphStageLogic and the
      // registered handlers.
      private var counter = 1

      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          push(out, counter)
          counter += 1
        }
      })
    }
}</code></pre></dd>
</dl>
<p>Instances of the above <code>GraphStage</code> are subclasses of <span class="group-scala"><code>Graph[SourceShape[Int],NotUsed]</code></span> <span class="group-java"><code>Graph&lt;SourceShape&lt;Integer&gt;,NotUsed&gt;</code></span> which means that they are already usable in many situations, but do not provide the DSL methods we usually have for other <code>Source</code> s. In order to convert this <code>Graph</code> to a proper <code>Source</code> we need to wrap it using <code>Source.fromGraph</code> (see <a href="stream-composition.html">Modularity, Composition and Hierarchy</a> for more details about operators and DSLs). Now we can use the source as any other built-in one:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L74-L84" target="_blank" title="Go to snippet source"></a><code class="language-scala">// A GraphStage is a proper Graph, just like what GraphDSL.create would return
val sourceGraph: Graph[SourceShape[Int], NotUsed] = new NumbersSource

// Create a Source from the Graph to access the DSL
val mySource: Source[Int, NotUsed] = Source.fromGraph(sourceGraph)

// Returns 55
val result1: Future[Int] = mySource.take(10).runFold(0)(_ + _)

// The source is reusable. This returns 5050
val result2: Future[Int] = mySource.take(100).runFold(0)(_ + _)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L135-L146" target="_blank" title="Go to snippet source"></a><code class="language-java">// A GraphStage is a proper Graph, just like what GraphDSL.create would return
Graph&lt;SourceShape&lt;Integer&gt;, NotUsed&gt; sourceGraph = new NumbersSource();

// Create a Source from the Graph to access the DSL
Source&lt;Integer, NotUsed&gt; mySource = Source.fromGraph(sourceGraph);

// Returns 55
CompletionStage&lt;Integer&gt; result1 = mySource.take(10).runFold(0, (sum, next) -&gt; sum + next, mat);

// The source is reusable. This returns 5050
CompletionStage&lt;Integer&gt; result2 =
    mySource.take(100).runFold(0, (sum, next) -&gt; sum + next, mat);</code></pre></dd>
</dl>
<p>Similarly, to create a custom <code>Sink</code> one can register a subclass <code>InHandler</code> with the operator <code>Inlet</code>. The <code>onPush()</code> callback is used to signal the handler a new element has been pushed to the operator, and can hence be grabbed and used. <code>onPush()</code> can be overridden to provide custom behavior. Please note, most Sinks would need to request upstream elements as soon as they are created: this can be done by calling <code>pull(inlet)</code> in the <code>preStart()</code> callback.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L93-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.stream.Attributes
import akka.stream.Inlet
import akka.stream.SinkShape
import akka.stream.stage.GraphStage
import akka.stream.stage.GraphStageLogic
import akka.stream.stage.InHandler

class StdoutSink extends GraphStage[SinkShape[Int]] {
  val in: Inlet[Int] = Inlet(&quot;StdoutSink&quot;)
  override val shape: SinkShape[Int] = SinkShape(in)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {

      // This requests one element at the Sink startup.
      override def preStart(): Unit = pull(in)

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          println(grab(in))
          pull(in)
        }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L95-L129" target="_blank" title="Go to snippet source"></a><code class="language-java">public class StdoutSink extends GraphStage&lt;SinkShape&lt;Integer&gt;&gt; {
  public final Inlet&lt;Integer&gt; in = Inlet.create(&quot;StdoutSink.in&quot;);

  private final SinkShape&lt;Integer&gt; shape = SinkShape.of(in);

  @Override
  public SinkShape&lt;Integer&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape()) {

      // This requests one element at the Sink startup.
      @Override
      public void preStart() {
        pull(in);
      }

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() throws Exception {
                Integer element = grab(in);
                System.out.println(element);
                pull(in);
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<h3><a href="#port-states-and-" name="port-states-and-" class="anchor"><span class="anchor-link"></span></a>Port states, <span class="group-scala">InHandler</span> <span class="group-java">AbstractInHandler</span> and <span class="group-scala">OutHandler</span> <span class="group-java">AbstractOutHandler</span></h3>
<p>In order to interact with a port (<code>Inlet</code> or <code>Outlet</code>) of the operator we need to be able to receive events and generate new events belonging to the port.</p>
<h4><a href="#output-port" name="output-port" class="anchor"><span class="anchor-link"></span></a>Output port</h4>
<p>From the <code>GraphStageLogic</code> the following operations are available on an output port:</p>
<ul>
  <li><code>push(out,elem)</code> pushes an element to the output port. Only possible after the port has been pulled by downstream.</li>
  <li><code>complete(out)</code> closes the output port normally.</li>
  <li><code>fail(out,exception)</code> closes the port with a failure signal.</li>
</ul>
<p>The events corresponding to an <em>output</em> port can be received in an <span class="group-scala"><code>OutHandler</code></span> <span class="group-java"><code>AbstractOutHandler</code></span> instance registered to the output port using <code>setHandler(out,handler)</code>. This handler has two callbacks:</p>
<ul>
  <li><code>onPull()</code> is called when the output port is ready to emit the next element, <code>push(out, elem)</code> is now allowed to be called on this port.</li>
  <li><code>onDownstreamFinish()</code> is called once the downstream has cancelled and no longer allows messages to be pushed to it. No more <code>onPull()</code> will arrive after this event. If not overridden this will default to stopping the operator.</li>
</ul>
<p>Also, there are two query methods available for output ports:</p>
<ul>
  <li><code>isAvailable(out)</code> returns true if the port can be pushed</li>
  <li><code>isClosed(out)</code> returns true if the port is closed. At this point the port can not be pushed and will not be pulled anymore.</li>
</ul>
<p>The relationship of the above operations, events and queries are summarized in the state machine below. Green shows the initial state while orange indicates the end state. If an operation is not listed for a state, then it is invalid to call it while the port is in that state. If an event is not listed for a state, then that event cannot happen in that state.</p>
<p><img src="../images/outport_transitions.png" alt="outport_transitions.png" /></p>
<h4><a href="#input-port" name="input-port" class="anchor"><span class="anchor-link"></span></a>Input port</h4>
<p>The following operations are available for <em>input</em> ports:</p>
<ul>
  <li><code>pull(in)</code> requests a new element from an input port. This is only possible after the port has been pushed by upstream.</li>
  <li><code>grab(in)</code> acquires the element that has been received during an <code>onPush()</code>. It cannot be called again until the port is pushed again by the upstream.</li>
  <li><code>cancel(in)</code> closes the input port.</li>
</ul>
<p>The events corresponding to an <em>input</em> port can be received in an <span class="group-scala"><code>InHandler</code></span> <span class="group-java"><code>AbstractInHandler</code></span> instance registered to the input port using <code>setHandler(in, handler)</code>. This handler has three callbacks:</p>
<ul>
  <li><code>onPush()</code> is called when the input port has now a new element. Now it is possible to acquire this element using <code>grab(in)</code> and/or call <code>pull(in)</code> on the port to request the next element. It is not mandatory to grab the element, but if it is pulled while the element has not been grabbed it will drop the buffered element.</li>
  <li><code>onUpstreamFinish()</code> is called once the upstream has completed and no longer can be pulled for new elements. No more <code>onPush()</code> will arrive after this event. If not overridden this will default to stopping the operator.</li>
  <li><code>onUpstreamFailure()</code> is called if the upstream failed with an exception and no longer can be pulled for new elements. No more <code>onPush()</code> will arrive after this event. If not overridden this will default to failing the operator.</li>
</ul>
<p>Also, there are three query methods available for input ports:</p>
<ul>
  <li><code>isAvailable(in)</code> returns true if the port can be grabbed.</li>
  <li><code>hasBeenPulled(in)</code> returns true if the port has been already pulled. Calling <code>pull(in)</code> in this state is illegal.</li>
  <li><code>isClosed(in)</code> returns true if the port is closed. At this point the port can not be pulled and will not be pushed anymore.</li>
</ul>
<p>The relationship of the above operations, events and queries are summarized in the state machine below. Green shows the initial state while orange indicates the end state. If an operation is not listed for a state, then it is invalid to call it while the port is in that state. If an event is not listed for a state, then that event cannot happen in that state.</p>
<p><img src="../images/inport_transitions.png" alt="inport_transitions.png" /></p>
<h4><a href="#complete-and-fail" name="complete-and-fail" class="anchor"><span class="anchor-link"></span></a>Complete and fail</h4>
<p>Finally, there are two methods available for convenience to complete the operator and all of its ports:</p>
<ul>
  <li><code>completeStage()</code> is equivalent to closing all output ports and cancelling all input ports.</li>
  <li><code>failStage(exception)</code> is equivalent to failing all output ports and cancelling all input ports.</li>
</ul>
<h4><a href="#emit" name="emit" class="anchor"><span class="anchor-link"></span></a>Emit</h4>
<p>In some cases it is inconvenient and error prone to react on the regular state machine events with the signal based API described above. For those cases there is an API which allows for a more declarative sequencing of actions which will greatly simplify some use cases at the cost of some extra allocations. The difference between the two APIs could be described as that the first one is signal driven from the outside, while this API is more active and drives its surroundings.</p>
<p>The operations of this part of the <code>GraphStage</code> API are:</p>
<ul>
  <li><code>emit(out, elem)</code> and <code>emitMultiple(out, Iterable(elem1, elem2))</code> replaces the <code>OutHandler</code> with a handler that emits one or more elements when there is demand, and then reinstalls the current handlers</li>
  <li><code>read(in)(andThen)</code> and <code>readN(in, n)(andThen)</code> replaces the <code>InHandler</code> with a handler that reads one or more elements as they are pushed and allows the handler to react once the requested number of elements has been read.</li>
  <li><code>abortEmitting()</code> and <code>abortReading()</code> which will cancel an ongoing emit or read</li>
</ul>
<p>Note that since the above methods are implemented by temporarily replacing the handlers of the operator you should never call <code>setHandler</code> while they are running <code>emit</code> or <code>read</code> as that interferes with how they are implemented. The following methods are safe to call after invoking <code>emit</code> and <code>read</code> (and will lead to actually running the operation when those are done): <code>complete(out)</code>, <code>completeStage()</code>, <code>emit</code>, <code>emitMultiple</code>, <code>abortEmitting()</code> and <code>abortReading()</code></p>
<p>An example of how this API simplifies an operator can be found below in the second version of the <code>Duplicator</code>.</p>
<h3><a href="#custom-linear-operators-using-graphstage" name="custom-linear-operators-using-graphstage" class="anchor"><span class="anchor-link"></span></a>Custom linear operators using GraphStage</h3>
<p>To define custom linear operators, you should extend <code>GraphStage</code> using <code>FlowShape</code> which has one input and one output.</p>
<p>Such an operator can be illustrated as a box with two flows as it is seen in the illustration below. Demand flowing upstream leading to elements flowing downstream.</p>
<p><img src="../images/graph_stage_conceptual.png" alt="graph_stage_conceptual.png" /></p>
<p>To illustrate these concepts we create a small <code>GraphStage</code> that implements the <code>map</code> transformation.</p>
<p><img src="../images/graph_stage_map.png" alt="graph_stage_map.png" /></p>
<p>Map calls <code>push(out)</code> from the <code>onPush()</code> handler and it also calls <code>pull()</code> from the <code>onPull</code> handler resulting in the conceptual wiring above, and fully expressed in code below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L124-L144" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Map[A, B](f: A ⇒ B) extends GraphStage[FlowShape[A, B]] {

  val in = Inlet[A](&quot;Map.in&quot;)
  val out = Outlet[B](&quot;Map.out&quot;)

  override val shape = FlowShape.of(in, out)

  override def createLogic(attr: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {
      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          push(out, f(grab(in)))
        }
      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          pull(in)
        }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L163-L205" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Map&lt;A, B&gt; extends GraphStage&lt;FlowShape&lt;A, B&gt;&gt; {

  private final Function&lt;A, B&gt; f;

  public Map(Function&lt;A, B&gt; f) {
    this.f = f;
  }

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;Map.in&quot;);
  public final Outlet&lt;B&gt; out = Outlet.create(&quot;Map.out&quot;);

  private final FlowShape&lt;A, B&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, B&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() throws Exception {
                push(out, f.apply(grab(in)));
              }
            });
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                pull(in);
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>Map is a typical example of a one-to-one transformation of a stream where demand is passed along upstream elements passed on downstream.</p>
<p>To demonstrate a many-to-one operator we will implement filter. The conceptual wiring of <code>Filter</code> looks like this:</p>
<p><img src="../images/graph_stage_filter.png" alt="graph_stage_filter.png" /></p>
<p>As we see above, if the given predicate matches the current element we are propagating it downwards, otherwise we return the “ball” to our upstream so that we get the new element. This is achieved by modifying the map example by adding a conditional in the <code>onPush</code> handler and decide between a <code>pull(in)</code> or <code>push(out)</code> call (and not having a mapping <code>f</code> function).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L160-L182" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Filter[A](p: A ⇒ Boolean) extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;Filter.in&quot;)
  val out = Outlet[A](&quot;Filter.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {
      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          if (p(elem)) push(out, elem)
          else pull(in)
        }
      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          pull(in)
        }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L230-L276" target="_blank" title="Go to snippet source"></a><code class="language-java">public final class Filter&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  private final Predicate&lt;A&gt; p;

  public Filter(Predicate&lt;A&gt; p) {
    this.p = p;
  }

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;Filter.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;Filter.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {
      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() {
                A elem = grab(in);
                if (p.test(elem)) {
                  push(out, elem);
                } else {
                  pull(in);
                }
              }
            });

        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                pull(in);
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>To complete the picture we define a one-to-many transformation as the next step. We chose a straightforward example operator that emits every upstream element twice downstream. The conceptual wiring of this operator looks like this:</p>
<p><img src="../images/graph_stage_duplicate.png" alt="graph_stage_duplicate.png" /></p>
<p>This is an operator that has state: an option with the last element it has seen indicating if it has duplicated this last element already or not. We must also make sure to emit the extra element if the upstream completes.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L199-L236" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Duplicator[A] extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;Duplicator.in&quot;)
  val out = Outlet[A](&quot;Duplicator.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {
      // Again: note that all mutable state
      // MUST be inside the GraphStageLogic
      var lastElem: Option[A] = None

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          lastElem = Some(elem)
          push(out, elem)
        }

        override def onUpstreamFinish(): Unit = {
          if (lastElem.isDefined) emit(out, lastElem.get)
          complete(out)
        }

      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          if (lastElem.isDefined) {
            push(out, lastElem.get)
            lastElem = None
          } else {
            pull(in)
          }
        }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L295-L349" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Duplicator&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;Duplicator.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;Duplicator.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {
      // Again: note that all mutable state
      // MUST be inside the GraphStageLogic
      Option&lt;A&gt; lastElem = Option.none();

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() {
                A elem = grab(in);
                lastElem = Option.some(elem);
                push(out, elem);
              }

              @Override
              public void onUpstreamFinish() {
                if (lastElem.isDefined()) {
                  emit(out, lastElem.get());
                }
                complete(out);
              }
            });

        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                if (lastElem.isDefined()) {
                  push(out, lastElem.get());
                  lastElem = Option.none();
                } else {
                  pull(in);
                }
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>In this case a pull from downstream might be consumed by the operator itself rather than passed along upstream as the operator might contain an element it wants to push. Note that we also need to handle the case where the upstream closes while the operator still has elements it wants to push downstream. This is done by overriding <em>onUpstreamFinish</em> in the <span class="group-scala"><em>InHandler</em></span> <span class="group-java"><em>AbstractInHandler</em></span> and provide custom logic that should happen when the upstream has been finished.</p>
<p>This example can be simplified by replacing the usage of a mutable state with calls to <code>emitMultiple</code> which will replace the handlers, emit each of multiple elements and then reinstate the original handlers:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L253-L277" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Duplicator[A] extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;Duplicator.in&quot;)
  val out = Outlet[A](&quot;Duplicator.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          // this will temporarily suspend this handler until the two elems
          // are emitted and then reinstates it
          emitMultiple(out, Iterable(elem, elem))
        }
      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          pull(in)
        }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L365-L405" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Duplicator2&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;Duplicator.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;Duplicator.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() {
                A elem = grab(in);
                // this will temporarily suspend this handler until the two elems
                // are emitted and then reinstates it
                emitMultiple(out, Arrays.asList(elem, elem).iterator());
              }
            });

        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                pull(in);
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<p>Finally, to demonstrate all of the operators above, we put them together into a processing chain, which conceptually would correspond to the following structure:</p>
<p><img src="../images/graph_stage_chain.png" alt="graph_stage_chain.png" /></p>
<p>In code this is only a few lines, using the <code>via</code> use our custom operators in a stream:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L296-L301" target="_blank" title="Go to snippet source"></a><code class="language-scala">val resultFuture = Source(1 to 5)
  .via(new Filter(_ % 2 == 0))
  .via(new Duplicator())
  .via(new Map(_ / 2))
  .runWith(sink)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L426-L432" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletionStage&lt;String&gt; resultFuture =
    Source.from(Arrays.asList(1, 2, 3, 4, 5))
        .via(new Filter&lt;Integer&gt;((n) -&gt; n % 2 == 0))
        .via(new Duplicator&lt;Integer&gt;())
        .via(new Map&lt;Integer, Integer&gt;((n) -&gt; n / 2))
        .runWith(sink, mat);
</code></pre></dd>
</dl>
<p>If we attempt to draw the sequence of events, it shows that there is one &ldquo;event token&rdquo; in circulation in a potential chain of operators, just like our conceptual &ldquo;railroad tracks&rdquo; representation predicts.</p>
<p><img src="../images/graph_stage_tracks_1.png" alt="graph_stage_tracks_1.png" /></p>
<h3><a href="#completion" name="completion" class="anchor"><span class="anchor-link"></span></a>Completion</h3>
<p>Completion handling usually (but not exclusively) comes into the picture when operators need to emit a few more elements after their upstream source has been completed. We have seen an example of this in our first <code>Duplicator</code> implementation where the last element needs to be doubled even after the upstream neighbor operator has been completed. This can be done by overriding the <code>onUpstreamFinish</code> method in <span class="group-scala"><code>InHandler</code></span><span class="group-java"><code>AbstractInHandler</code></span>.</p>
<p>Operators by default automatically stop once all of their ports (input and output) have been closed externally or internally. It is possible to opt out from this behavior by invoking <code>setKeepGoing(true)</code> (which is not supported from the operator’s constructor and usually done in <code>preStart</code>). In this case the operator <strong>must</strong> be explicitly closed by calling <code>completeStage()</code> or <code>failStage(exception)</code>. This feature carries the risk of leaking streams and actors, therefore it should be used with care.</p>
<h3><a href="#logging-inside-graphstages" name="logging-inside-graphstages" class="anchor"><span class="anchor-link"></span></a>Logging inside GraphStages</h3>
<p>Logging debug or other important information in your operators is often a very good idea, especially when developing more advanced operators which may need to be debugged at some point.</p><div class="group-scala">
<p>The helper trait <code>akka.stream.operator.StageLogging</code> is provided to enable you to obtain a <code>LoggingAdapter</code> inside of a <code>GraphStage</code> as long as the <code>Materializer</code> you&rsquo;re using is able to provide you with a logger. In that sense, it serves a very similar purpose as <code>ActorLogging</code> does for Actors. </p></div><div class="group-java">
<p>You can extend the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/stream/stage/GraphStageLogicWithLogging.html">GraphStageLogicWithLogging</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/stream/stage/GraphStageLogicWithLogging.html">GraphStageLogicWithLogging</a></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/stream/stage/TimerGraphStageLogicWithLogging.html">TimerGraphStageLogicWithLogging</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/stream/stage/TimerGraphStageLogicWithLogging.html">TimerGraphStageLogicWithLogging</a></span> classes instead of the usual <code>GraphStageLogic</code> to enable you to obtain a <code>LoggingAdapter</code> inside your operator as long as the <code>Materializer</code> you&rsquo;re using is able to provide you with a logger.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Please note that you can always use a logging library directly inside an operator. Make sure to use an asynchronous appender however, to not accidentally block the operator when writing to files etc. See <a href="../logging.html#slf4j-directly">Using the SLF4J API directly</a> for more details on setting up async appenders in SLF4J.</p></div>
<p>The operator then gets access to the <code>log</code> field which it can safely use from any <code>GraphStage</code> callbacks:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageLoggingDocSpec.scala#L19-L41" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.stream.stage.{ GraphStage, GraphStageLogic, OutHandler, StageLogging }

final class RandomLettersSource extends GraphStage[SourceShape[String]] {
  val out = Outlet[String](&quot;RandomLettersSource.out&quot;)
  override val shape: SourceShape[String] = SourceShape(out)

  override def createLogic(inheritedAttributes: Attributes) =
    new GraphStageLogic(shape) with StageLogging {
      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          val c = nextChar() // ASCII lower case letters

          // `log` is obtained from materializer automatically (via StageLogging)
          log.debug(&quot;Randomly generated: [{}]&quot;, c)

          push(out, c.toString)
        }
      })
    }

  def nextChar(): Char =
    ThreadLocalRandom.current().nextInt(&#39;a&#39;, &#39;z&#39;.toInt + 1).toChar
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageLoggingDocTest.java#L32-L68" target="_blank" title="Go to snippet source"></a><code class="language-java">public class RandomLettersSource extends GraphStage&lt;SourceShape&lt;String&gt;&gt; {
  public final Outlet&lt;String&gt; out = Outlet.create(&quot;RandomLettersSource.in&quot;);

  private final SourceShape&lt;String&gt; shape = SourceShape.of(out);

  @Override
  public SourceShape&lt;String&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogicWithLogging(shape()) {

      {
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                final String s = nextChar(); // ASCII lower case letters

                // `log` is obtained from materializer automatically (via StageLogging)
                log().debug(&quot;Randomly generated: [{}]&quot;, s);

                push(out, s);
              }

              private String nextChar() {
                final char i = (char) ThreadLocalRandom.current().nextInt(&#39;a&#39;, &#39;z&#39; + 1);
                return String.valueOf(i);
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p><strong>SPI Note:</strong> If you&rsquo;re implementing a Materializer, you can add this ability to your materializer by implementing <code>MaterializerLoggingProvider</code> in your <code>Materializer</code>.</p></div>
<h3><a href="#using-timers" name="using-timers" class="anchor"><span class="anchor-link"></span></a>Using timers</h3>
<p>It is possible to use timers in <code>GraphStages</code> by using <code>TimerGraphStageLogic</code> as the base class for the returned logic. Timers can be scheduled by calling one of <code>scheduleOnce(key,delay)</code>, <code>schedulePeriodically(key,period)</code> or <code>schedulePeriodicallyWithInitialDelay(key,delay,period)</code> and passing an object as a key for that timer (can be any object, for example a <code>String</code>). The <code>onTimer(key)</code> method needs to be overridden and it will be called once the timer of <code>key</code> fires. It is possible to cancel a timer using <code>cancelTimer(key)</code> and check the status of a timer with <code>isTimerActive(key)</code>. Timers will be automatically cleaned up when the operator completes.</p>
<p>Timers can not be scheduled from the constructor of the logic, but it is possible to schedule them from the <code>preStart()</code> lifecycle hook.</p>
<p>In this sample the operator toggles between open and closed, where open means no elements are passed through. The operator starts out as closed but as soon as an element is pushed downstream the gate becomes open for a duration of time during which it will consume and drop upstream messages:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L370-L402" target="_blank" title="Go to snippet source"></a><code class="language-scala">// each time an event is pushed through it will trigger a period of silence
class TimedGate[A](silencePeriod: FiniteDuration) extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;TimedGate.in&quot;)
  val out = Outlet[A](&quot;TimedGate.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new TimerGraphStageLogic(shape) {

      var open = false

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          if (open) pull(in)
          else {
            push(out, elem)
            open = true
            scheduleOnce(None, silencePeriod)
          }
        }
      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = { pull(in) }
      })

      override protected def onTimer(timerKey: Any): Unit = {
        open = false
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L524-L582" target="_blank" title="Go to snippet source"></a><code class="language-java">// each time an event is pushed through it will trigger a period of silence
public class TimedGate&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  private final int silencePeriodInSeconds;

  public TimedGate(int silencePeriodInSeconds) {
    this.silencePeriodInSeconds = silencePeriodInSeconds;
  }

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;TimedGate.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;TimedGate.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new TimerGraphStageLogic(shape) {

      private boolean open = false;

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() throws Exception {
                A elem = grab(in);
                if (open) pull(in);
                else {
                  push(out, elem);
                  open = true;
                  scheduleOnce(&quot;key&quot;, java.time.Duration.ofSeconds(silencePeriodInSeconds));
                }
              }
            });
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                pull(in);
              }
            });
      }

      @Override
      public void onTimer(Object key) {
        if (key.equals(&quot;key&quot;)) {
          open = false;
        }
      }
    };
  }
}</code></pre></dd>
</dl>
<h3><a href="#using-asynchronous-side-channels" name="using-asynchronous-side-channels" class="anchor"><span class="anchor-link"></span></a>Using asynchronous side-channels</h3>
<p>In order to receive asynchronous events that are not arriving as stream elements (for example a completion of a future or a callback from a 3rd party API) one must acquire a <code>AsyncCallback</code> by calling <code>getAsyncCallback()</code> from the operator logic. The method <code>getAsyncCallback</code> takes as a parameter a callback that will be called once the asynchronous event fires. It is important to <strong>not call the callback directly</strong>, instead, the external API must call the <code>invoke(event)</code> method on the returned <code>AsyncCallback</code>. The execution engine will take care of calling the provided callback in a thread-safe way. The callback can safely access the state of the <code>GraphStageLogic</code> implementation.</p>
<p>Sharing the AsyncCallback from the constructor risks race conditions, therefore it is recommended to use the <code>preStart()</code> lifecycle hook instead.</p>
<p>This example shows an asynchronous side channel operator that starts dropping elements when a future completes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L310-L336" target="_blank" title="Go to snippet source"></a><code class="language-scala">// will close upstream in all materializations of the graph stage instance
// when the future completes
class KillSwitch[A](switch: Future[Unit]) extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;KillSwitch.in&quot;)
  val out = Outlet[A](&quot;KillSwitch.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {

      override def preStart(): Unit = {
        val callback = getAsyncCallback[Unit] { (_) ⇒
          completeStage()
        }
        switch.foreach(callback.invoke)
      }

      setHandler(in, new InHandler {
        override def onPush(): Unit = { push(out, grab(in)) }
      })
      setHandler(out, new OutHandler {
        override def onPull(): Unit = { pull(in) }
      })
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L439-L498" target="_blank" title="Go to snippet source"></a><code class="language-java">// will close upstream in all materializations of the stage instance
// when the completion stage completes
public class KillSwitch&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  private final CompletionStage&lt;Done&gt; switchF;

  public KillSwitch(CompletionStage&lt;Done&gt; switchF) {
    this.switchF = switchF;
  }

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;KillSwitch.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;KillSwitch.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() {
                push(out, grab(in));
              }
            });
        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                pull(in);
              }
            });
      }

      @Override
      public void preStart() {
        AsyncCallback&lt;Done&gt; callback =
            createAsyncCallback(
                new Procedure&lt;Done&gt;() {
                  @Override
                  public void apply(Done param) throws Exception {
                    completeStage();
                  }
                });

        ExecutionContext ec = system.dispatcher();
        switchF.thenAccept(callback::invoke);
      }
    };
  }
}</code></pre></dd>
</dl>
<h3><a href="#integration-with-actors" name="integration-with-actors" class="anchor"><span class="anchor-link"></span></a>Integration with actors</h3>
<p><strong>This section is a stub and will be extended in the next release</strong> <strong>This is a <a href="../common/may-change.html">may change</a> feature</strong>*</p>
<p>It is possible to acquire an ActorRef that can be addressed from the outside of the operator, similarly how <code>AsyncCallback</code> allows injecting asynchronous events into an operator logic. This reference can be obtained by calling <code>getStageActor(receive)</code> passing in a function that takes a <code>Pair</code> of the sender <code>ActorRef</code> and the received message. This reference can be used to watch other actors by calling its <code>watch(ref)</code> or <code>unwatch(ref)</code> methods. The reference can be also watched by external actors. The current limitations of this <code>ActorRef</code> are:</p>
<ul>
  <li>they are not location transparent, they cannot be accessed via remoting.</li>
  <li>they cannot be returned as materialized values.</li>
  <li>they cannot be accessed from the constructor of the <code>GraphStageLogic</code>, but they can be accessed from the <code>preStart()</code> method.</li>
</ul>
<h3><a href="#custom-materialized-values" name="custom-materialized-values" class="anchor"><span class="anchor-link"></span></a>Custom materialized values</h3>
<p>Custom operators can return materialized values instead of <code>NotUsed</code> by inheriting from <code>GraphStageWithMaterializedValue</code> instead of the simpler <code>GraphStage</code>. The difference is that in this case the method <code>createLogicAndMaterializedValue(inheritedAttributes)</code> needs to be overridden, and in addition to the operator logic the materialized value must be provided</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>There is no built-in synchronization of accessing this value from both of the thread where the logic runs and the thread that got hold of the materialized value. It is the responsibility of the programmer to add the necessary (non-blocking) synchronization and visibility guarantees to this shared object.</p></div>
<p>In this sample the materialized value is a future containing the first element to go through the stream:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L418-L454" target="_blank" title="Go to snippet source"></a><code class="language-scala">class FirstValue[A] extends GraphStageWithMaterializedValue[FlowShape[A, A], Future[A]] {

  val in = Inlet[A](&quot;FirstValue.in&quot;)
  val out = Outlet[A](&quot;FirstValue.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[A]) = {
    val promise = Promise[A]()
    val logic = new GraphStageLogic(shape) {

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          promise.success(elem)
          push(out, elem)

          // replace handler with one that only forwards elements
          setHandler(in, new InHandler {
            override def onPush(): Unit = {
              push(out, grab(in))
            }
          })
        }
      })

      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          pull(in)
        }
      })

    }

    (logic, promise.future)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L597-L652" target="_blank" title="Go to snippet source"></a><code class="language-java">public class FirstValue&lt;A&gt;
    extends AbstractGraphStageWithMaterializedValue&lt;FlowShape&lt;A, A&gt;, CompletionStage&lt;A&gt;&gt; {

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;FirstValue.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;FirstValue.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  @Override
  public Pair&lt;GraphStageLogic, CompletionStage&lt;A&gt;&gt; createLogicAndMaterializedValuePair(
      Attributes inheritedAttributes) {
    CompletableFuture&lt;A&gt; promise = new CompletableFuture&lt;&gt;();

    GraphStageLogic logic =
        new GraphStageLogic(shape) {
          {
            setHandler(
                in,
                new AbstractInHandler() {
                  @Override
                  public void onPush() {
                    A elem = grab(in);
                    promise.complete(elem);
                    push(out, elem);

                    // replace handler with one that only forwards elements
                    setHandler(
                        in,
                        new AbstractInHandler() {
                          @Override
                          public void onPush() {
                            push(out, grab(in));
                          }
                        });
                  }
                });

            setHandler(
                out,
                new AbstractOutHandler() {
                  @Override
                  public void onPull() throws Exception {
                    pull(in);
                  }
                });
          }
        };

    return new Pair&lt;&gt;(logic, promise);
  }
}</code></pre></dd>
</dl>
<h3><a href="#using-attributes-to-affect-the-behavior-of-an-operator" name="using-attributes-to-affect-the-behavior-of-an-operator" class="anchor"><span class="anchor-link"></span></a>Using attributes to affect the behavior of an operator</h3>
<p><strong>This section is a stub and will be extended in the next release</strong></p>
<p>Operators can access the <code>Attributes</code> object created by the materializer. This contains all the applied (inherited) attributes applying to the operator, ordered from least specific (outermost) towards the most specific (innermost) attribute. It is the responsibility of the operator to decide how to reconcile this inheritance chain to a final effective decision.</p>
<p>See <a href="stream-composition.html">Modularity, Composition and Hierarchy</a> for an explanation on how attributes work.</p>
<h3><a href="#rate-decoupled-operators" name="rate-decoupled-operators" class="anchor"><span class="anchor-link"></span></a>Rate decoupled operators</h3>
<p>Sometimes it is desirable to <em>decouple</em> the rate of the upstream and downstream of an operator, synchronizing only when needed.</p>
<p>This is achieved in the model by representing a <code>GraphStage</code> as a <em>boundary</em> between two regions where the demand sent upstream is decoupled from the demand that arrives from downstream. One immediate consequence of this difference is that an <code>onPush</code> call does not always lead to calling <code>push</code> and an <code>onPull</code> call does not always lead to calling <code>pull</code>.</p>
<p>One of the important use-case for this is to build buffer-like entities, that allow independent progress of upstream and downstream operators when the buffer is not full or empty, and slowing down the appropriate side if the buffer becomes empty or full.</p>
<p>The next diagram illustrates the event sequence for a buffer with capacity of two elements in a setting where the downstream demand is slow to start and the buffer will fill up with upstream elements before any demand is seen from downstream.</p>
<p><img src="../images/graph_stage_detached_tracks_1.png" alt="graph_stage_detached_tracks_1.png" /></p>
<p>Another scenario would be where the demand from downstream starts coming in before any element is pushed into the buffer operator.</p>
<p><img src="../images/graph_stage_detached_tracks_2.png" alt="graph_stage_detached_tracks_2.png" /></p>
<p>The first difference we can notice is that our <code>Buffer</code> operator is automatically pulling its upstream on initialization. The buffer has demand for up to two elements without any downstream demand.</p>
<p>The following code example demonstrates a buffer class corresponding to the message sequence chart above.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L471-L529" target="_blank" title="Go to snippet source"></a><code class="language-scala">class TwoBuffer[A] extends GraphStage[FlowShape[A, A]] {

  val in = Inlet[A](&quot;TwoBuffer.in&quot;)
  val out = Outlet[A](&quot;TwoBuffer.out&quot;)

  val shape = FlowShape.of(in, out)

  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =
    new GraphStageLogic(shape) {

      val buffer = mutable.Queue[A]()
      def bufferFull = buffer.size == 2
      var downstreamWaiting = false

      override def preStart(): Unit = {
        // a detached stage needs to start upstream demand
        // itself as it is not triggered by downstream demand
        pull(in)
      }

      setHandler(in, new InHandler {
        override def onPush(): Unit = {
          val elem = grab(in)
          buffer.enqueue(elem)
          if (downstreamWaiting) {
            downstreamWaiting = false
            val bufferedElem = buffer.dequeue()
            push(out, bufferedElem)
          }
          if (!bufferFull) {
            pull(in)
          }
        }

        override def onUpstreamFinish(): Unit = {
          if (buffer.nonEmpty) {
            // emit the rest if possible
            emitMultiple(out, buffer.toIterator)
          }
          completeStage()
        }
      })

      setHandler(out, new OutHandler {
        override def onPull(): Unit = {
          if (buffer.isEmpty) {
            downstreamWaiting = true
          } else {
            val elem = buffer.dequeue
            push(out, elem)
          }
          if (!bufferFull &amp;&amp; !hasBeenPulled(in)) {
            pull(in)
          }
        }
      })
    }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/GraphStageDocTest.java#L668-L746" target="_blank" title="Go to snippet source"></a><code class="language-java">public class TwoBuffer&lt;A&gt; extends GraphStage&lt;FlowShape&lt;A, A&gt;&gt; {

  public final Inlet&lt;A&gt; in = Inlet.create(&quot;TwoBuffer.in&quot;);
  public final Outlet&lt;A&gt; out = Outlet.create(&quot;TwoBuffer.out&quot;);

  private final FlowShape&lt;A, A&gt; shape = FlowShape.of(in, out);

  @Override
  public FlowShape&lt;A, A&gt; shape() {
    return shape;
  }

  @Override
  public GraphStageLogic createLogic(Attributes inheritedAttributes) {
    return new GraphStageLogic(shape) {

      private final int SIZE = 2;
      private Queue&lt;A&gt; buffer = new ArrayDeque&lt;&gt;(SIZE);
      private boolean downstreamWaiting = false;

      private boolean isBufferFull() {
        return buffer.size() == SIZE;
      }

      @Override
      public void preStart() {
        // a detached stage needs to start upstream demand
        // itself as it is not triggered by downstream demand
        pull(in);
      }

      {
        setHandler(
            in,
            new AbstractInHandler() {
              @Override
              public void onPush() {
                A elem = grab(in);
                buffer.add(elem);
                if (downstreamWaiting) {
                  downstreamWaiting = false;
                  A bufferedElem = buffer.poll();
                  push(out, bufferedElem);
                }
                if (!isBufferFull()) {
                  pull(in);
                }
              }

              @Override
              public void onUpstreamFinish() {
                if (!buffer.isEmpty()) {
                  // emit the rest if possible
                  emitMultiple(out, buffer.iterator());
                }
                completeStage();
              }
            });

        setHandler(
            out,
            new AbstractOutHandler() {
              @Override
              public void onPull() throws Exception {
                if (buffer.isEmpty()) {
                  downstreamWaiting = true;
                } else {
                  A elem = buffer.poll();
                  push(out, elem);
                }
                if (!isBufferFull() &amp;&amp; !hasBeenPulled(in)) {
                  pull(in);
                }
              }
            });
      }
    };
  }
}</code></pre></dd>
</dl>
<h2><a href="#thread-safety-of-custom-operators" name="thread-safety-of-custom-operators" class="anchor"><span class="anchor-link"></span></a>Thread safety of custom operators</h2>
<dl>
  <dt>All of the above custom operators (linear or graph) provide a few simple guarantees that implementors can rely on.
  </dt>
  <dd></dd>
</dl>
<ul>
  <li>The callbacks exposed by all of these classes are never called concurrently.</li>
  <li>The state encapsulated by these classes can be safely modified from the provided callbacks, without any further synchronization.</li>
</ul>
<p>In essence, the above guarantees are similar to what <code>Actor</code> s provide, if one thinks of the state of a custom operator as state of an actor, and the callbacks as the <code>receive</code> block of the actor.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>It is <strong>not safe</strong> to access the state of any custom operator outside of the callbacks that it provides, just like it is unsafe to access the state of an actor from the outside. This means that Future callbacks should <strong>not close over</strong> internal state of custom operators because such access can be concurrent with the provided callbacks, leading to undefined behavior.</p></div>
<h2><a href="#resources-and-the-operator-lifecycle" name="resources-and-the-operator-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resources and the operator lifecycle</h2>
<p>If an operator manages a resource with a lifecycle, for example objects that need to be shutdown when they are not used anymore it is important to make sure this will happen in all circumstances when the operator shuts down.</p>
<p>Cleaning up resources should be done in <code>GraphStageLogic.postStop</code> and not in the <code>InHandler</code> and <code>OutHandler</code> callbacks. The reason for this is that when the operator itself completes or is failed there is no signal from the upstreams or the downstreams. Even for operators that do not complete or fail in this manner, this can happen when the <code>Materializer</code> is shutdown or the <code>ActorSystem</code> is terminated while a stream is still running, what is called an &ldquo;abrupt termination&rdquo;.</p><div class="group-scala">
<h2><a href="#extending-flow-operators-with-custom-operators" name="extending-flow-operators-with-custom-operators" class="anchor"><span class="anchor-link"></span></a>Extending Flow Operators with Custom Operators</h2>
<p>The most general way of extending any <code>Source</code>, <code>Flow</code> or <code>SubFlow</code> (e.g. from <code>groupBy</code>) is demonstrated above: create an operator of flow-shape like the <code>Duplicator</code> example given above and use the <code>.via(...)</code> operator to integrate it into your stream topology. This works with all <code>FlowOps</code> sub-types, including the ports that you connect with the graph DSL.</p>
<p>Advanced Scala users may wonder whether it is possible to write extension methods that enrich <code>FlowOps</code> to allow nicer syntax. The short answer is that Scala 2 does not support this in a fully generic fashion, the problem is that it is impossible to abstract over the kind of stream that is being extended because <code>Source</code>, <code>Flow</code> and <code>SubFlow</code> differ in the number and kind of their type parameters. While it would be possible to write an implicit class that enriches them generically, this class would require explicit instantiation with all type parameters due to <a href="https://issues.scala-lang.org/browse/SI-2712">SI-2712</a>. For a partial workaround that unifies extensions to <code>Source</code> and <code>Flow</code> see <a href="https://gist.github.com/rkuhn/2870fcee4937dda2cad5">this sketch by R. Kuhn</a>.</p>
<p>A lot simpler is the task of adding an extension method to <code>Source</code> as shown below:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L560-L566" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit class SourceDuplicator[Out, Mat](s: Source[Out, Mat]) {
  def duplicateElements: Source[Out, Mat] = s.via(new Duplicator)
}

val s = Source(1 to 3).duplicateElements

s.runWith(Sink.seq).futureValue should ===(Seq(1, 1, 2, 2, 3, 3))</code></pre>
<p>The analog works for <code>Flow</code> as well:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/GraphStageDocSpec.scala#L572-L578" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit class FlowDuplicator[In, Out, Mat](s: Flow[In, Out, Mat]) {
  def duplicateElements: Flow[In, Out, Mat] = s.via(new Duplicator)
}

val f = Flow[Int].duplicateElements

Source(1 to 3).via(f).runWith(Sink.seq).futureValue should ===(Seq(1, 1, 2, 2, 3, 3))</code></pre>
<p>If you try to write this for <code>SubFlow</code>, though, you will run into the same issue as when trying to unify the two solutions above, only on a higher level (the type constructors needed for that unification would have rank two, meaning that some of their type arguments are type constructors themselves—when trying to extend the solution shown in the linked sketch the author encountered such a density of compiler StackOverflowErrors and IDE failures that he gave up).</p>
<p>It is interesting to note that a simplified form of this problem has found its way into the <a href="https://github.com/lampepfl/dotty/pull/1186/files">dotty test suite</a>. Dotty is the development version of Scala on its way to Scala 3.</p></div>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../stream/stream-dynamic.html"><i class="icon-prev"></i> <span class="link-prev">Dynamic stream handling</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../stream/stream-integrations.html">Integration <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/stream/stream-customize.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
