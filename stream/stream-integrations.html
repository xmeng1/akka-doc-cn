<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Integration &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/stream/stream-integrations.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html#integration" class="active page">Integration</a>
    <ul>
      <li><a href="../stream/stream-integrations.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-actors" class="header">Integrating with Actors</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-external-services" class="header">Integrating with External Services</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-reactive-streams" class="header">Integrating with Reactive Streams</a></li>
    </ul></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a>
  <ul>
    <li><a href="../stream/index.html#dependency" class="header">Dependency</a></li>
    <li><a href="../stream/stream-introduction.html" class="page">Introduction</a></li>
    <li><a href="../stream/stream-quickstart.html" class="page">Streams Quickstart Guide</a></li>
    <li><a href="../general/stream/stream-design.html" class="page">Design Principles behind Akka Streams</a></li>
    <li><a href="../stream/stream-flows-and-basics.html" class="page">Basics and working with Flows</a></li>
    <li><a href="../stream/stream-graphs.html" class="page">Working with Graphs</a></li>
    <li><a href="../stream/stream-composition.html" class="page">Modularity, Composition and Hierarchy</a></li>
    <li><a href="../stream/stream-rate.html" class="page">Buffers and working with rate</a></li>
    <li><a href="../stream/stream-dynamic.html" class="page">Dynamic stream handling</a></li>
    <li><a href="../stream/stream-customize.html" class="page">Custom stream processing</a></li>
    <li><a href="../stream/stream-integrations.html#integration" class="active page">Integration</a>
    <ul>
      <li><a href="../stream/stream-integrations.html#dependency" class="header">Dependency</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-actors" class="header">Integrating with Actors</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-external-services" class="header">Integrating with External Services</a></li>
      <li><a href="../stream/stream-integrations.html#integrating-with-reactive-streams" class="header">Integrating with Reactive Streams</a></li>
    </ul></li>
    <li><a href="../stream/stream-error.html" class="page">Error Handling in Streams</a></li>
    <li><a href="../stream/stream-io.html" class="page">Working with streaming IO</a></li>
    <li><a href="../stream/stream-refs.html" class="page">StreamRefs - Reactive Streams over the network</a></li>
    <li><a href="../stream/stream-parallelism.html" class="page">Pipelining and Parallelism</a></li>
    <li><a href="../stream/stream-testkit.html" class="page">Testing streams</a></li>
    <li><a href="../stream/stream-substream.html" class="page">Substreams</a></li>
    <li><a href="../stream/stream-cookbook.html" class="page">Streams Cookbook</a></li>
    <li><a href="../general/stream/stream-configuration.html" class="page">Configuration</a></li>
    <li><a href="../stream/operators/index.html" class="page">Operators</a></li>
  </ul></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#integration" name="integration" class="anchor"><span class="anchor-link"></span></a>Integration</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Streams, add the module to your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-stream" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-stream_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-stream_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#integrating-with-actors" name="integrating-with-actors" class="anchor"><span class="anchor-link"></span></a>Integrating with Actors</h2>
<p>For piping the elements of a stream as messages to an ordinary actor you can use <code>ask</code> in a <code>mapAsync</code> or use <code>Sink.actorRefWithAck</code>.</p>
<p>Messages can be sent to a stream with <code>Source.queue</code> or via the <code>ActorRef</code> that is materialized by <code>Source.actorRef</code>.</p>
<h3><a href="#ask" name="ask" class="anchor"><span class="anchor-link"></span></a>ask</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Source-or-Flow/ask.html">Flow.ask operator reference docs</a>, <a href="operators/ActorFlow/ask.html">ActorFlow.ask operator reference docs</a> for Akka Typed</p></div>
<p>A nice way to delegate some processing of elements in a stream to an actor is to use <code>ask</code>. The back-pressure of the stream is maintained by the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and the mailbox of the actor will not be filled with more messages than the given <code>parallelism</code> of the <code>ask</code> operator (similarly to how the <code>mapAsync</code> operator works).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L145-L153" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit val askTimeout = Timeout(5.seconds)
val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

words
  .ask[String](parallelism = 5)(ref)
  // continue processing of the replies from the actor
  .map(_.toLowerCase)
  .runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L393-L400" target="_blank" title="Go to snippet source"></a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));
Timeout askTimeout = Timeout.apply(5, TimeUnit.SECONDS);

words
    .ask(5, ref, String.class, askTimeout)
    // continue processing of the replies from the actor
    .map(elem -&gt; elem.toLowerCase())
    .runWith(Sink.ignore(), mat);</code></pre></dd>
</dl>
<p>Note that the messages received in the actor will be in the same order as the stream elements, i.e. the <code>parallelism</code> does not change the ordering of the messages. There is a performance advantage of using parallelism &gt; 1 even though the actor will only process one message at a time because then there is already a message in the mailbox when the actor has completed previous message.</p>
<p>The actor must reply to the <span class="group-scala"><code>sender()</code></span><span class="group-java"><code>getSender()</code></span> for each message from the stream. That reply will complete the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the <code>ask</code> and it will be the element that is emitted downstreams.</p>
<p>In case the target actor is stopped, the operator will fail with an <code>AskStageTargetActorTerminatedException</code></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L124-L131" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Translator extends Actor {
  def receive = {
    case word: String ⇒
      // ... process message
      val reply = word.toUpperCase
      sender() ! reply // reply to the ask
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L309-L323" target="_blank" title="Go to snippet source"></a><code class="language-java">static class Translator extends AbstractActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            word -&gt; {
              // ... process message
              String reply = word.toUpperCase();
              // reply to the ask
              getSender().tell(reply, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>The stream can be completed with failure by sending <code>akka.actor.Status.Failure</code> as reply from the actor.</p>
<p>If the <code>ask</code> fails due to timeout the stream will be completed with <code>TimeoutException</code> failure. If that is not desired outcome you can use <code>recover</code> on the <code>ask</code> <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, or use the other &ldquo;restart&rdquo; operators to restart it.</p>
<p>If you don&rsquo;t care about the reply values and only use them as back-pressure signals you can use <code>Sink.ignore</code> after the <code>ask</code> operator and then actor is effectively a sink of the stream.</p>
<p>Note that while you may implement the same concept using <code>mapAsync</code>, that style would not be aware of the actor terminating.</p>
<p>If you are intending to ask multiple actors by using <a href="../routing.html">Actor routers</a>, then you should use <code>mapAsyncUnordered</code> and perform the ask manually in there, as the ordering of the replies is not important, since multiple actors are being asked concurrently to begin with, and no single actor is the one to be watched by the operator.</p>
<h3><a href="#sink-actorrefwithack" name="sink-actorrefwithack" class="anchor"><span class="anchor-link"></span></a>Sink.actorRefWithAck</h3><div class="callout note "><div class="callout-title">Note</div>
<p>See also: <a href="operators/Sink/actorRefWithAck.html">Sink.actorRefWithAck operator reference docs</a></p></div>
<p>The sink sends the elements of the stream to the given <code>ActorRef</code> that sends back back-pressure signal. First element is always <em>onInitMessage</em>, then stream is waiting for the given acknowledgement message from the given actor which means that it is ready to process elements. It also requires the given acknowledgement message after each stream element to make back-pressure work.</p>
<p>If the target actor terminates the stream will be cancelled. When the stream is completed successfully the given <code>onCompleteMessage</code> will be sent to the destination actor. When the stream is completed with failure a <code>akka.actor.Status.Failure</code> message will be sent to the destination actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L199-L228" target="_blank" title="Go to snippet source"></a><code class="language-scala">val words: Source[String, NotUsed] =
  Source(List(&quot;hello&quot;, &quot;hi&quot;))

// sent from actor to stream to &quot;ack&quot; processing of given element
val AckMessage = AckingReceiver.Ack

// sent from stream to actor to indicate start, end or failure of stream:
val InitMessage = AckingReceiver.StreamInitialized
val OnCompleteMessage = AckingReceiver.StreamCompleted
val onErrorMessage = (ex: Throwable) ⇒ AckingReceiver.StreamFailure(ex)

val probe = TestProbe()
val receiver = system.actorOf(
  Props(new AckingReceiver(probe.ref, ackWith = AckMessage)))
val sink = Sink.actorRefWithAck(
  receiver,
  onInitMessage = InitMessage,
  ackMessage = AckMessage,
  onCompleteMessage = OnCompleteMessage,
  onFailureMessage = onErrorMessage
)

words
  .map(_.toLowerCase)
  .runWith(sink)

probe.expectMsg(&quot;Stream initialized!&quot;)
probe.expectMsg(&quot;hello&quot;)
probe.expectMsg(&quot;hi&quot;)
probe.expectMsg(&quot;Stream completed!&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L407-L426" target="_blank" title="Go to snippet source"></a><code class="language-java">Source&lt;String, NotUsed&gt; words = Source.from(Arrays.asList(&quot;hello&quot;, &quot;hi&quot;));

final TestKit probe = new TestKit(system);

ActorRef receiver = system.actorOf(Props.create(AckingReceiver.class, probe.getRef()));

Sink&lt;String, NotUsed&gt; sink =
    Sink.&lt;String&gt;actorRefWithAck(
        receiver,
        new StreamInitialized(),
        Ack.INSTANCE,
        new StreamCompleted(),
        ex -&gt; new StreamFailure(ex));

words.map(el -&gt; el.toLowerCase()).runWith(sink, mat);

probe.expectMsg(&quot;Stream initialized&quot;);
probe.expectMsg(&quot;hello&quot;);
probe.expectMsg(&quot;hi&quot;);
probe.expectMsg(&quot;Stream completed&quot;);</code></pre></dd>
</dl>
<p>The receiving actor would then need to be implemented similar to the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L233-L261" target="_blank" title="Go to snippet source"></a><code class="language-scala">object AckingReceiver {
  case object Ack

  case object StreamInitialized
  case object StreamCompleted
  final case class StreamFailure(ex: Throwable)
}

class AckingReceiver(probe: ActorRef, ackWith: Any) extends Actor with ActorLogging {
  import AckingReceiver._

  def receive: Receive = {
    case StreamInitialized ⇒
      log.info(&quot;Stream initialized!&quot;)
      probe ! &quot;Stream initialized!&quot;
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case el: String ⇒
      log.info(&quot;Received element: {}&quot;, el)
      probe ! el
      sender() ! Ack // ack to allow the stream to proceed sending more elements

    case StreamCompleted ⇒
      log.info(&quot;Stream completed!&quot;)
      probe ! &quot;Stream completed!&quot;
    case StreamFailure(ex) ⇒
      log.error(ex, &quot;Stream failed!&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L327-L386" target="_blank" title="Go to snippet source"></a><code class="language-java">enum Ack {
  INSTANCE;
}

static class StreamInitialized {}

static class StreamCompleted {}

static class StreamFailure {
  private final Throwable cause;

  public StreamFailure(Throwable cause) {
    this.cause = cause;
  }

  public Throwable getCause() {
    return cause;
  }
}

static class AckingReceiver extends AbstractLoggingActor {

  private final ActorRef probe;

  public AckingReceiver(ActorRef probe) {
    this.probe = probe;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            StreamInitialized.class,
            init -&gt; {
              log().info(&quot;Stream initialized&quot;);
              probe.tell(&quot;Stream initialized&quot;, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            String.class,
            element -&gt; {
              log().info(&quot;Received element: {}&quot;, element);
              probe.tell(element, getSelf());
              sender().tell(Ack.INSTANCE, self());
            })
        .match(
            StreamCompleted.class,
            completed -&gt; {
              log().info(&quot;Stream completed&quot;);
              probe.tell(&quot;Stream completed&quot;, getSelf());
            })
        .match(
            StreamFailure.class,
            failed -&gt; {
              log().error(failed.getCause(), &quot;Stream failed!&quot;);
              probe.tell(&quot;Stream failed!&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Note that replying to the sender of the elements (the &ldquo;stream&rdquo;) is required as lack of those ack signals would be interpreted as back-pressure (as intended), and no new elements will be sent into the actor until it acknowledges some elements. Handling the other signals while is not required, however is a good practice, to see the state of the streams lifecycle in the connected actor as well. Technically it is also possible to use multiple sinks targeting the same actor, however it is not common practice to do so, and one should rather investigate using a <code>Merge</code> operator for this purpose.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Using <code>Sink.actorRef</code> or ordinary <code>tell</code> from a <code>map</code> or <code>foreach</code> operator means that there is no back-pressure signal from the destination actor, i.e. if the actor is not consuming the messages fast enough the mailbox of the actor will grow, unless you use a bounded mailbox with zero <em>mailbox-push-timeout-time</em> or use a rate limiting operator in front. It&rsquo;s often better to use <code>Sink.actorRefWithAck</code> or <code>ask</code> in <code>mapAsync</code>, though.</p></div>
<h3><a href="#source-queue" name="source-queue" class="anchor"><span class="anchor-link"></span></a>Source.queue</h3>
<p><code>Source.queue</code> is an improvement over <code>Sink.actorRef</code>, since it can provide backpressure. The <code>offer</code> method returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>, which completes with the result of the enqueue operation.</p>
<p><code>Source.queue</code> can be used for emitting elements to a stream from an actor (or from anything running outside the stream). The elements will be buffered until the stream can process them. You can <code>offer</code> elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Use overflow strategy <code>akka.stream.OverflowStrategy.backpressure</code> to avoid dropping of elements if the buffer is full, instead the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> does not complete until there is space in the buffer and <code>offer</code> should not be called again until it completes.</p>
<p>Using <code>Source.queue</code> you can push elements to the queue and they will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received. Elements in the buffer will be discarded if downstream is terminated.</p>
<p>You could combine it with the <a href="operators/Source-or-Flow/throttle.html"><code>throttle</code></a> operator is used to slow down the stream to <code>5 element</code> per <code>3 seconds</code> and other patterns.</p>
<p><code>SourceQueue.offer</code> returns <span class="group-scala"><code>Future[QueueOfferResult]</code></span><span class="group-java"><code>CompletionStage&lt;QueueOfferResult&gt;</code></span> which completes with <code>QueueOfferResult.Enqueued</code> if element was added to buffer or sent downstream. It completes with <code>QueueOfferResult.Dropped</code> if element was dropped. Can also complete with <code>QueueOfferResult.Failure</code> - when stream failed or <code>QueueOfferResult.QueueClosed</code> when downstream is completed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L478-L498" target="_blank" title="Go to snippet source"></a><code class="language-scala">val bufferSize = 10
val elementsToProcess = 5

val queue = Source
  .queue[Int](bufferSize, OverflowStrategy.backpressure)
  .throttle(elementsToProcess, 3.second)
  .map(x ⇒ x * x)
  .toMat(Sink.foreach(x ⇒ println(s&quot;completed $x&quot;)))(Keep.left)
  .run()

val source = Source(1 to 10)

implicit val ec = system.dispatcher
source.mapAsync(1)(x ⇒ {
  queue.offer(x).map {
    case QueueOfferResult.Enqueued    ⇒ println(s&quot;enqueued $x&quot;)
    case QueueOfferResult.Dropped     ⇒ println(s&quot;dropped $x&quot;)
    case QueueOfferResult.Failure(ex) ⇒ println(s&quot;Offer failed ${ex.getMessage}&quot;)
    case QueueOfferResult.QueueClosed ⇒ println(&quot;Source Queue closed&quot;)
  }
}).runWith(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L755-L768" target="_blank" title="Go to snippet source"></a><code class="language-java">int bufferSize = 10;
int elementsToProcess = 5;

SourceQueueWithComplete&lt;Integer&gt; sourceQueue =
    Source.&lt;Integer&gt;queue(bufferSize, OverflowStrategy.backpressure())
        .throttle(elementsToProcess, Duration.ofSeconds(3))
        .map(x -&gt; x * x)
        .to(Sink.foreach(x -&gt; System.out.println(&quot;got: &quot; + x)))
        .run(mat);

Source&lt;Integer, NotUsed&gt; source = Source.from(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

source.map(x -&gt; sourceQueue.offer(x)).runWith(Sink.ignore(), mat);
</code></pre></dd>
</dl>
<p>When used from an actor you typically <code>pipe</code> the result of the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> back to the actor to continue processing.</p>
<h3><a href="#source-actorref" name="source-actorref" class="anchor"><span class="anchor-link"></span></a>Source.actorRef</h3>
<p>Messages sent to the actor that is materialized by <code>Source.actorRef</code> will be emitted to the stream if there is demand from downstream, otherwise they will be buffered until request for demand is received.</p>
<p>Depending on the defined <code>OverflowStrategy</code> it might drop elements if there is no space available in the buffer. The strategy <code>OverflowStrategy.backpressure</code> is not supported for this Source type, i.e. elements will be dropped if the buffer is filled by sending at a rate that is faster than the stream can consume. You should consider using <code>Source.queue</code> if you want a backpressured actor interface.</p>
<p>The stream can be completed successfully by sending <code>akka.actor.Status.Success</code> to the actor reference.</p>
<p>The stream can be completed with failure by sending <code>akka.actor.Status.Failure</code> to the actor reference.</p>
<p>The actor will be stopped when the stream is completed, failed or cancelled from downstream, i.e. you can watch it to get notified when that happens.</p>
<h2><a href="#integrating-with-external-services" name="integrating-with-external-services" class="anchor"><span class="anchor-link"></span></a>Integrating with External Services</h2>
<p>Stream transformations and side effects involving external non-stream based services can be performed with <code>mapAsync</code> or <code>mapAsyncUnordered</code>.</p>
<p>For example, sending emails to the authors of selected tweets using an external email service:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L69-L75" target="_blank" title="Go to snippet source"></a><code class="language-scala">def send(email: Email): Future[Unit] = {
  // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L191-L197" target="_blank" title="Go to snippet source"></a><code class="language-java">public CompletionStage&lt;Email&gt; send(Email email) {
  // ...
}</code></pre></dd>
</dl>
<p>We start with the tweet stream of authors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L163-L166" target="_blank" title="Go to snippet source"></a><code class="language-scala">val authors: Source[Author, NotUsed] =
  tweets
    .filter(_.hashtags.contains(akkaTag))
    .map(_.author)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L439-L441" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;Author, NotUsed&gt; authors =
    tweets.filter(t -&gt; t.hashtags().contains(AKKA)).map(t -&gt; t.author);
</code></pre></dd>
</dl>
<p>Assume that we can lookup their email address using:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">def lookupEmail(handle: String): Future[Option[String]] =</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L78" target="_blank" title="Go to snippet source"></a><code class="language-java">public CompletionStage&lt;Optional&lt;String&gt;&gt; lookupEmail(String handle)</code></pre></dd>
</dl>
<p>Transforming the stream of authors to a stream of email addresses by using the <code>lookupEmail</code> service can be done with <code>mapAsync</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L170-L173" target="_blank" title="Go to snippet source"></a><code class="language-scala">val emailAddresses: Source[String, NotUsed] =
  authors
    .mapAsync(4)(author ⇒ addressSystem.lookupEmail(author.handle))
    .collect { case Some(emailAddress) ⇒ emailAddress }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L445-L450" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;String, NotUsed&gt; emailAddresses =
    authors
        .mapAsync(4, author -&gt; addressSystem.lookupEmail(author.handle))
        .filter(o -&gt; o.isPresent())
        .map(o -&gt; o.get());
</code></pre></dd>
</dl>
<p>Finally, sending the emails:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L177-L185" target="_blank" title="Go to snippet source"></a><code class="language-scala">val sendEmails: RunnableGraph[NotUsed] =
  emailAddresses
    .mapAsync(4)(address ⇒ {
      emailServer.send(
        Email(to = address, title = &quot;Akka&quot;, body = &quot;I like your tweet&quot;))
    })
    .to(Sink.ignore)

sendEmails.run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L454-L460" target="_blank" title="Go to snippet source"></a><code class="language-java">final RunnableGraph&lt;NotUsed&gt; sendEmails =
    emailAddresses
        .mapAsync(
            4, address -&gt; emailServer.send(new Email(address, &quot;Akka&quot;, &quot;I like your tweet&quot;)))
        .to(Sink.ignore());

sendEmails.run(mat);</code></pre></dd>
</dl>
<p><code>mapAsync</code> is applying the given function that is calling out to the external service to each of the elements as they pass through this processing step. The function returns a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> and the value of that future will be emitted downstreams. The number of Futures that shall run in parallel is given as the first argument to <code>mapAsync</code>. These Futures may complete in any order, but the elements that are emitted downstream are in the same order as received from upstream.</p>
<p>That means that back-pressure works as expected. For example if the <code>emailServer.send</code> is the bottleneck it will limit the rate at which incoming tweets are retrieved and email addresses looked up.</p>
<p>The final piece of this pipeline is to generate the demand that pulls the tweet authors information through the emailing pipeline: we attach a <code>Sink.ignore</code> which makes it all run. If our email process would return some interesting data for further transformation then we would not ignore it but send that result stream onwards for further processing or storage.</p>
<p>Note that <code>mapAsync</code> preserves the order of the stream elements. In this example the order is not important and then we can use the more efficient <code>mapAsyncUnordered</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L286-L302" target="_blank" title="Go to snippet source"></a><code class="language-scala">val authors: Source[Author, NotUsed] =
  tweets.filter(_.hashtags.contains(akkaTag)).map(_.author)

val emailAddresses: Source[String, NotUsed] =
  authors
    .mapAsyncUnordered(4)(author ⇒ addressSystem.lookupEmail(author.handle))
    .collect { case Some(emailAddress) ⇒ emailAddress }

val sendEmails: RunnableGraph[NotUsed] =
  emailAddresses
    .mapAsyncUnordered(4)(address ⇒ {
      emailServer.send(
        Email(to = address, title = &quot;Akka&quot;, body = &quot;I like your tweet&quot;))
    })
    .to(Sink.ignore)

sendEmails.run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L507-L522" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;Author, NotUsed&gt; authors =
    tweets.filter(t -&gt; t.hashtags().contains(AKKA)).map(t -&gt; t.author);

final Source&lt;String, NotUsed&gt; emailAddresses =
    authors
        .mapAsyncUnordered(4, author -&gt; addressSystem.lookupEmail(author.handle))
        .filter(o -&gt; o.isPresent())
        .map(o -&gt; o.get());

final RunnableGraph&lt;NotUsed&gt; sendEmails =
    emailAddresses
        .mapAsyncUnordered(
            4, address -&gt; emailServer.send(new Email(address, &quot;Akka&quot;, &quot;I like your tweet&quot;)))
        .to(Sink.ignore());

sendEmails.run(mat);</code></pre></dd>
</dl>
<p>In the above example the services conveniently returned a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> of the result. If that is not the case you need to wrap the call in a <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>. If the service call involves blocking you must also make sure that you run it on a dedicated execution context, to avoid starvation and disturbance of other tasks in the system.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L327-L339" target="_blank" title="Go to snippet source"></a><code class="language-scala">val blockingExecutionContext = system.dispatchers.lookup(&quot;blocking-dispatcher&quot;)

val sendTextMessages: RunnableGraph[NotUsed] =
  phoneNumbers
    .mapAsync(4)(phoneNo ⇒ {
      Future {
        smsServer.send(
          TextMessage(to = phoneNo, body = &quot;I like your tweet&quot;))
      }(blockingExecutionContext)
    })
    .to(Sink.ignore)

sendTextMessages.run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L546-L558" target="_blank" title="Go to snippet source"></a><code class="language-java">final Executor blockingEc = system.dispatchers().lookup(&quot;blocking-dispatcher&quot;);

final RunnableGraph&lt;NotUsed&gt; sendTextMessages =
    phoneNumbers
        .mapAsync(
            4,
            phoneNo -&gt;
                CompletableFuture.supplyAsync(
                    () -&gt; smsServer.send(new TextMessage(phoneNo, &quot;I like your tweet&quot;)),
                    blockingEc))
        .to(Sink.ignore());

sendTextMessages.run(mat);</code></pre></dd>
</dl>
<p>The configuration of the <code>&quot;blocking-dispatcher&quot;</code> may look something like:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L33-L39" target="_blank" title="Go to snippet source"></a><code class="language-scala">blocking-dispatcher {
  executor = &quot;thread-pool-executor&quot;
  thread-pool-executor {
    core-pool-size-min    = 10
    core-pool-size-max    = 10
  }
}</code></pre>
<p>An alternative for blocking calls is to perform them in a <code>map</code> operation, still using a dedicated dispatcher for that operation.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L364-L372" target="_blank" title="Go to snippet source"></a><code class="language-scala">val send = Flow[String]
  .map { phoneNo ⇒
    smsServer.send(TextMessage(to = phoneNo, body = &quot;I like your tweet&quot;))
  }
  .withAttributes(ActorAttributes.dispatcher(&quot;blocking-dispatcher&quot;))
val sendTextMessages: RunnableGraph[NotUsed] =
  phoneNumbers.via(send).to(Sink.ignore)

sendTextMessages.run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L594-L600" target="_blank" title="Go to snippet source"></a><code class="language-java">final Flow&lt;String, Boolean, NotUsed&gt; send =
    Flow.of(String.class)
        .map(phoneNo -&gt; smsServer.send(new TextMessage(phoneNo, &quot;I like your tweet&quot;)))
        .withAttributes(ActorAttributes.dispatcher(&quot;blocking-dispatcher&quot;));
final RunnableGraph&lt;?&gt; sendTextMessages = phoneNumbers.via(send).to(Sink.ignore());

sendTextMessages.run(mat);</code></pre></dd>
</dl>
<p>However, that is not exactly the same as <code>mapAsync</code>, since the <code>mapAsync</code> may run several calls concurrently, but <code>map</code> performs them one at a time.</p>
<p>For a service that is exposed as an actor, or if an actor is used as a gateway in front of an external service, you can use <code>ask</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L389-L397" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.pattern.ask

val akkaTweets: Source[Tweet, NotUsed] = tweets.filter(_.hashtags.contains(akkaTag))

implicit val timeout = Timeout(3.seconds)
val saveTweets: RunnableGraph[NotUsed] =
  akkaTweets
    .mapAsync(4)(tweet ⇒ database ? Save(tweet))
    .to(Sink.ignore)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L625-L630" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;Tweet, NotUsed&gt; akkaTweets = tweets.filter(t -&gt; t.hashtags().contains(AKKA));

final RunnableGraph&lt;NotUsed&gt; saveTweets =
    akkaTweets
        .mapAsync(4, tweet -&gt; ask(database, new Save(tweet), Duration.ofMillis(300L)))
        .to(Sink.ignore());</code></pre></dd>
</dl>
<p>Note that if the <code>ask</code> is not completed within the given timeout the stream is completed with failure. If that is not desired outcome you can use <code>recover</code> on the <code>ask</code> <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span>.</p>
<h3><a href="#illustrating-ordering-and-parallelism" name="illustrating-ordering-and-parallelism" class="anchor"><span class="anchor-link"></span></a>Illustrating ordering and parallelism</h3>
<p>Let us look at another example to get a better understanding of the ordering and parallelism characteristics of <code>mapAsync</code> and <code>mapAsyncUnordered</code>.</p>
<p>Several <code>mapAsync</code> and <code>mapAsyncUnordered</code> futures may run concurrently. The number of concurrent futures are limited by the downstream demand. For example, if 5 elements have been requested by downstream there will be at most 5 futures in progress.</p>
<p><code>mapAsync</code> emits the future results in the same order as the input elements were received. That means that completed results are only emitted downstream when earlier results have been completed and emitted. One slow call will thereby delay the results of all successive calls, even though they are completed before the slow call.</p>
<p><code>mapAsyncUnordered</code> emits the future results as soon as they are completed, i.e. it is possible that the elements are not emitted downstream in the same order as received from upstream. One slow call will thereby not delay the results of faster successive calls as long as there is downstream demand of several elements.</p>
<p>Here is a fictive service that we can use to illustrate these aspects.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L102-L120" target="_blank" title="Go to snippet source"></a><code class="language-scala">class SometimesSlowService(implicit ec: ExecutionContext) {

  private val runningCount = new AtomicInteger

  def convert(s: String): Future[String] = {
    println(s&quot;running: $s (${runningCount.incrementAndGet()})&quot;)
    Future {
      if (s.nonEmpty &amp;&amp; s.head.isLower)
        Thread.sleep(500)
      else
        Thread.sleep(20)
      println(s&quot;completed: $s (${runningCount.decrementAndGet()})&quot;)
      s.toUpperCase
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L277-L305" target="_blank" title="Go to snippet source"></a><code class="language-java">static class SometimesSlowService {
  private final Executor ec;

  public SometimesSlowService(Executor ec) {
    this.ec = ec;
  }

  private final AtomicInteger runningCount = new AtomicInteger();

  public CompletionStage&lt;String&gt; convert(String s) {
    System.out.println(&quot;running: &quot; + s + &quot;(&quot; + runningCount.incrementAndGet() + &quot;)&quot;);
    return CompletableFuture.supplyAsync(
        () -&gt; {
          if (!s.isEmpty() &amp;&amp; Character.isLowerCase(s.charAt(0)))
            try {
              Thread.sleep(500);
            } catch (InterruptedException e) {
            }
          else
            try {
              Thread.sleep(20);
            } catch (InterruptedException e) {
            }
          System.out.println(&quot;completed: &quot; + s + &quot;(&quot; + runningCount.decrementAndGet() + &quot;)&quot;);
          return s.toUpperCase();
        },
        ec);
  }
}</code></pre></dd>
</dl>
<p>Elements starting with a lower case character are simulated to take longer time to process.</p>
<p>Here is how we can use it with <code>mapAsync</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L419-L428" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit val blockingExecutionContext = system.dispatchers.lookup(&quot;blocking-dispatcher&quot;)
val service = new SometimesSlowService

implicit val materializer = ActorMaterializer(
  ActorMaterializerSettings(system).withInputBuffer(initialSize = 4, maxSize = 4))

Source(List(&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;, &quot;g&quot;, &quot;H&quot;, &quot;i&quot;, &quot;J&quot;))
  .map(elem ⇒ { println(s&quot;before: $elem&quot;); elem })
  .mapAsync(4)(service.convert)
  .runForeach(elem ⇒ println(s&quot;after: $elem&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L666-L680" target="_blank" title="Go to snippet source"></a><code class="language-java">final Executor blockingEc = system.dispatchers().lookup(&quot;blocking-dispatcher&quot;);
final SometimesSlowService service = new SometimesSlowService(blockingEc);

final ActorMaterializer mat =
    ActorMaterializer.create(
        ActorMaterializerSettings.create(system).withInputBuffer(4, 4), system);

Source.from(Arrays.asList(&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;, &quot;g&quot;, &quot;H&quot;, &quot;i&quot;, &quot;J&quot;))
    .map(
        elem -&gt; {
          System.out.println(&quot;before: &quot; + elem);
          return elem;
        })
    .mapAsync(4, service::convert)
    .runForeach(elem -&gt; System.out.println(&quot;after: &quot; + elem), mat);</code></pre></dd>
</dl>
<p>The output may look like this:</p>
<pre><code>before: a
before: B
before: C
before: D
running: a (1)
running: B (2)
before: e
running: C (3)
before: F
running: D (4)
before: g
before: H
completed: C (3)
completed: B (2)
completed: D (1)
completed: a (0)
after: A
after: B
running: e (1)
after: C
after: D
running: F (2)
before: i
before: J
running: g (3)
running: H (4)
completed: H (2)
completed: F (3)
completed: e (1)
completed: g (0)
after: E
after: F
running: i (1)
after: G
after: H
running: J (2)
completed: J (1)
completed: i (0)
after: I
after: J
</code></pre>
<p>Note that <code>after</code> lines are in the same order as the <code>before</code> lines even though elements are <code>completed</code> in a different order. For example <code>H</code> is <code>completed</code> before <code>g</code>, but still emitted afterwards.</p>
<p>The numbers in parenthesis illustrates how many calls that are in progress at the same time. Here the downstream demand and thereby the number of concurrent calls are limited by the buffer size (4) of the <code>ActorMaterializerSettings</code>.</p>
<p>Here is how we can use the same service with <code>mapAsyncUnordered</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/IntegrationDocSpec.scala#L451-L460" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit val blockingExecutionContext = system.dispatchers.lookup(&quot;blocking-dispatcher&quot;)
val service = new SometimesSlowService

implicit val materializer = ActorMaterializer(
  ActorMaterializerSettings(system).withInputBuffer(initialSize = 4, maxSize = 4))

Source(List(&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;, &quot;g&quot;, &quot;H&quot;, &quot;i&quot;, &quot;J&quot;))
  .map(elem ⇒ { println(s&quot;before: $elem&quot;); elem })
  .mapAsyncUnordered(4)(service.convert)
  .runForeach(elem ⇒ println(s&quot;after: $elem&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/IntegrationDocTest.java#L716-L730" target="_blank" title="Go to snippet source"></a><code class="language-java">final Executor blockingEc = system.dispatchers().lookup(&quot;blocking-dispatcher&quot;);
final SometimesSlowService service = new SometimesSlowService(blockingEc);

final ActorMaterializer mat =
    ActorMaterializer.create(
        ActorMaterializerSettings.create(system).withInputBuffer(4, 4), system);

Source.from(Arrays.asList(&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;, &quot;g&quot;, &quot;H&quot;, &quot;i&quot;, &quot;J&quot;))
    .map(
        elem -&gt; {
          System.out.println(&quot;before: &quot; + elem);
          return elem;
        })
    .mapAsyncUnordered(4, service::convert)
    .runForeach(elem -&gt; System.out.println(&quot;after: &quot; + elem), mat);</code></pre></dd>
</dl>
<p>The output may look like this:</p>
<pre><code>before: a
before: B
before: C
before: D
running: a (1)
running: B (2)
before: e
running: C (3)
before: F
running: D (4)
before: g
before: H
completed: B (3)
completed: C (1)
completed: D (2)
after: B
after: D
running: e (2)
after: C
running: F (3)
before: i
before: J
completed: F (2)
after: F
running: g (3)
running: H (4)
completed: H (3)
after: H
completed: a (2)
after: A
running: i (3)
running: J (4)
completed: J (3)
after: J
completed: e (2)
after: E
completed: g (1)
after: G
completed: i (0)
after: I
</code></pre>
<p>Note that <code>after</code> lines are not in the same order as the <code>before</code> lines. For example <code>H</code> overtakes the slow <code>G</code>.</p>
<p>The numbers in parenthesis illustrates how many calls that are in progress at the same time. Here the downstream demand and thereby the number of concurrent calls are limited by the buffer size (4) of the <code>ActorMaterializerSettings</code>.</p>
<a id="reactive-streams-integration"></a>
<h2><a href="#integrating-with-reactive-streams" name="integrating-with-reactive-streams" class="anchor"><span class="anchor-link"></span></a>Integrating with Reactive Streams</h2>
<p><a href="http://reactive-streams.org/">Reactive Streams</a> defines a standard for asynchronous stream processing with non-blocking back pressure. It makes it possible to plug together stream libraries that adhere to the standard. Akka Streams is one such library.</p>
<p>An incomplete list of other implementations:</p>
<ul>
  <li><a href="https://github.com/reactor/reactor">Reactor (1.1+)</a></li>
  <li><a href="https://github.com/ReactiveX/RxJavaReactiveStreams">RxJava</a></li>
  <li><a href="http://www.ratpack.io/manual/current/streams.html">Ratpack</a></li>
  <li><a href="http://slick.lightbend.com">Slick</a></li>
</ul>
<p>The two most important interfaces in Reactive Streams are the <code>Publisher</code> and <code>Subscriber</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L20-L21" target="_blank" title="Go to snippet source"></a><code class="language-scala">import org.reactivestreams.Publisher
import org.reactivestreams.Subscriber</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L23-L25" target="_blank" title="Go to snippet source"></a><code class="language-java">import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Processor;</code></pre></dd>
</dl>
<p>Let us assume that a library provides a publisher of tweets:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">def tweets: Publisher[Tweet]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L71" target="_blank" title="Go to snippet source"></a><code class="language-java">Publisher&lt;Tweet&gt; tweets();</code></pre></dd>
</dl>
<p>and another library knows how to store author handles in a database:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L37" target="_blank" title="Go to snippet source"></a><code class="language-scala">def storage: Subscriber[Author]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L75" target="_blank" title="Go to snippet source"></a><code class="language-java">Subscriber&lt;Author&gt; storage();</code></pre></dd>
</dl>
<p>Using an Akka Streams <code>Flow</code> we can transform the stream and connect those:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L26-L29" target="_blank" title="Go to snippet source"></a><code class="language-scala">val authors = Flow[Tweet]
  .filter(_.hashtags.contains(akkaTag))
  .map(_.author)

Source.fromPublisher(tweets).via(authors).to(Sink.fromSubscriber(storage)).run()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L63-L65" target="_blank" title="Go to snippet source"></a><code class="language-java">final Flow&lt;Tweet, Author, NotUsed&gt; authors =
    Flow.of(Tweet.class).filter(t -&gt; t.hashtags().contains(AKKA)).map(t -&gt; t.author);

Source.fromPublisher(rs.tweets()).via(authors).to(Sink.fromSubscriber(rs.storage()));</code></pre></dd>
</dl>
<p>The <code>Publisher</code> is used as an input <code>Source</code> to the flow and the <code>Subscriber</code> is used as an output <code>Sink</code>.</p>
<p>A <code>Flow</code> can also be also converted to a <code>RunnableGraph[Processor[In, Out]]</code> which materializes to a <code>Processor</code> when <code>run()</code> is called. <code>run()</code> itself can be called multiple times, resulting in a new <code>Processor</code> instance each time.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L83-L86" target="_blank" title="Go to snippet source"></a><code class="language-scala">val processor: Processor[Tweet, Author] = authors.toProcessor.run()

tweets.subscribe(processor)
processor.subscribe(storage)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L158-L161" target="_blank" title="Go to snippet source"></a><code class="language-java">final Processor&lt;Tweet, Author&gt; processor = authors.toProcessor().run(mat);

rs.tweets().subscribe(processor);
processor.subscribe(rs.storage());</code></pre></dd>
</dl>
<p>A publisher can be connected to a subscriber with the <code>subscribe</code> method.</p>
<p>It is also possible to expose a <code>Source</code> as a <code>Publisher</code> by using the Publisher-<code>Sink</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L97-L100" target="_blank" title="Go to snippet source"></a><code class="language-scala">val authorPublisher: Publisher[Author] =
  Source.fromPublisher(tweets).via(authors).runWith(Sink.asPublisher(fanout = false))

authorPublisher.subscribe(storage)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L176-L181" target="_blank" title="Go to snippet source"></a><code class="language-java">final Publisher&lt;Author&gt; authorPublisher =
    Source.fromPublisher(rs.tweets())
        .via(authors)
        .runWith(Sink.asPublisher(AsPublisher.WITHOUT_FANOUT), mat);

authorPublisher.subscribe(rs.storage());</code></pre></dd>
</dl>
<p>A publisher that is created with <span class="group-scala"><code>Sink.asPublisher(fanout = false)</code></span><span class="group-java"><code>Sink.asPublisher(AsPublisher.WITHOUT_FANOUT)</code></span> supports only a single subscription. Additional subscription attempts will be rejected with an <code>IllegalStateException</code>.</p>
<p>A publisher that supports multiple subscribers using fan-out/broadcasting is created as follows:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L41" target="_blank" title="Go to snippet source"></a><code class="language-scala">def alert: Subscriber[Author]
def storage: Subscriber[Author]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L79" target="_blank" title="Go to snippet source"></a><code class="language-java">Subscriber&lt;Author&gt; alert();
Subscriber&lt;Author&gt; storage();</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L112-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">val authorPublisher: Publisher[Author] =
  Source.fromPublisher(tweets).via(authors)
    .runWith(Sink.asPublisher(fanout = true))

authorPublisher.subscribe(storage)
authorPublisher.subscribe(alert)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L196-L202" target="_blank" title="Go to snippet source"></a><code class="language-java">final Publisher&lt;Author&gt; authorPublisher =
    Source.fromPublisher(rs.tweets())
        .via(authors)
        .runWith(Sink.asPublisher(AsPublisher.WITH_FANOUT), mat);

authorPublisher.subscribe(rs.storage());
authorPublisher.subscribe(rs.alert());</code></pre></dd>
</dl>
<p>The input buffer size of the operator controls how far apart the slowest subscriber can be from the fastest subscriber before slowing down the stream.</p>
<p>To make the picture complete, it is also possible to expose a <code>Sink</code> as a <code>Subscriber</code> by using the Subscriber-<code>Source</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L130-L133" target="_blank" title="Go to snippet source"></a><code class="language-scala">val tweetSubscriber: Subscriber[Tweet] =
  authors.to(Sink.fromSubscriber(storage)).runWith(Source.asSubscriber[Tweet])

tweets.subscribe(tweetSubscriber)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L217-L222" target="_blank" title="Go to snippet source"></a><code class="language-java">final Subscriber&lt;Author&gt; storage = rs.storage();

final Subscriber&lt;Tweet&gt; tweetSubscriber =
    authors.to(Sink.fromSubscriber(storage)).runWith(Source.asSubscriber(), mat);

rs.tweets().subscribe(tweetSubscriber);</code></pre></dd>
</dl>
<p>It is also possible to use re-wrap <code>Processor</code> instances as a <code>Flow</code> by passing a factory function that will create the <code>Processor</code> instances:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ReactiveStreamsDocSpec.scala#L142-L145" target="_blank" title="Go to snippet source"></a><code class="language-scala">// An example Processor factory
def createProcessor: Processor[Int, Int] = Flow[Int].toProcessor.run()

val flow: Flow[Int, Int, NotUsed] = Flow.fromProcessor(() ⇒ createProcessor)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ReactiveStreamsDocTest.java#L235-L244" target="_blank" title="Go to snippet source"></a><code class="language-java">// An example Processor factory
final Creator&lt;Processor&lt;Integer, Integer&gt;&gt; factory =
    new Creator&lt;Processor&lt;Integer, Integer&gt;&gt;() {
      public Processor&lt;Integer, Integer&gt; create() {
        return Flow.of(Integer.class).toProcessor().run(mat);
      }
    };

final Flow&lt;Integer, Integer, NotUsed&gt; flow = Flow.fromProcessor(factory);
</code></pre></dd>
</dl>
<p>Please note that a factory is necessary to achieve reusability of the resulting <code>Flow</code>.</p>
<h3><a href="#implementing-reactive-streams-publisher-or-subscriber" name="implementing-reactive-streams-publisher-or-subscriber" class="anchor"><span class="anchor-link"></span></a>Implementing Reactive Streams Publisher or Subscriber</h3>
<p>As described above any Akka Streams <code>Source</code> can be exposed as a Reactive Streams <code>Publisher</code> and any <code>Sink</code> can be exposed as a Reactive Streams <code>Subscriber</code>. Therefore we recommend that you implement Reactive Streams integrations with built-in operators or <a href="stream-customize.html">custom operators</a>.</p>
<p>For historical reasons the <code>ActorPublisher</code> and <code>ActorSubscriber</code> traits are provided to support implementing Reactive Streams <code>Publisher</code> and <code>Subscriber</code> with an <code>Actor</code>.</p>
<p>These can be consumed by other Reactive Stream libraries or used as an Akka Streams <code>Source</code> or <code>Sink</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><code>ActorPublisher</code> and <code>ActorSubscriber</code> cannot be used with remote actors, because if signals of the Reactive Streams protocol (e.g. <code>request</code>) are lost the the stream may deadlock.</p></div>
<h4><a href="#actorpublisher" name="actorpublisher" class="anchor"><span class="anchor-link"></span></a>ActorPublisher</h4><div class="callout warning "><div class="callout-title">Warning</div>
<p><strong>Deprecation warning:</strong> <code>ActorPublisher</code> is deprecated in favour of the vastly more type-safe and safe to implement <a href="stream-customize.html"><code>GraphStage</code></a>. It can also expose a &ldquo;operator actor ref&rdquo; is needed to be addressed as-if an Actor. Custom operators implemented using <a href="stream-customize.html"><code>GraphStage</code></a> are also automatically fusable.</p>
<p>To learn more about implementing custom operators using it refer to <a href="stream-customize.html#graphstage">Custom processing with GraphStage</a>.</p></div>
<p>Extend <span class="group-scala"><code>akka.stream.actor.ActorPublisher</code> in your <code>Actor</code> to make it</span><span class="group-java"><code>akka.stream.actor.AbstractActorPublisher</code> to implement</span> a stream publisher that keeps track of the subscription life cycle and requested elements.</p>
<p>Here is an example of such an actor. It dispatches incoming jobs to the attached subscriber:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ActorPublisherDocSpec.scala#L17-L66" target="_blank" title="Go to snippet source"></a><code class="language-scala">object JobManager {
  def props: Props = Props[JobManager]

  final case class Job(payload: String)
  case object JobAccepted
  case object JobDenied
}

class JobManager extends ActorPublisher[JobManager.Job] {
  import akka.stream.actor.ActorPublisherMessage._
  import JobManager._

  val MaxBufferSize = 100
  var buf = Vector.empty[Job]

  def receive = {
    case job: Job if buf.size == MaxBufferSize ⇒
      sender() ! JobDenied
    case job: Job ⇒
      sender() ! JobAccepted
      if (buf.isEmpty &amp;&amp; totalDemand &gt; 0)
        onNext(job)
      else {
        buf :+= job
        deliverBuf()
      }
    case Request(_) ⇒
      deliverBuf()
    case Cancel ⇒
      context.stop(self)
  }

  @tailrec final def deliverBuf(): Unit =
    if (totalDemand &gt; 0) {
      /*
       * totalDemand is a Long and could be larger than
       * what buf.splitAt can accept
       */
      if (totalDemand &lt;= Int.MaxValue) {
        val (use, keep) = buf.splitAt(totalDemand.toInt)
        buf = keep
        use foreach onNext
      } else {
        val (use, keep) = buf.splitAt(Int.MaxValue)
        buf = keep
        use foreach onNext
        deliverBuf()
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ActorPublisherDocTest.java#L44-L126" target="_blank" title="Go to snippet source"></a><code class="language-java">public static class JobManagerProtocol {
  public static final class Job {
    public final String payload;

    public Job(String payload) {
      this.payload = payload;
    }
  }

  public static class JobAcceptedMessage {
    @Override
    public String toString() {
      return &quot;JobAccepted&quot;;
    }
  }

  public static final JobAcceptedMessage JobAccepted = new JobAcceptedMessage();

  public static class JobDeniedMessage {
    @Override
    public String toString() {
      return &quot;JobDenied&quot;;
    }
  }

  public static final JobDeniedMessage JobDenied = new JobDeniedMessage();
}

public static class JobManager extends AbstractActorPublisher&lt;JobManagerProtocol.Job&gt; {

  public static Props props() {
    return Props.create(JobManager.class);
  }

  private final int MAX_BUFFER_SIZE = 100;
  private final List&lt;JobManagerProtocol.Job&gt; buf = new ArrayList&lt;&gt;();

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            JobManagerProtocol.Job.class,
            job -&gt; buf.size() == MAX_BUFFER_SIZE,
            job -&gt; {
              getSender().tell(JobManagerProtocol.JobDenied, getSelf());
            })
        .match(
            JobManagerProtocol.Job.class,
            job -&gt; {
              getSender().tell(JobManagerProtocol.JobAccepted, getSelf());

              if (buf.isEmpty() &amp;&amp; totalDemand() &gt; 0) onNext(job);
              else {
                buf.add(job);
                deliverBuf();
              }
            })
        .match(ActorPublisherMessage.Request.class, request -&gt; deliverBuf())
        .match(ActorPublisherMessage.Cancel.class, cancel -&gt; getContext().stop(getSelf()))
        .build();
  }

  void deliverBuf() {
    while (totalDemand() &gt; 0) {
      /*
       * totalDemand is a Long and could be larger than
       * what buf.splitAt can accept
       */
      if (totalDemand() &lt;= Integer.MAX_VALUE) {
        final List&lt;JobManagerProtocol.Job&gt; took =
            buf.subList(0, Math.min(buf.size(), (int) totalDemand()));
        took.forEach(this::onNext);
        buf.removeAll(took);
        break;
      } else {
        final List&lt;JobManagerProtocol.Job&gt; took =
            buf.subList(0, Math.min(buf.size(), Integer.MAX_VALUE));
        took.forEach(this::onNext);
        buf.removeAll(took);
      }
    }
  }
}</code></pre></dd>
</dl>
<p>You send elements to the stream by calling <code>onNext</code>. You are allowed to send as many elements as have been requested by the stream subscriber. This amount can be inquired with <code>totalDemand</code>. It is only allowed to use <code>onNext</code> when <code>isActive</code> and <code>totalDemand&gt;0</code>, otherwise <code>onNext</code> will throw <code>IllegalStateException</code>.</p>
<p>When the stream subscriber requests more elements the <code>ActorPublisherMessage.Request</code> message is delivered to this actor, and you can act on that event. The <code>totalDemand</code> is updated automatically.</p>
<p>When the stream subscriber cancels the subscription the <code>ActorPublisherMessage.Cancel</code> message is delivered to this actor. After that subsequent calls to <code>onNext</code> will be ignored.</p>
<p>You can complete the stream by calling <code>onComplete</code>. After that you are not allowed to call <code>onNext</code>, <code>onError</code> and <code>onComplete</code>.</p>
<p>You can terminate the stream with failure by calling <code>onError</code>. After that you are not allowed to call <code>onNext</code>, <code>onError</code> and <code>onComplete</code>.</p>
<p>If you suspect that this <span class="group-scala"><code>ActorPublisher</code></span><span class="group-java"><code>AbstractActorPublisher</code></span> may never get subscribed to, you can override the <code>subscriptionTimeout</code> method to provide a timeout after which this Publisher should be considered canceled. The actor will be notified when the timeout triggers via an <code>ActorPublisherMessage.SubscriptionTimeoutExceeded</code> message and MUST then perform cleanup and stop itself.</p>
<p>If the actor is stopped the stream will be completed, unless it was not already terminated with failure, completed or canceled.</p>
<p>More detailed information can be found in the API documentation.</p>
<p>This is how it can be used as input <code>Source</code> to a <code>Flow</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ActorPublisherDocSpec.scala#L80-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala">val jobManagerSource = Source.actorPublisher[JobManager.Job](JobManager.props)
val ref = Flow[JobManager.Job]
  .map(_.payload.toUpperCase)
  .map { elem ⇒ println(elem); elem }
  .to(Sink.ignore)
  .runWith(jobManagerSource)

ref ! JobManager.Job(&quot;a&quot;)
ref ! JobManager.Job(&quot;b&quot;)
ref ! JobManager.Job(&quot;c&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ActorPublisherDocTest.java#L136-L152" target="_blank" title="Go to snippet source"></a><code class="language-java">final Source&lt;JobManagerProtocol.Job, ActorRef&gt; jobManagerSource =
    Source.actorPublisher(JobManager.props());

final ActorRef ref =
    jobManagerSource
        .map(job -&gt; job.payload.toUpperCase())
        .map(
            elem -&gt; {
              System.out.println(elem);
              return elem;
            })
        .to(Sink.ignore())
        .run(mat);

ref.tell(new JobManagerProtocol.Job(&quot;a&quot;), ActorRef.noSender());
ref.tell(new JobManagerProtocol.Job(&quot;b&quot;), ActorRef.noSender());
ref.tell(new JobManagerProtocol.Job(&quot;c&quot;), ActorRef.noSender());</code></pre></dd>
</dl>
<p><span class="group-scala">A publisher that is created with <code>Sink.asPublisher</code> supports a specified number of subscribers. Additional  subscription attempts will be rejected with an <code>IllegalStateException</code>. </span><span class="group-java">You can only attach one subscriber to this publisher. Use a <code>Broadcast</code>-element or  attach a <code>Sink.asPublisher(AsPublisher.WITH_FANOUT)</code> to enable multiple subscribers. </span></p>
<h4><a href="#actorsubscriber" name="actorsubscriber" class="anchor"><span class="anchor-link"></span></a>ActorSubscriber</h4><div class="callout warning "><div class="callout-title">Warning</div>
<p><strong>Deprecation warning:</strong> <code>ActorSubscriber</code> is deprecated in favour of the vastly more type-safe and safe to implement <a href="stream-customize.html"><code>GraphStage</code></a>. It can also expose a &ldquo;operator actor ref&rdquo; is needed to be addressed as-if an Actor. Custom operators implemented using <a href="stream-customize.html"><code>GraphStage</code></a> are also automatically fusable.</p>
<p>To learn more about implementing custom operators using it refer to <a href="stream-customize.html#graphstage">Custom processing with GraphStage</a>.</p></div>
<p>Extend <span class="group-scala"><code>akka.stream.actor.ActorSubscriber</code> in your <code>Actor</code> to make it</span><span class="group-java"><code>akka.stream.actor.AbstractActorSubscriber</code> to make your class</span> a stream subscriber with full control of stream back pressure. It will receive <code>ActorSubscriberMessage.OnNext</code>, <code>ActorSubscriberMessage.OnComplete</code> and <code>ActorSubscriberMessage.OnError</code> messages from the stream. It can also receive other, non-stream messages, in the same way as any actor.</p>
<p>Here is an example of such an actor. It dispatches incoming jobs to child worker actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ActorSubscriberDocSpec.scala#L24-L76" target="_blank" title="Go to snippet source"></a><code class="language-scala">object WorkerPool {
  case class Msg(id: Int, replyTo: ActorRef)
  case class Work(id: Int)
  case class Reply(id: Int)
  case class Done(id: Int)

  def props: Props = Props(new WorkerPool)
}

class WorkerPool extends ActorSubscriber {
  import WorkerPool._
  import ActorSubscriberMessage._

  val MaxQueueSize = 10
  var queue = Map.empty[Int, ActorRef]

  val router = {
    val routees = Vector.fill(3) {
      ActorRefRoutee(context.actorOf(Props[Worker]))
    }
    Router(RoundRobinRoutingLogic(), routees)
  }

  override val requestStrategy = new MaxInFlightRequestStrategy(max = MaxQueueSize) {
    override def inFlightInternally: Int = queue.size
  }

  def receive = {
    case OnNext(Msg(id, replyTo)) ⇒
      queue += (id -&gt; replyTo)
      assert(queue.size &lt;= MaxQueueSize, s&quot;queued too many: ${queue.size}&quot;)
      router.route(Work(id), self)
    case Reply(id) ⇒
      queue(id) ! Done(id)
      queue -= id
      if (canceled &amp;&amp; queue.isEmpty) {
        context.stop(self)
      }
    case OnComplete ⇒
      if (queue.isEmpty) {
        context.stop(self)
      }
  }
}

class Worker extends Actor {
  import WorkerPool._
  def receive = {
    case Work(id) ⇒
      // ...
      sender() ! Reply(id)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ActorSubscriberDocTest.java#L53-L225" target="_blank" title="Go to snippet source"></a><code class="language-java">public static class WorkerPoolProtocol {

  public static class Msg {
    public final int id;
    public final ActorRef replyTo;

    public Msg(int id, ActorRef replyTo) {
      this.id = id;
      this.replyTo = replyTo;
    }

    @Override
    public String toString() {
      return String.format(&quot;Msg(%s, %s)&quot;, id, replyTo);
    }
  }

  public static Msg msg(int id, ActorRef replyTo) {
    return new Msg(id, replyTo);
  }

  public static class Work {
    public final int id;

    public Work(int id) {
      this.id = id;
    }

    @Override
    public String toString() {
      return String.format(&quot;Work(%s)&quot;, id);
    }
  }

  public static Work work(int id) {
    return new Work(id);
  }

  public static class Reply {
    public final int id;

    public Reply(int id) {
      this.id = id;
    }

    @Override
    public String toString() {
      return String.format(&quot;Reply(%s)&quot;, id);
    }
  }

  public static Reply reply(int id) {
    return new Reply(id);
  }

  public static class Done {
    public final int id;

    public Done(int id) {
      this.id = id;
    }

    @Override
    public String toString() {
      return String.format(&quot;Done(%s)&quot;, id);
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }

      Done done = (Done) o;

      if (id != done.id) {
        return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return id;
    }
  }

  public static Done done(int id) {
    return new Done(id);
  }
}

public static class WorkerPool extends AbstractActorSubscriber {

  public static Props props() {
    return Props.create(WorkerPool.class);
  }

  final int MAX_QUEUE_SIZE = 10;
  final Map&lt;Integer, ActorRef&gt; queue = new HashMap&lt;&gt;();

  final Router router;

  @Override
  public RequestStrategy requestStrategy() {
    return new MaxInFlightRequestStrategy(MAX_QUEUE_SIZE) {
      @Override
      public int inFlightInternally() {
        return queue.size();
      }
    };
  }

  public WorkerPool() {
    final List&lt;Routee&gt; routees = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 3; i++)
      routees.add(new ActorRefRoutee(getContext().actorOf(Props.create(Worker.class))));
    router = new Router(new RoundRobinRoutingLogic(), routees);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ActorSubscriberMessage.OnNext.class,
            on -&gt; on.element() instanceof WorkerPoolProtocol.Msg,
            onNext -&gt; {
              WorkerPoolProtocol.Msg msg = (WorkerPoolProtocol.Msg) onNext.element();
              queue.put(msg.id, msg.replyTo);

              if (queue.size() &gt; MAX_QUEUE_SIZE)
                throw new RuntimeException(&quot;queued too many: &quot; + queue.size());

              router.route(WorkerPoolProtocol.work(msg.id), getSelf());
            })
        .match(
            ActorSubscriberMessage.onCompleteInstance().getClass(),
            complete -&gt; {
              if (queue.isEmpty()) {
                getContext().stop(getSelf());
              }
            })
        .match(
            WorkerPoolProtocol.Reply.class,
            reply -&gt; {
              int id = reply.id;
              queue.get(id).tell(WorkerPoolProtocol.done(id), getSelf());
              queue.remove(id);
              if (canceled() &amp;&amp; queue.isEmpty()) {
                getContext().stop(getSelf());
              }
            })
        .build();
  }
}

static class Worker extends AbstractActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            WorkerPoolProtocol.Work.class,
            work -&gt; {
              // ...
              getSender().tell(WorkerPoolProtocol.reply(work.id), getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Subclass must define the <code>RequestStrategy</code> to control stream back pressure. After each incoming message the <span class="group-scala"><code>ActorSubscriber</code></span><span class="group-java"><code>AbstractActorSubscriber</code></span> will automatically invoke the <code>RequestStrategy.requestDemand</code> and propagate the returned demand to the stream.</p>
<ul>
  <li>The provided <code>WatermarkRequestStrategy</code> is a good strategy if the actor performs work itself.</li>
  <li>The provided <code>MaxInFlightRequestStrategy</code> is useful if messages are queued internally or delegated to other actors.</li>
  <li>You can also implement a custom <code>RequestStrategy</code> or call <code>request</code> manually together with <code>ZeroRequestStrategy</code> or some other strategy. In that case you must also call <code>request</code> when the actor is started or when it is ready, otherwise it will not receive any elements.</li>
</ul>
<p>More detailed information can be found in the API documentation.</p>
<p>This is how it can be used as output <code>Sink</code> to a <code>Flow</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/stream/ActorSubscriberDocSpec.scala#L90-L92" target="_blank" title="Go to snippet source"></a><code class="language-scala">val N = 117
val worker = Source(1 to N).map(WorkerPool.Msg(_, replyTo))
  .runWith(Sink.actorSubscriber(WorkerPool.props))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/stream/ActorSubscriberDocTest.java#L236-L245" target="_blank" title="Go to snippet source"></a><code class="language-java">final int N = 117;
final List&lt;Integer&gt; data = new ArrayList&lt;&gt;(N);
for (int i = 0; i &lt; N; i++) {
  data.add(i);
}

final ActorRef worker =
    Source.from(data)
        .map(i -&gt; WorkerPoolProtocol.msg(i, replyTo))
        .runWith(Sink.&lt;WorkerPoolProtocol.Msg&gt;actorSubscriber(WorkerPool.props()), mat);</code></pre></dd>
</dl>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../stream/stream-customize.html"><i class="icon-prev"></i> <span class="link-prev">Custom stream processing</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../stream/stream-error.html">Error Handling in Streams <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/stream/stream-integrations.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
