<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Cluster Sharding &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/cluster-sharding.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a>
  <ul>
    <li><a href="common/cluster.html" class="page">Cluster Specification</a></li>
    <li><a href="cluster-usage.html" class="page">Cluster Usage</a></li>
    <li><a href="cluster-routing.html" class="page">Cluster Aware Routers</a></li>
    <li><a href="cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="cluster-client.html" class="page">Cluster Client</a></li>
    <li><a href="cluster-sharding.html#cluster-sharding" class="active page">Cluster Sharding</a>
    <ul>
      <li><a href="cluster-sharding.html#dependency" class="header">Dependency</a></li>
      <li><a href="cluster-sharding.html#sample-project" class="header">Sample project</a></li>
      <li><a href="cluster-sharding.html#introduction" class="header">Introduction</a></li>
      <li><a href="cluster-sharding.html#an-example" class="header">An Example</a></li>
      <li><a href="cluster-sharding.html#how-it-works" class="header">How it works</a></li>
      <li><a href="cluster-sharding.html#distributed-data-vs-persistence-mode" class="header">Distributed Data vs. Persistence Mode</a></li>
      <li><a href="cluster-sharding.html#startup-after-minimum-number-of-members" class="header">Startup after minimum number of members</a></li>
      <li><a href="cluster-sharding.html#proxy-only-mode" class="header">Proxy Only Mode</a></li>
      <li><a href="cluster-sharding.html#passivation" class="header">Passivation</a></li>
      <li><a href="cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
      <li><a href="cluster-sharding.html#supervision" class="header">Supervision</a></li>
      <li><a href="cluster-sharding.html#graceful-shutdown" class="header">Graceful Shutdown</a></li>
      <li><a href="cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of Internal Cluster Sharding Data</a></li>
      <li><a href="cluster-sharding.html#configuration" class="header">Configuration</a></li>
      <li><a href="cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
      <li><a href="cluster-sharding.html#rolling-upgrades" class="header">Rolling upgrades</a></li>
    </ul></li>
    <li><a href="cluster-metrics.html" class="page">Cluster Metrics Extension</a></li>
    <li><a href="distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="cluster-dc.html" class="page">Cluster across multiple data centers</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a>
  <ul>
    <li><a href="common/cluster.html" class="page">Cluster Specification</a></li>
    <li><a href="cluster-usage.html" class="page">Cluster Usage</a></li>
    <li><a href="cluster-routing.html" class="page">Cluster Aware Routers</a></li>
    <li><a href="cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="cluster-client.html" class="page">Cluster Client</a></li>
    <li><a href="cluster-sharding.html#cluster-sharding" class="active page">Cluster Sharding</a>
    <ul>
      <li><a href="cluster-sharding.html#dependency" class="header">Dependency</a></li>
      <li><a href="cluster-sharding.html#sample-project" class="header">Sample project</a></li>
      <li><a href="cluster-sharding.html#introduction" class="header">Introduction</a></li>
      <li><a href="cluster-sharding.html#an-example" class="header">An Example</a></li>
      <li><a href="cluster-sharding.html#how-it-works" class="header">How it works</a></li>
      <li><a href="cluster-sharding.html#distributed-data-vs-persistence-mode" class="header">Distributed Data vs. Persistence Mode</a></li>
      <li><a href="cluster-sharding.html#startup-after-minimum-number-of-members" class="header">Startup after minimum number of members</a></li>
      <li><a href="cluster-sharding.html#proxy-only-mode" class="header">Proxy Only Mode</a></li>
      <li><a href="cluster-sharding.html#passivation" class="header">Passivation</a></li>
      <li><a href="cluster-sharding.html#remembering-entities" class="header">Remembering Entities</a></li>
      <li><a href="cluster-sharding.html#supervision" class="header">Supervision</a></li>
      <li><a href="cluster-sharding.html#graceful-shutdown" class="header">Graceful Shutdown</a></li>
      <li><a href="cluster-sharding.html#removal-of-internal-cluster-sharding-data" class="header">Removal of Internal Cluster Sharding Data</a></li>
      <li><a href="cluster-sharding.html#configuration" class="header">Configuration</a></li>
      <li><a href="cluster-sharding.html#inspecting-cluster-sharding-state" class="header">Inspecting cluster sharding state</a></li>
      <li><a href="cluster-sharding.html#rolling-upgrades" class="header">Rolling upgrades</a></li>
    </ul></li>
    <li><a href="cluster-metrics.html" class="page">Cluster Metrics Extension</a></li>
    <li><a href="distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="cluster-dc.html" class="page">Cluster across multiple data centers</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#cluster-sharding" name="cluster-sharding" class="anchor"><span class="anchor-link"></span></a>Cluster Sharding</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Cluster Sharding, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-cluster-sharding" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-cluster-sharding_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-cluster-sharding_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#sample-project" name="sample-project" class="anchor"><span class="anchor-link"></span></a>Sample project</h2>
<p>You can look at the <span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-samples-cluster-sharding-java">Cluster Sharding example project</a></span> <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-samples-cluster-sharding-scala">Cluster Sharding example project</a></span> to see what this looks like in practice.</p>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Cluster sharding is useful when you need to distribute actors across several nodes in the cluster and want to be able to interact with them using their logical identifier, but without having to care about their physical location in the cluster, which might also change over time.</p>
<p>It could for example be actors representing Aggregate Roots in Domain-Driven Design terminology. Here we call these actors &ldquo;entities&rdquo;. These actors typically have persistent (durable) state, but this feature is not limited to actors with persistent state.</p>
<p>Cluster sharding is typically used when you have many stateful actors that together consume more resources (e.g. memory) than fit on one machine. If you only have a few stateful actors it might be easier to run them on a <a href="cluster-singleton.html">Cluster Singleton</a> node.</p>
<p>In this context sharding means that actors with an identifier, so called entities, can be automatically distributed across multiple nodes in the cluster. Each entity actor runs only at one place, and messages can be sent to the entity without requiring the sender to know the location of the destination actor. This is achieved by sending the messages via a <code>ShardRegion</code> actor provided by this extension, which knows how to route the message with the entity id to the final destination.</p>
<p>Cluster sharding will not be active on members with status <a href="cluster-usage.html#weakly-up">WeaklyUp</a> if that feature is enabled.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><strong>Don&rsquo;t use Cluster Sharding together with Automatic Downing</strong>, since it allows the cluster to split up into two separate clusters, which in turn will result in <em>multiple shards and entities</em> being started, one in each separate cluster! See <a href="cluster-usage.html#automatic-vs-manual-downing">Downing</a>.</p></div>
<h2><a href="#an-example" name="an-example" class="anchor"><span class="anchor-link"></span></a>An Example</h2>
<p>This is how an entity actor may look like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L37-L77" target="_blank" title="Go to snippet source"></a><code class="language-scala">case object Increment
case object Decrement
final case class Get(counterId: Long)
final case class EntityEnvelope(id: Long, payload: Any)

case object Stop
final case class CounterChanged(delta: Int)

class Counter extends PersistentActor {
  import ShardRegion.Passivate

  context.setReceiveTimeout(120.seconds)

  // self.path.name is the entity identifier (utf-8 URL-encoded)
  override def persistenceId: String = &quot;Counter-&quot; + self.path.name

  var count = 0

  def updateState(event: CounterChanged): Unit =
    count += event.delta

  override def receiveRecover: Receive = {
    case evt: CounterChanged ⇒ updateState(evt)
  }

  override def receiveCommand: Receive = {
    case Increment      ⇒ persist(CounterChanged(+1))(updateState)
    case Decrement      ⇒ persist(CounterChanged(-1))(updateState)
    case Get(_)         ⇒ sender() ! count
    case ReceiveTimeout ⇒ context.parent ! Passivate(stopMessage = Stop)
    case Stop           ⇒ context.stop(self)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L155-L237" target="_blank" title="Go to snippet source"></a><code class="language-java">static class Counter extends AbstractPersistentActor {

  public enum CounterOp {
    INCREMENT,
    DECREMENT
  }

  public static class Get {
    public final long counterId;

    public Get(long counterId) {
      this.counterId = counterId;
    }
  }

  public static class EntityEnvelope {
    public final long id;
    public final Object payload;

    public EntityEnvelope(long id, Object payload) {
      this.id = id;
      this.payload = payload;
    }
  }

  public static class CounterChanged {
    public final int delta;

    public CounterChanged(int delta) {
      this.delta = delta;
    }
  }

  int count = 0;

  // getSelf().path().name() is the entity identifier (utf-8 URL-encoded)
  @Override
  public String persistenceId() {
    return &quot;Counter-&quot; + getSelf().path().name();
  }

  @Override
  public void preStart() throws Exception {
    super.preStart();
    getContext().setReceiveTimeout(Duration.ofSeconds(120));
  }

  void updateState(CounterChanged event) {
    count += event.delta;
  }

  @Override
  public Receive createReceiveRecover() {
    return receiveBuilder().match(CounterChanged.class, this::updateState).build();
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Get.class, this::receiveGet)
        .matchEquals(CounterOp.INCREMENT, msg -&gt; receiveIncrement())
        .matchEquals(CounterOp.DECREMENT, msg -&gt; receiveDecrement())
        .matchEquals(ReceiveTimeout.getInstance(), msg -&gt; passivate())
        .build();
  }

  private void receiveGet(Get msg) {
    getSender().tell(count, getSelf());
  }

  private void receiveIncrement() {
    persist(new CounterChanged(+1), this::updateState);
  }

  private void receiveDecrement() {
    persist(new CounterChanged(-1), this::updateState);
  }

  private void passivate() {
    getContext().getParent().tell(new ShardRegion.Passivate(PoisonPill.getInstance()), getSelf());
  }
}
</code></pre></dd>
</dl>
<p>The above actor uses event sourcing and the support provided in <span class="group-scala"><code>PersistentActor</code></span> <span class="group-java"><code>AbstractPersistentActor</code></span> to store its state. It does not have to be a persistent actor, but in case of failure or migration of entities between nodes it must be able to recover its state if it is valuable.</p>
<p>Note how the <code>persistenceId</code> is defined. The name of the actor is the entity identifier (utf-8 URL-encoded). You may define it another way, but it must be unique.</p>
<p>When using the sharding extension you are first, typically at system startup on each node in the cluster, supposed to register the supported entity types with the <code>ClusterSharding.start</code> method. <code>ClusterSharding.start</code> gives you the reference which you can pass along. Please note that <code>ClusterSharding.start</code> will start a <code>ShardRegion</code> in <a href="#proxy-only-mode">proxy only mode</a> in case if there is no match between the roles of the current cluster node and the role specified in <code>ClusterShardingSettings</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L633-L638" target="_blank" title="Go to snippet source"></a><code class="language-scala">val counterRegion: ActorRef = ClusterSharding(system).start(
  typeName = &quot;Counter&quot;,
  entityProps = Props[Counter],
  settings = ClusterShardingSettings(system),
  extractEntityId = extractEntityId,
  extractShardId = extractShardId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L25-L84" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.japi.Option;
import akka.cluster.sharding.ClusterSharding;
import akka.cluster.sharding.ClusterShardingSettings;

Option&lt;String&gt; roleOption = Option.none();
ClusterShardingSettings settings = ClusterShardingSettings.create(system);
ActorRef startedCounterRegion =
    ClusterSharding.get(system)
        .start(&quot;Counter&quot;, Props.create(Counter.class), settings, messageExtractor);</code></pre></dd>
</dl>
<p>The <span class="group-scala"><code>extractEntityId</code> and <code>extractShardId</code> are two</span> <span class="group-java"><code>messageExtractor</code> defines</span> application specific <span class="group-scala">functions</span> <span class="group-java">methods</span> to extract the entity identifier and the shard identifier from incoming messages.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L181-L194" target="_blank" title="Go to snippet source"></a><code class="language-scala">val extractEntityId: ShardRegion.ExtractEntityId = {
  case EntityEnvelope(id, payload) ⇒ (id.toString, payload)
  case msg @ Get(id)               ⇒ (id.toString, msg)
}

val numberOfShards = 100

val extractShardId: ShardRegion.ExtractShardId = {
  case EntityEnvelope(id, _) ⇒ (id % numberOfShards).toString
  case Get(id)               ⇒ (id % numberOfShards).toString
  case ShardRegion.StartEntity(id) ⇒
    // StartEntity is used by remembering entities feature
    (id.toLong % numberOfShards).toString
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L20-L76" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.cluster.sharding.ShardRegion;

ShardRegion.MessageExtractor messageExtractor =
    new ShardRegion.MessageExtractor() {

      @Override
      public String entityId(Object message) {
        if (message instanceof Counter.EntityEnvelope)
          return String.valueOf(((Counter.EntityEnvelope) message).id);
        else if (message instanceof Counter.Get)
          return String.valueOf(((Counter.Get) message).counterId);
        else return null;
      }

      @Override
      public Object entityMessage(Object message) {
        if (message instanceof Counter.EntityEnvelope)
          return ((Counter.EntityEnvelope) message).payload;
        else return message;
      }

      @Override
      public String shardId(Object message) {
        int numberOfShards = 100;
        if (message instanceof Counter.EntityEnvelope) {
          long id = ((Counter.EntityEnvelope) message).id;
          return String.valueOf(id % numberOfShards);
        } else if (message instanceof Counter.Get) {
          long id = ((Counter.Get) message).counterId;
          return String.valueOf(id % numberOfShards);
        } else {
          return null;
        }
      }
    };</code></pre></dd>
</dl>
<p>This example illustrates two different ways to define the entity identifier in the messages:</p>
<ul>
  <li>The <code>Get</code> message includes the identifier itself.</li>
  <li>The <code>EntityEnvelope</code> holds the identifier, and the actual message that is sent to the entity actor is wrapped in the envelope.</li>
</ul>
<p>Note how these two messages types are handled in the <span class="group-scala"><code>extractEntityId</code> function</span> <span class="group-java"><code>entityId</code> and <code>entityMessage</code> methods</span> shown above. The message sent to the entity actor is <span class="group-scala">the second part of the tuple returned by the <code>extractEntityId</code></span> <span class="group-java">what <code>entityMessage</code> returns</span> and that makes it possible to unwrap envelopes if needed.</p>
<p>A shard is a group of entities that will be managed together. The grouping is defined by the <code>extractShardId</code> function shown above. For a specific entity identifier the shard identifier must always be the same. Otherwise the entity actor might accidentally be started in several places at the same time.</p>
<p>Creating a good sharding algorithm is an interesting challenge in itself. Try to produce a uniform distribution, i.e. same amount of entities in each shard. As a rule of thumb, the number of shards should be a factor ten greater than the planned maximum number of cluster nodes. Less shards than number of nodes will result in that some nodes will not host any shards. Too many shards will result in less efficient management of the shards, e.g. rebalancing overhead, and increased latency because the coordinator is involved in the routing of the first message for each shard. The sharding algorithm must be the same on all nodes in a running cluster. It can be changed after stopping all nodes in the cluster.</p>
<p>A simple sharding algorithm that works fine in most cases is to take the absolute value of the <code>hashCode</code> of the entity identifier modulo number of shards. As a convenience this is provided by the <code>ShardRegion.HashCodeMessageExtractor</code>.</p>
<p>Messages to the entities are always sent via the local <code>ShardRegion</code>. The <code>ShardRegion</code> actor reference for a named entity type is returned by <code>ClusterSharding.start</code> and it can also be retrieved with <code>ClusterSharding.shardRegion</code>. The <code>ShardRegion</code> will lookup the location of the shard for the entity if it does not already know its location. It will delegate the message to the right node and it will create the entity actor on demand, i.e. when the first message for a specific entity is delivered.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L659-L665" target="_blank" title="Go to snippet source"></a><code class="language-scala">val counterRegion: ActorRef = ClusterSharding(system).shardRegion(&quot;Counter&quot;)
counterRegion ! Get(123)
expectMsg(0)

counterRegion ! EntityEnvelope(123, Increment)
counterRegion ! Get(123)
expectMsg(1)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L88-L92" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef counterRegion = ClusterSharding.get(system).shardRegion(&quot;Counter&quot;);
counterRegion.tell(new Counter.Get(123), getSelf());

counterRegion.tell(new Counter.EntityEnvelope(123, Counter.CounterOp.INCREMENT), getSelf());
counterRegion.tell(new Counter.Get(123), getSelf());</code></pre></dd>
</dl><div class="group-scala">
<p>A more comprehensive sample is available in the tutorial named <a href="https://github.com/typesafehub/activator-akka-cluster-sharding-scala">Akka Cluster Sharding with Scala!</a>.</p></div>
<h2><a href="#how-it-works" name="how-it-works" class="anchor"><span class="anchor-link"></span></a>How it works</h2>
<p>The <code>ShardRegion</code> actor is started on each node in the cluster, or group of nodes tagged with a specific role. The <code>ShardRegion</code> is created with two application specific functions to extract the entity identifier and the shard identifier from incoming messages. A <code>Shard</code> is a group of entities that will be managed together. For the first message in a specific shard the <code>ShardRegion</code> requests the location of the shard from a central coordinator, the <code>ShardCoordinator</code>.</p>
<p>The <code>ShardCoordinator</code> decides which <code>ShardRegion</code> shall own the <code>Shard</code> and informs that <code>ShardRegion</code>. The region will confirm this request and create the <code>Shard</code> supervisor as a child actor. The individual <code>Entities</code> will then be created when needed by the <code>Shard</code> actor. Incoming messages thus travel via the <code>ShardRegion</code> and the <code>Shard</code> to the target <code>Entity</code>.</p>
<p>If the shard home is another <code>ShardRegion</code> instance messages will be forwarded to that <code>ShardRegion</code> instance instead. While resolving the location of a shard incoming messages for that shard are buffered and later delivered when the shard home is known. Subsequent messages to the resolved shard can be delivered to the target destination immediately without involving the <code>ShardCoordinator</code>.</p>
<h3><a href="#scenarios" name="scenarios" class="anchor"><span class="anchor-link"></span></a>Scenarios</h3>
<p>Once a <code>Shard</code> location is known <code>ShardRegion</code>s send messages directly. Here are the scenarios for getting to this state. In the scenarios the following notation is used:</p>
<ul>
  <li><code>SC</code> - ShardCoordinator</li>
  <li><code>M#</code> - Message 1, 2, 3, etc</li>
  <li><code>SR#</code> - ShardRegion 1, 2 3, etc</li>
  <li><code>S#</code> - Shard 1 2 3, etc</li>
  <li><code>E#</code> - Entity 1 2 3, etc. An entity refers to an Actor managed by Cluster Sharding.</li>
</ul>
<p>Where <code>#</code> is a number to distinguish between instances as there are multiple in the Cluster.</p>
<h4><a href="#scenario-1-message-to-an-unknown-shard-that-belongs-to-the-local-shardregion" name="scenario-1-message-to-an-unknown-shard-that-belongs-to-the-local-shardregion" class="anchor"><span class="anchor-link"></span></a>Scenario 1: Message to an unknown shard that belongs to the local ShardRegion</h4>
<ol>
  <li>Incoming message <code>M1</code> to <code>ShardRegion</code> instance <code>SR1</code>.</li>
  <li><code>M1</code> is mapped to shard <code>S1</code>. <code>SR1</code> doesn&rsquo;t know about <code>S1</code>, so it asks the <code>SC</code> for the location of <code>S1</code>.</li>
  <li><code>SC</code> answers that the home of <code>S1</code> is <code>SR1</code>.</li>
  <li><code>R1</code> creates child actor for the entity <code>E1</code> and sends buffered messages for <code>S1</code> to <code>E1</code> child</li>
  <li>All incoming messages for <code>S1</code> which arrive at <code>R1</code> can be handled by <code>R1</code> without <code>SC</code>. It creates entity children as needed, and forwards messages to them.</li>
</ol>
<h4><a href="#scenario-2-message-to-an-unknown-shard-that-belongs-to-a-remote-shardregion" name="scenario-2-message-to-an-unknown-shard-that-belongs-to-a-remote-shardregion" class="anchor"><span class="anchor-link"></span></a>Scenario 2: Message to an unknown shard that belongs to a remote ShardRegion</h4>
<ol>
  <li>Incoming message <code>M2</code> to <code>ShardRegion</code> instance <code>SR1</code>.</li>
  <li><code>M2</code> is mapped to <code>S2</code>. SR1 doesn&rsquo;t know about <code>S2</code>, so it asks <code>SC</code> for the location of <code>S2</code>.</li>
  <li><code>SC</code> answers that the home of <code>S2</code> is <code>SR2</code>.</li>
  <li><code>SR1</code> sends buffered messages for <code>S2</code> to <code>SR2</code>.</li>
  <li>All incoming messages for <code>S2</code> which arrive at <code>SR1</code> can be handled by <code>SR1</code> without <code>SC</code>. It forwards messages to <code>SR2</code>.</li>
  <li><code>SR2</code> receives message for <code>S2</code>, ask <code>SC</code>, which answers that the home of <code>S2</code> is <code>SR2</code>, and we are in Scenario 1 (but for <code>SR2</code>).</li>
</ol>
<h3><a href="#shard-location" name="shard-location" class="anchor"><span class="anchor-link"></span></a>Shard location</h3>
<p>To make sure that at most one instance of a specific entity actor is running somewhere in the cluster it is important that all nodes have the same view of where the shards are located. Therefore the shard allocation decisions are taken by the central <code>ShardCoordinator</code>, which is running as a cluster singleton, i.e. one instance on the oldest member among all cluster nodes or a group of nodes tagged with a specific role.</p>
<p>The logic that decides where a shard is to be located is defined in a pluggable shard allocation strategy. The default implementation <code>ShardCoordinator.LeastShardAllocationStrategy</code> allocates new shards to the <code>ShardRegion</code> with least number of previously allocated shards. This strategy can be replaced by an application specific implementation.</p>
<h3><a href="#shard-rebalancing" name="shard-rebalancing" class="anchor"><span class="anchor-link"></span></a>Shard Rebalancing</h3>
<p>To be able to use newly added members in the cluster the coordinator facilitates rebalancing of shards, i.e. migrate entities from one node to another. In the rebalance process the coordinator first notifies all <code>ShardRegion</code> actors that a handoff for a shard has started. That means they will start buffering incoming messages for that shard, in the same way as if the shard location is unknown. During the rebalance process the coordinator will not answer any requests for the location of shards that are being rebalanced, i.e. local buffering will continue until the handoff is completed. The <code>ShardRegion</code> responsible for the rebalanced shard will stop all entities in that shard by sending the specified <code>stopMessage</code> (default <code>PoisonPill</code>) to them. When all entities have been terminated the <code>ShardRegion</code> owning the entities will acknowledge the handoff as completed to the coordinator. Thereafter the coordinator will reply to requests for the location of the shard and thereby allocate a new home for the shard and then buffered messages in the <code>ShardRegion</code> actors are delivered to the new location. This means that the state of the entities are not transferred or migrated. If the state of the entities are of importance it should be persistent (durable), e.g. with <a href="persistence.html">Persistence</a>, so that it can be recovered at the new location.</p>
<p>The logic that decides which shards to rebalance is defined in a pluggable shard allocation strategy. The default implementation <code>ShardCoordinator.LeastShardAllocationStrategy</code> picks shards for handoff from the <code>ShardRegion</code> with most number of previously allocated shards. They will then be allocated to the <code>ShardRegion</code> with least number of previously allocated shards, i.e. new members in the cluster.</p>
<p>For the <code>LeastShardAllocationStrategy</code> there is a configurable threshold (<code>rebalance-threshold</code>) of how large the difference must be to begin the rebalancing. The difference between number of shards in the region with most shards and the region with least shards must be greater than the <code>rebalance-threshold</code> for the rebalance to occur.</p>
<p>A <code>rebalance-threshold</code> of 1 gives the best distribution and therefore typically the best choice. A higher threshold means that more shards can be rebalanced at the same time instead of one-by-one. That has the advantage that the rebalance process can be quicker but has the drawback that the the number of shards (and therefore load) between different nodes may be significantly different.</p>
<h3><a href="#shard-coordinator-state" name="shard-coordinator-state" class="anchor"><span class="anchor-link"></span></a>Shard Coordinator State</h3>
<p>The state of shard locations in the <code>ShardCoordinator</code> is persistent (durable) with <a href="distributed-data.html">Distributed Data</a> or <a href="persistence.html">Persistence</a> to survive failures. When a crashed or unreachable coordinator node has been removed (via down) from the cluster a new <code>ShardCoordinator</code> singleton actor will take over and the state is recovered. During such a failure period shards with known location are still available, while messages for new (unknown) shards are buffered until the new <code>ShardCoordinator</code> becomes available.</p>
<h3><a href="#message-ordering" name="message-ordering" class="anchor"><span class="anchor-link"></span></a>Message ordering</h3>
<p>As long as a sender uses the same <code>ShardRegion</code> actor to deliver messages to an entity actor the order of the messages is preserved. As long as the buffer limit is not reached messages are delivered on a best effort basis, with at-most once delivery semantics, in the same way as ordinary message sending. Reliable end-to-end messaging, with at-least-once semantics can be added by using <code>AtLeastOnceDelivery</code> in <a href="persistence.html">Persistence</a>.</p>
<h3><a href="#overhead" name="overhead" class="anchor"><span class="anchor-link"></span></a>Overhead</h3>
<p>Some additional latency is introduced for messages targeted to new or previously unused shards due to the round-trip to the coordinator. Rebalancing of shards may also add latency. This should be considered when designing the application specific shard resolution, e.g. to avoid too fine grained shards. Once a shard&rsquo;s location is known the only overhead is sending a message via the <code>ShardRegion</code> rather than directly.</p>
<a id="cluster-sharding-mode"></a>
<h2><a href="#distributed-data-vs-persistence-mode" name="distributed-data-vs-persistence-mode" class="anchor"><span class="anchor-link"></span></a>Distributed Data vs. Persistence Mode</h2>
<p>The state of the coordinator and the state of <a href="#cluster-sharding-remembering">Remembering Entities</a> of the shards are persistent (durable) to survive failures. <a href="distributed-data.html">Distributed Data</a> or <a href="persistence.html">Persistence</a> can be used for the storage. Distributed Data is used by default.</p>
<p>The functionality when using the two modes is the same. If your sharded entities are not using Akka Persistence themselves it is more convenient to use the Distributed Data mode, since then you don&rsquo;t have to setup and operate a separate data store (e.g. Cassandra) for persistence. Aside from that, there are no major reasons for using one mode over the the other.</p>
<p>It&rsquo;s important to use the same mode on all nodes in the cluster, i.e. it&rsquo;s not possible to perform a rolling upgrade to change this setting.</p>
<h3><a href="#distributed-data-mode" name="distributed-data-mode" class="anchor"><span class="anchor-link"></span></a>Distributed Data Mode</h3>
<p>This mode is enabled with configuration (enabled by default):</p>
<pre><code>akka.cluster.sharding.state-store-mode = ddata
</code></pre>
<p>The state of the <code>ShardCoordinator</code> will be replicated inside a cluster by the <a href="distributed-data.html">Distributed Data</a> module with <code>WriteMajority</code>/<code>ReadMajority</code> consistency. The state of the coordinator is not durable, it&rsquo;s not stored to disk. When all nodes in the cluster have been stopped the state is lost and not needed any more.</p>
<p>The state of <a href="#cluster-sharding-remembering">Remembering Entities</a> is also durable, i.e. it is stored to disk. The stored entities are started also after a complete cluster restart.</p>
<p>Cluster Sharding is using its own Distributed Data <code>Replicator</code> per node role. In this way you can use a subset of all nodes for some entity types and another subset for other entity types. Each such replicator has a name that contains the node role and therefore the role configuration must be the same on all nodes in the cluster, i.e. you can&rsquo;t change the roles when performing a rolling upgrade.</p>
<p>The settings for Distributed Data is configured in the the section <code>akka.cluster.sharding.distributed-data</code>. It&rsquo;s not possible to have different <code>distributed-data</code> settings for different sharding entity types.</p>
<h3><a href="#persistence-mode" name="persistence-mode" class="anchor"><span class="anchor-link"></span></a>Persistence Mode</h3>
<p>This mode is enabled with configuration:</p>
<pre><code>akka.cluster.sharding.state-store-mode = persistence
</code></pre>
<p>Since it is running in a cluster <a href="persistence.html">Persistence</a> must be configured with a distributed journal.</p>
<h2><a href="#startup-after-minimum-number-of-members" name="startup-after-minimum-number-of-members" class="anchor"><span class="anchor-link"></span></a>Startup after minimum number of members</h2>
<p>It&rsquo;s good to use Cluster Sharding with the Cluster setting <code>akka.cluster.min-nr-of-members</code> or <code>akka.cluster.role.&lt;role-name&gt;.min-nr-of-members</code>. That will defer the allocation of the shards until at least that number of regions have been started and registered to the coordinator. This avoids that many shards are allocated to the first region that registers and only later are rebalanced to other nodes.</p>
<p>See <a href="cluster-usage.html#min-members">How To Startup when Cluster Size Reached</a> for more information about <code>min-nr-of-members</code>.</p>
<h2><a href="#proxy-only-mode" name="proxy-only-mode" class="anchor"><span class="anchor-link"></span></a>Proxy Only Mode</h2>
<p>The <code>ShardRegion</code> actor can also be started in proxy only mode, i.e. it will not host any entities itself, but knows how to delegate messages to the right location. A <code>ShardRegion</code> is started in proxy only mode with the <code>ClusterSharding.startProxy</code> method. Also a <code>ShardRegion</code> is started in proxy only mode in case if there is no match between the roles of the current cluster node and the role specified in <code>ClusterShardingSettings</code> passed to the <code>ClusterSharding.start</code> method.</p>
<h2><a href="#passivation" name="passivation" class="anchor"><span class="anchor-link"></span></a>Passivation</h2>
<p>If the state of the entities are persistent you may stop entities that are not used to reduce memory consumption. This is done by the application specific implementation of the entity actors for example by defining receive timeout (<code>context.setReceiveTimeout</code>). If a message is already enqueued to the entity when it stops itself the enqueued message in the mailbox will be dropped. To support graceful passivation without losing such messages the entity actor can send <code>ShardRegion.Passivate</code> to its parent <code>Shard</code>. The specified wrapped message in <code>Passivate</code> will be sent back to the entity, which is then supposed to stop itself. Incoming messages will be buffered by the <code>Shard</code> between reception of <code>Passivate</code> and termination of the entity. Such buffered messages are thereafter delivered to a new incarnation of the entity.</p>
<h3><a href="#automatic-passivation" name="automatic-passivation" class="anchor"><span class="anchor-link"></span></a>Automatic Passivation</h3>
<p>The entities can be configured to be automatically passivated if they haven&rsquo;t received a message for a while using the <code>akka.cluster.sharding.passivate-idle-entity-after</code> setting, or by explicitly setting <code>ClusterShardingSettings.passivateIdleEntityAfter</code> to a suitable time to keep the actor alive. Note that only messages sent through sharding are counted, so direct messages to the <code>ActorRef</code> of the actor or messages that it sends to itself are not counted as activity. By default automatic passivation is disabled. </p>
<a id="cluster-sharding-remembering"></a>
<h2><a href="#remembering-entities" name="remembering-entities" class="anchor"><span class="anchor-link"></span></a>Remembering Entities</h2>
<p>The list of entities in each <code>Shard</code> can be made persistent (durable) by setting the <code>rememberEntities</code> flag to true in <code>ClusterShardingSettings</code> when calling <code>ClusterSharding.start</code> and making sure the <code>shardIdExtractor</code> handles <code>Shard.StartEntity(EntityId)</code> which implies that a <code>ShardId</code> must be possible to extract from the <code>EntityId</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L199-L205" target="_blank" title="Go to snippet source"></a><code class="language-scala">val extractShardId: ShardRegion.ExtractShardId = {
  case EntityEnvelope(id, _) ⇒ (id % numberOfShards).toString
  case Get(id)               ⇒ (id % numberOfShards).toString
  case ShardRegion.StartEntity(id) ⇒
    // StartEntity is used by remembering entities feature
    (id.toLong % numberOfShards).toString
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L133-L148" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public String shardId(Object message) {
  int numberOfShards = 100;
  if (message instanceof Counter.EntityEnvelope) {
    long id = ((Counter.EntityEnvelope) message).id;
    return String.valueOf(id % numberOfShards);
  } else if (message instanceof Counter.Get) {
    long id = ((Counter.Get) message).counterId;
    return String.valueOf(id % numberOfShards);
  } else if (message instanceof ShardRegion.StartEntity) {
    long id = Long.valueOf(((ShardRegion.StartEntity) message).entityId());
    return String.valueOf(id % numberOfShards);
  } else {
    return null;
  }
}</code></pre></dd>
</dl>
<p>When configured to remember entities, whenever a <code>Shard</code> is rebalanced onto another node or recovers after a crash it will recreate all the entities which were previously running in that <code>Shard</code>. To permanently stop entities, a <code>Passivate</code> message must be sent to the parent of the entity actor, otherwise the entity will be automatically restarted after the entity restart backoff specified in the configuration.</p>
<p>When <a href="#cluster-sharding-mode">Distributed Data mode</a> is used the identifiers of the entities are stored in <a href="distributed-data.html#ddata-durable">Durable Storage</a> of Distributed Data. You may want to change the configuration of the <code>akka.cluster.sharding.distributed-data.durable.lmdb.dir</code>, since the default directory contains the remote port of the actor system. If using a dynamically assigned port (0) it will be different each time and the previously stored data will not be loaded.</p>
<p>When <code>rememberEntities</code> is set to false, a <code>Shard</code> will not automatically restart any entities after a rebalance or recovering from a crash. Entities will only be started once the first message for that entity has been received in the <code>Shard</code>. Entities will not be restarted if they stop without using a <code>Passivate</code>.</p>
<p>Note that the state of the entities themselves will not be restored unless they have been made persistent, e.g. with <a href="persistence.html">Persistence</a>.</p>
<p>The performance cost of <code>rememberEntities</code> is rather high when starting/stopping entities and when shards are rebalanced. This cost increases with number of entities per shard and we currently don&rsquo;t recommend using it with more than 10000 entities per shard.</p>
<h2><a href="#supervision" name="supervision" class="anchor"><span class="anchor-link"></span></a>Supervision</h2>
<p>If you need to use another <code>supervisorStrategy</code> for the entity actors than the default (restarting) strategy you need to create an intermediate parent actor that defines the <code>supervisorStrategy</code> to the child entity actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L103-L116" target="_blank" title="Go to snippet source"></a><code class="language-scala">class CounterSupervisor extends Actor {
  val counter = context.actorOf(Props[Counter], &quot;theCounter&quot;)

  override val supervisorStrategy = OneForOneStrategy() {
    case _: IllegalArgumentException     ⇒ SupervisorStrategy.Resume
    case _: ActorInitializationException ⇒ SupervisorStrategy.Stop
    case _: DeathPactException           ⇒ SupervisorStrategy.Stop
    case _: Exception                    ⇒ SupervisorStrategy.Restart
  }

  def receive = {
    case msg ⇒ counter forward msg
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L241-L265" target="_blank" title="Go to snippet source"></a><code class="language-java">static class CounterSupervisor extends AbstractActor {

  private final ActorRef counter =
      getContext().actorOf(Props.create(Counter.class), &quot;theCounter&quot;);

  private static final SupervisorStrategy strategy =
      new OneForOneStrategy(
          DeciderBuilder.match(IllegalArgumentException.class, e -&gt; SupervisorStrategy.resume())
              .match(ActorInitializationException.class, e -&gt; SupervisorStrategy.stop())
              .match(Exception.class, e -&gt; SupervisorStrategy.restart())
              .matchAny(o -&gt; SupervisorStrategy.escalate())
              .build());

  @Override
  public SupervisorStrategy supervisorStrategy() {
    return strategy;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Object.class, msg -&gt; counter.forward(msg, getContext()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>You start such a supervisor in the same way as if it was the entity actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/multi-jvm/scala/akka/cluster/sharding/ClusterShardingSpec.scala#L648-L653" target="_blank" title="Go to snippet source"></a><code class="language-scala">ClusterSharding(system).start(
  typeName = &quot;SupervisedCounter&quot;,
  entityProps = Props[CounterSupervisor],
  settings = ClusterShardingSettings(system),
  extractEntityId = extractEntityId,
  extractShardId = extractShardId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/sharding/ClusterShardingTest.java#L96-L98" target="_blank" title="Go to snippet source"></a><code class="language-java">ClusterSharding.get(system)
    .start(
        &quot;SupervisedCounter&quot;, Props.create(CounterSupervisor.class), settings, messageExtractor);</code></pre></dd>
</dl>
<p>Note that stopped entities will be started again when a new message is targeted to the entity.</p>
<h2><a href="#graceful-shutdown" name="graceful-shutdown" class="anchor"><span class="anchor-link"></span></a>Graceful Shutdown</h2>
<p>You can send the <span class="group-scala"><code>ShardRegion.GracefulShutdown</code></span> <span class="group-java"><code>ShardRegion.gracefulShutdownInstance</code></span> message to the <code>ShardRegion</code> actor to hand off all shards that are hosted by that <code>ShardRegion</code> and then the <code>ShardRegion</code> actor will be stopped. You can <code>watch</code> the <code>ShardRegion</code> actor to know when it is completed. During this period other regions will buffer messages for those shards in the same way as when a rebalance is triggered by the coordinator. When the shards have been stopped the coordinator will allocate these shards elsewhere.</p>
<p>This is performed automatically by the <a href="actors.html#coordinated-shutdown">Coordinated Shutdown</a> and is therefore part of the graceful leaving process of a cluster member.</p>
<a id="removeinternalclustershardingdata"></a>
<h2><a href="#removal-of-internal-cluster-sharding-data" name="removal-of-internal-cluster-sharding-data" class="anchor"><span class="anchor-link"></span></a>Removal of Internal Cluster Sharding Data</h2>
<p>The Cluster Sharding coordinator stores the locations of the shards using Akka Persistence. This data can safely be removed when restarting the whole Akka Cluster. Note that this is not application data.</p>
<p>There is a utility program <code>akka.cluster.sharding.RemoveInternalClusterShardingData</code> that removes this data.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Never use this program while there are running Akka Cluster nodes that are using Cluster Sharding. Stop all Cluster nodes before using this program.</p></div>
<p>It can be needed to remove the data if the Cluster Sharding coordinator cannot startup because of corrupt data, which may happen if accidentally two clusters were running at the same time, e.g. caused by using auto-down and there was a network partition.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><strong>Don&rsquo;t use Cluster Sharding together with Automatic Downing</strong>, since it allows the cluster to split up into two separate clusters, which in turn will result in <em>multiple shards and entities</em> being started, one in each separate cluster! See <a href="cluster-usage.html#automatic-vs-manual-downing">Downing</a>.</p></div>
<p>Use this program as a standalone Java main program:</p>
<pre><code>java -classpath &lt;jar files, including akka-cluster-sharding&gt;
  akka.cluster.sharding.RemoveInternalClusterShardingData
    -2.3 entityType1 entityType2 entityType3
</code></pre>
<p>The program is included in the <code>akka-cluster-sharding</code> jar file. It is easiest to run it with same classpath and configuration as your ordinary application. It can be run from sbt or Maven in similar way.</p>
<p>Specify the entity type names (same as you use in the <code>start</code> method of <code>ClusterSharding</code>) as program arguments.</p>
<p>If you specify <code>-2.3</code> as the first program argument it will also try to remove data that was stored by Cluster Sharding in Akka 2.3.x using different persistenceId.</p>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>The <code>ClusterSharding</code> extension can be configured with the following properties. These configuration properties are read by the <code>ClusterShardingSettings</code> when created with a <code>ActorSystem</code> parameter. It is also possible to amend the <code>ClusterShardingSettings</code> or create it from another config section with the same layout as below. <code>ClusterShardingSettings</code> is a parameter to the <code>start</code> method of the <code>ClusterSharding</code> extension, i.e. each each entity type can be configured with different settings if needed.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-sharding/src/main/resources/reference.conf#L10-L164" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Settings for the ClusterShardingExtension
akka.cluster.sharding {

  # The extension creates a top level actor with this name in top level system scope,
  # e.g. &#39;/system/sharding&#39;
  guardian-name = sharding

  # Specifies that entities runs on cluster nodes with a specific role.
  # If the role is not specified (or empty) all nodes in the cluster are used.
  role = &quot;&quot;

  # When this is set to &#39;on&#39; the active entity actors will automatically be restarted
  # upon Shard restart. i.e. if the Shard is started on a different ShardRegion
  # due to rebalance or crash.
  remember-entities = off

  # Set this to a time duration to have sharding passivate entities when they have not
  # gotten any message in this long time. Set to &#39;off&#39; to disable.
  passivate-idle-entity-after = off

  # If the coordinator can&#39;t store state changes it will be stopped
  # and started again after this duration, with an exponential back-off
  # of up to 5 times this duration.
  coordinator-failure-backoff = 5 s

  # The ShardRegion retries registration and shard location requests to the
  # ShardCoordinator with this interval if it does not reply.
  retry-interval = 2 s

  # Maximum number of messages that are buffered by a ShardRegion actor.
  buffer-size = 100000

  # Timeout of the shard rebalancing process.
  # Additionally, if an entity doesn&#39;t handle the stopMessage
  # after (handoff-timeout - 5.seconds).max(1.second) it will be stopped forcefully
  handoff-timeout = 60 s

  # Time given to a region to acknowledge it&#39;s hosting a shard.
  shard-start-timeout = 10 s

  # If the shard is remembering entities and can&#39;t store state changes
  # will be stopped and then started again after this duration. Any messages
  # sent to an affected entity may be lost in this process.
  shard-failure-backoff = 10 s

  # If the shard is remembering entities and an entity stops itself without
  # using passivate. The entity will be restarted after this duration or when
  # the next message for it is received, which ever occurs first.
  entity-restart-backoff = 10 s

  # Rebalance check is performed periodically with this interval.
  rebalance-interval = 10 s

  # Absolute path to the journal plugin configuration entity that is to be
  # used for the internal persistence of ClusterSharding. If not defined
  # the default journal plugin is used. Note that this is not related to
  # persistence used by the entity actors.
  # Only used when state-store-mode=persistence
  journal-plugin-id = &quot;&quot;

  # Absolute path to the snapshot plugin configuration entity that is to be
  # used for the internal persistence of ClusterSharding. If not defined
  # the default snapshot plugin is used. Note that this is not related to
  # persistence used by the entity actors.
  # Only used when state-store-mode=persistence
  snapshot-plugin-id = &quot;&quot;

  # Defines how the coordinator stores its state. Same is also used by the
  # shards for rememberEntities.
  # Valid values are &quot;ddata&quot; or &quot;persistence&quot;. 
  state-store-mode = &quot;ddata&quot;

  # The shard saves persistent snapshots after this number of persistent
  # events. Snapshots are used to reduce recovery times.
  # Only used when state-store-mode=persistence
  snapshot-after = 1000

  # The shard deletes persistent events (messages and snapshots) after doing snapshot
  # keeping this number of old persistent batches.
  # Batch is of size `snapshot-after`.
  # When set to 0 after snapshot is successfully done all messages with equal or lower sequence number will be deleted.
  # Default value of 2 leaves last maximum 2*`snapshot-after` messages and 3 snapshots (2 old ones + fresh snapshot)
  keep-nr-of-batches = 2

  # Setting for the default shard allocation strategy
  least-shard-allocation-strategy {
    # Threshold of how large the difference between most and least number of
    # allocated shards must be to begin the rebalancing.
    # The difference between number of shards in the region with most shards and
    # the region with least shards must be greater than (&gt;) the `rebalanceThreshold`
    # for the rebalance to occur.
    # 1 gives the best distribution and therefore typically the best choice.
    # Increasing the threshold can result in quicker rebalance but has the
    # drawback of increased difference between number of shards (and therefore load)
    # on different nodes before rebalance will occur.
    rebalance-threshold = 1

    # The number of ongoing rebalancing processes is limited to this number.
    max-simultaneous-rebalance = 3
  }

  # Timeout of waiting the initial distributed state (an initial state will be queried again if the timeout happened)
  # Only used when state-store-mode=ddata
  waiting-for-state-timeout = 5 s

  # Timeout of waiting for update the distributed state (update will be retried if the timeout happened)
  # Only used when state-store-mode=ddata
  updating-state-timeout = 5 s

  # The shard uses this strategy to determines how to recover the underlying entity actors. The strategy is only used
  # by the persistent shard when rebalancing or restarting. The value can either be &quot;all&quot; or &quot;constant&quot;. The &quot;all&quot;
  # strategy start all the underlying entity actors at the same time. The constant strategy will start the underlying
  # entity actors at a fix rate. The default strategy &quot;all&quot;.
  entity-recovery-strategy = &quot;all&quot;

  # Default settings for the constant rate entity recovery strategy
  entity-recovery-constant-rate-strategy {
    # Sets the frequency at which a batch of entity actors is started.
    frequency = 100 ms
    # Sets the number of entity actors to be restart at a particular interval
    number-of-entities = 5
  }

  # Settings for the coordinator singleton. Same layout as akka.cluster.singleton.
  # The &quot;role&quot; of the singleton configuration is not used. The singleton role will
  # be the same as &quot;akka.cluster.sharding.role&quot;.
  coordinator-singleton = ${akka.cluster.singleton}
  
  # Settings for the Distributed Data replicator. 
  # Same layout as akka.cluster.distributed-data.
  # The &quot;role&quot; of the distributed-data configuration is not used. The distributed-data
  # role will be the same as &quot;akka.cluster.sharding.role&quot;.
  # Note that there is one Replicator per role and it&#39;s not possible
  # to have different distributed-data settings for different sharding entity types.
  # Only used when state-store-mode=ddata
  distributed-data = ${akka.cluster.distributed-data}
  distributed-data {
    # minCap parameter to MajorityWrite and MajorityRead consistency level.
    majority-min-cap = 5
    durable.keys = [&quot;shard-*&quot;]
    
    # When using many entities with &quot;remember entities&quot; the Gossip message
    # can become to large if including to many in same message. Limit to
    # the same number as the number of ORSet per shard.
    max-delta-elements = 5
    
  }

  # The id of the dispatcher to use for ClusterSharding actors.
  # If not specified default dispatcher is used.
  # If specified you need to define the settings of the actual dispatcher.
  # This dispatcher for the entity actors is defined by the user provided
  # Props, i.e. this dispatcher is not used for the entity actors.
  use-dispatcher = &quot;&quot;
}</code></pre>
<p>Custom shard allocation strategy can be defined in an optional parameter to <code>ClusterSharding.start</code>. See the API documentation of <span class="group-scala"><code>ShardAllocationStrategy</code></span> <span class="group-java"><code>AbstractShardAllocationStrategy</code></span> for details of how to implement a custom shard allocation strategy.</p>
<h2><a href="#inspecting-cluster-sharding-state" name="inspecting-cluster-sharding-state" class="anchor"><span class="anchor-link"></span></a>Inspecting cluster sharding state</h2>
<p>Two requests to inspect the cluster state are available:</p>
<p><span class="group-scala"><code>ShardRegion.GetShardRegionState</code></span> <span class="group-java"><code>ShardRegion.getShardRegionStateInstance</code></span> which will return a <span class="group-scala"><code>ShardRegion.CurrentShardRegionState</code></span> <span class="group-java"><code>ShardRegion.ShardRegionState</code></span> that contains the identifiers of the shards running in a Region and what entities are alive for each of them.</p>
<p><code>ShardRegion.GetClusterShardingStats</code> which will query all the regions in the cluster and return a <code>ShardRegion.ClusterShardingStats</code> containing the identifiers of the shards running in each region and a count of entities that are alive in each shard.</p>
<p>The type names of all started shards can be acquired via <span class="group-scala"><code>ClusterSharding.shardTypeNames</code></span> <span class="group-java"><code>ClusterSharding.getShardTypeNames</code></span>.</p>
<p>The purpose of these messages is testing and monitoring, they are not provided to give access to directly sending messages to the individual entities.</p>
<h2><a href="#rolling-upgrades" name="rolling-upgrades" class="anchor"><span class="anchor-link"></span></a>Rolling upgrades</h2>
<p>When doing rolling upgrades special care must be taken to not change any of the following aspects of sharding:</p>
<ul>
  <li>the <code>extractShardId</code> function</li>
  <li>the role that the shard regions run on</li>
  <li>the persistence mode</li>
</ul>
<p>If any one of these needs a change it will require a full cluster restart.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="cluster-client.html"><i class="icon-prev"></i> <span class="link-prev">Cluster Client</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="cluster-metrics.html">Cluster Metrics Extension <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/cluster-sharding.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
