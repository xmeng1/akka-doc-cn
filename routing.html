<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Routing &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/routing.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html#routing" class="active page">Routing</a>
    <ul>
      <li><a href="routing.html#dependency" class="header">Dependency</a></li>
      <li><a href="routing.html#introduction" class="header">Introduction</a></li>
      <li><a href="routing.html#a-simple-router" class="header">A Simple Router</a></li>
      <li><a href="routing.html#a-router-actor" class="header">A Router Actor</a></li>
      <li><a href="routing.html#router-usage" class="header">Router usage</a></li>
      <li><a href="routing.html#specially-handled-messages" class="header">Specially Handled Messages</a></li>
      <li><a href="routing.html#dynamically-resizable-pool" class="header">Dynamically Resizable Pool</a></li>
      <li><a href="routing.html#how-routing-is-designed-within-akka" class="header">How Routing is Designed within Akka</a></li>
      <li><a href="routing.html#custom-router" class="header">Custom Router</a></li>
      <li><a href="routing.html#configuring-dispatchers" class="header">Configuring Dispatchers</a></li>
    </ul></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html#routing" class="active page">Routing</a>
    <ul>
      <li><a href="routing.html#dependency" class="header">Dependency</a></li>
      <li><a href="routing.html#introduction" class="header">Introduction</a></li>
      <li><a href="routing.html#a-simple-router" class="header">A Simple Router</a></li>
      <li><a href="routing.html#a-router-actor" class="header">A Router Actor</a></li>
      <li><a href="routing.html#router-usage" class="header">Router usage</a></li>
      <li><a href="routing.html#specially-handled-messages" class="header">Specially Handled Messages</a></li>
      <li><a href="routing.html#dynamically-resizable-pool" class="header">Dynamically Resizable Pool</a></li>
      <li><a href="routing.html#how-routing-is-designed-within-akka" class="header">How Routing is Designed within Akka</a></li>
      <li><a href="routing.html#custom-router" class="header">Custom Router</a></li>
      <li><a href="routing.html#configuring-dispatchers" class="header">Configuring Dispatchers</a></li>
    </ul></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#routing" name="routing" class="anchor"><span class="anchor-link"></span></a>Routing</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Routing, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Messages can be sent via a router to efficiently route them to destination actors, known as its <em>routees</em>. A <code>Router</code> can be used inside or outside of an actor, and you can manage the routees yourselves or use a self contained router actor with configuration capabilities.</p>
<p>Different routing strategies can be used, according to your application&rsquo;s needs. Akka comes with several useful routing strategies right out of the box. But, as you will see in this chapter, it is also possible to <a href="#custom-router">create your own</a>.</p>
<a id="simple-router"></a>
<h2><a href="#a-simple-router" name="a-simple-router" class="anchor"><span class="anchor-link"></span></a>A Simple Router</h2>
<p>The following example illustrates how to use a <code>Router</code> and manage the routees from within an actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L297-L318" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.routing.{ ActorRefRoutee, RoundRobinRoutingLogic, Router }

class Master extends Actor {
  var router = {
    val routees = Vector.fill(5) {
      val r = context.actorOf(Props[Worker])
      context watch r
      ActorRefRoutee(r)
    }
    Router(RoundRobinRoutingLogic(), routees)
  }

  def receive = {
    case w: Work ⇒
      router.route(w, sender())
    case Terminated(a) ⇒
      router = router.removeRoutee(a)
      val r = context.actorOf(Props[Worker])
      context watch r
      router = router.addRoutee(r)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L78-L123" target="_blank" title="Go to snippet source"></a><code class="language-java">static final class Work implements Serializable {
  private static final long serialVersionUID = 1L;
  public final String payload;

  public Work(String payload) {
    this.payload = payload;
  }
}

static class Master extends AbstractActor {

  Router router;

  {
    List&lt;Routee&gt; routees = new ArrayList&lt;Routee&gt;();
    for (int i = 0; i &lt; 5; i++) {
      ActorRef r = getContext().actorOf(Props.create(Worker.class));
      getContext().watch(r);
      routees.add(new ActorRefRoutee(r));
    }
    router = new Router(new RoundRobinRoutingLogic(), routees);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Work.class,
            message -&gt; {
              router.route(message, getSender());
            })
        .match(
            Terminated.class,
            message -&gt; {
              router = router.removeRoutee(message.actor());
              ActorRef r = getContext().actorOf(Props.create(Worker.class));
              getContext().watch(r);
              router = router.addRoutee(new ActorRefRoutee(r));
            })
        .build();
  }
}
</code></pre></dd>
</dl>
<p>We create a <code>Router</code> and specify that it should use <code>RoundRobinRoutingLogic</code> when routing the messages to the routees.</p>
<p>The routing logic shipped with Akka are:</p>
<ul>
  <li><code>akka.routing.RoundRobinRoutingLogic</code></li>
  <li><code>akka.routing.RandomRoutingLogic</code></li>
  <li><code>akka.routing.SmallestMailboxRoutingLogic</code></li>
  <li><code>akka.routing.BroadcastRoutingLogic</code></li>
  <li><code>akka.routing.ScatterGatherFirstCompletedRoutingLogic</code></li>
  <li><code>akka.routing.TailChoppingRoutingLogic</code></li>
  <li><code>akka.routing.ConsistentHashingRoutingLogic</code></li>
</ul>
<p>We create the routees as ordinary child actors wrapped in <code>ActorRefRoutee</code>. We watch the routees to be able to replace them if they are terminated.</p>
<p>Sending messages via the router is done with the <code>route</code> method, as is done for the <code>Work</code> messages in the example above.</p>
<p>The <code>Router</code> is immutable and the <code>RoutingLogic</code> is thread safe; meaning that they can also be used outside of actors. </p><div class="callout note "><div class="callout-title">Note</div>
<p>In general, any message sent to a router will be sent onwards to its routees, but there is one exception. The special <a href="#broadcast-messages">Broadcast Messages</a> will send to <em>all</em> of a router&rsquo;s routees. However, do not use <a href="#broadcast-messages">Broadcast Messages</a> when you use <a href="#balancing-pool">BalancingPool</a> for routees as described in <a href="#router-special-messages">Specially Handled Messages</a>.</p></div>
<h2><a href="#a-router-actor" name="a-router-actor" class="anchor"><span class="anchor-link"></span></a>A Router Actor</h2>
<p>A router can also be created as a self contained actor that manages the routees itself and loads routing logic and other settings from configuration.</p>
<p>This type of router actor comes in two distinct flavors:</p>
<ul>
  <li>Pool - The router creates routees as child actors and removes them from the router if they terminate.</li>
  <li>Group - The routee actors are created externally to the router and the router sends messages to the specified path using actor selection, without watching for termination.</li>
</ul>
<p>The settings for a router actor can be defined in configuration or programmatically. In order to make an actor to make use of an externally configurable router the <code>FromConfig</code> props wrapper must be used to denote that the actor accepts routing settings from configuration. This is in contrast with Remote Deployment where such marker props is not necessary. If the props of an actor is NOT wrapped in <code>FromConfig</code> it will ignore the router section of the deployment configuration.</p>
<p>You send messages to the routees via the router actor in the same way as for ordinary actors, i.e. via its <code>ActorRef</code>. The router actor forwards messages onto its routees without changing the original sender. When a routee replies to a routed message, the reply will be sent to the original sender, not to the router actor.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In general, any message sent to a router will be sent onwards to its routees, but there are a few exceptions. These are documented in the <a href="#router-special-messages">Specially Handled Messages</a> section below.</p></div>
<h3><a href="#pool" name="pool" class="anchor"><span class="anchor-link"></span></a>Pool</h3>
<p>The following code and configuration snippets show how to create a <a href="#round-robin-router">round-robin</a> router that forwards messages to five <code>Worker</code> routees. The routees will be created as the router&rsquo;s children.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L33-L38" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router1 {
    router = round-robin-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L347-L348" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router1: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router1&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L183-L184" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router1 =
    getContext().actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router1&quot;);</code></pre></dd>
</dl>
<p>Here is the same example, but with the router configuration provided programmatically instead of from configuration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L352-L353" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router2: ActorRef =
  context.actorOf(RoundRobinPool(5).props(Props[Worker]), &quot;router2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L188-L189" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router2 =
    getContext().actorOf(new RoundRobinPool(5).props(Props.create(Worker.class)), &quot;router2&quot;);</code></pre></dd>
</dl>
<h4><a href="#remote-deployed-routees" name="remote-deployed-routees" class="anchor"><span class="anchor-link"></span></a>Remote Deployed Routees</h4>
<p>In addition to being able to create local actors as routees, you can instruct the router to deploy its created children on a set of remote hosts. Routees will be deployed in round-robin fashion. In order to deploy routees remotely, wrap the router configuration in a <code>RemoteRouterConfig</code>, attaching the remote addresses of the nodes to deploy to. Remote deployment requires the <code>akka-remote</code> module to be included in the classpath.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L605-L611" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Address, AddressFromURIString }
import akka.remote.routing.RemoteRouterConfig
val addresses = Seq(
  Address(&quot;akka.tcp&quot;, &quot;remotesys&quot;, &quot;otherhost&quot;, 1234),
  AddressFromURIString(&quot;akka.tcp://othersys@anotherhost:1234&quot;))
val routerRemote = system.actorOf(
  RemoteRouterConfig(RoundRobinPool(5), addresses).props(Props[Echo]))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L453-L460" target="_blank" title="Go to snippet source"></a><code class="language-java">Address[] addresses = {
  new Address(&quot;akka.tcp&quot;, &quot;remotesys&quot;, &quot;otherhost&quot;, 1234),
  AddressFromURIString.parse(&quot;akka.tcp://othersys@anotherhost:1234&quot;)
};
ActorRef routerRemote =
    system.actorOf(
        new RemoteRouterConfig(new RoundRobinPool(5), addresses)
            .props(Props.create(Echo.class)));</code></pre></dd>
</dl>
<h4><a href="#senders" name="senders" class="anchor"><span class="anchor-link"></span></a>Senders</h4>
<p>By default, when a routee sends a message, it will <a href="actors.html#actors-tell-sender">implicitly set itself as the sender </a>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L712" target="_blank" title="Go to snippet source"></a><code class="language-scala">sender() ! x // replies will go to this actor</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L147" target="_blank" title="Go to snippet source"></a><code class="language-java">getSender().tell(&quot;reply&quot;, getSelf());</code></pre></dd>
</dl>
<p>However, it is often useful for routees to set the <em>router</em> as a sender. For example, you might want to set the router as the sender if you want to hide the details of the routees behind the router. The following code snippet shows how to set the parent router as sender.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L707-L708" target="_blank" title="Go to snippet source"></a><code class="language-scala">sender().tell(&quot;reply&quot;, context.parent) // replies will go back to parent
sender().!(&quot;reply&quot;)(context.parent) // alternative syntax (beware of the parens!)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L151" target="_blank" title="Go to snippet source"></a><code class="language-java">getSender().tell(&quot;reply&quot;, getContext().getParent());</code></pre></dd>
</dl>
<h4><a href="#supervision" name="supervision" class="anchor"><span class="anchor-link"></span></a>Supervision</h4>
<p>Routees that are created by a pool router will be created as the router&rsquo;s children. The router is therefore also the children&rsquo;s supervisor.</p>
<p>The supervision strategy of the router actor can be configured with the <code>supervisorStrategy</code> property of the Pool. If no configuration is provided, routers default to a strategy of “always escalate”. This means that errors are passed up to the router&rsquo;s supervisor for handling. The router&rsquo;s supervisor will decide what to do about any errors.</p>
<p>Note the router&rsquo;s supervisor will treat the error as an error with the router itself. Therefore a directive to stop or restart will cause the router <em>itself</em> to stop or restart. The router, in turn, will cause its children to stop and restart.</p>
<p>It should be mentioned that the router&rsquo;s restart behavior has been overridden so that a restart, while still re-creating the children, will still preserve the same number of actors in the pool.</p>
<p>This means that if you have not specified <code>supervisorStrategy</code> of the router or its parent a failure in a routee will escalate to the parent of the router, which will by default restart the router, which will restart all routees (it uses Escalate and does not stop routees during restart). The reason is to make the default behave such that adding <code>.withRouter</code> to a child’s definition does not change the supervision strategy applied to the child. This might be an inefficiency that you can avoid by specifying the strategy when defining the router.</p>
<p>Setting the strategy is done like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-tests/src/test/scala/akka/routing/RoutingSpec.scala#L136-L142" target="_blank" title="Go to snippet source"></a><code class="language-scala">val escalator = OneForOneStrategy() {
  case e ⇒ testActor ! e; SupervisorStrategy.Escalate
}
val router = system.actorOf(RoundRobinPool(1, supervisorStrategy = escalator).props(
  routeeProps = Props[TestActor]))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L481-L488" target="_blank" title="Go to snippet source"></a><code class="language-java">final SupervisorStrategy strategy =
    new OneForOneStrategy(
        5,
        Duration.ofMinutes(1),
        Collections.&lt;Class&lt;? extends Throwable&gt;&gt;singletonList(Exception.class));
final ActorRef router =
    system.actorOf(
        new RoundRobinPool(5).withSupervisorStrategy(strategy).props(Props.create(Echo.class)));</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>If the child of a pool router terminates, the pool router will not automatically spawn a new child. In the event that all children of a pool router have terminated the router will terminate itself unless it is a dynamic router, e.g. using a resizer.</p></div>
<h3><a href="#group" name="group" class="anchor"><span class="anchor-link"></span></a>Group</h3>
<p>Sometimes, rather than having the router actor create its routees, it is desirable to create routees separately and provide them to the router for its use. You can do this by passing in paths of the routees to the router&rsquo;s configuration. Messages will be sent with <code>ActorSelection</code> to these paths, wildcards can be and will result in the same <a href="general/addressing.html#querying-the-logical-actor-hierarchy">semantics as explicitly using <code>ActorSelection</code></a>.</p>
<p>The example below shows how to create a router by providing it with the path strings of three routee actors. </p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L42-L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router3 {
    router = round-robin-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L357-L358" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router3: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router3&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L193" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router3 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router3&quot;);</code></pre></dd>
</dl>
<p>Here is the same example, but with the router configuration provided programmatically instead of from configuration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router4: ActorRef =
  context.actorOf(RoundRobinGroup(paths).props(), &quot;router4&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
ActorRef router4 = getContext().actorOf(new RoundRobinGroup(paths).props(), &quot;router4&quot;);</code></pre></dd>
</dl>
<p>The routee actors are created externally from the router:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L539" target="_blank" title="Go to snippet source"></a><code class="language-scala">system.actorOf(Props[Workers], &quot;workers&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L362" target="_blank" title="Go to snippet source"></a><code class="language-java">system.actorOf(Props.create(Workers.class), &quot;workers&quot;);</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L328-L332" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Workers extends Actor {
  context.actorOf(Props[Worker], name = &quot;w1&quot;)
  context.actorOf(Props[Worker], name = &quot;w2&quot;)
  context.actorOf(Props[Worker], name = &quot;w3&quot;)
  // ...</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L160-L167" target="_blank" title="Go to snippet source"></a><code class="language-java">static class Workers extends AbstractActor {
  @Override
  public void preStart() {
    getContext().actorOf(Props.create(Worker.class), &quot;w1&quot;);
    getContext().actorOf(Props.create(Worker.class), &quot;w2&quot;);
    getContext().actorOf(Props.create(Worker.class), &quot;w3&quot;);
  }
  // ...</code></pre></dd>
</dl>
<p>The paths may contain protocol and address information for actors running on remote hosts. Remoting requires the <code>akka-remote</code> module to be included in the classpath.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L229-L237" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/remoteGroup {
    router = round-robin-group
    routees.paths = [
      &quot;akka.tcp://app@10.0.0.1:2552/user/workers/w1&quot;,
      &quot;akka.tcp://app@10.0.0.2:2552/user/workers/w1&quot;,
      &quot;akka.tcp://app@10.0.0.3:2552/user/workers/w1&quot;]
  }
}</code></pre>
<h2><a href="#router-usage" name="router-usage" class="anchor"><span class="anchor-link"></span></a>Router usage</h2>
<p>In this section we will describe how to create the different types of router actors.</p>
<p>The router actors in this section are created from within a top level actor named <code>parent</code>. Note that deployment paths in the configuration starts with <code>/parent/</code> followed by the name of the router actor. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L543" target="_blank" title="Go to snippet source"></a><code class="language-scala">system.actorOf(Props[Parent], &quot;parent&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L366" target="_blank" title="Go to snippet source"></a><code class="language-java">system.actorOf(Props.create(Parent.class), &quot;parent&quot;);</code></pre></dd>
</dl>
<a id="round-robin-router"></a>
<h3><a href="#roundrobinpool-and-roundrobingroup" name="roundrobinpool-and-roundrobingroup" class="anchor"><span class="anchor-link"></span></a>RoundRobinPool and RoundRobinGroup</h3>
<p>Routes in a <a href="http://en.wikipedia.org/wiki/Round-robin">round-robin</a> fashion to its routees.</p>
<p>RoundRobinPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L33-L38" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router1 {
    router = round-robin-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L347-L348" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router1: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router1&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L183-L184" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router1 =
    getContext().actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router1&quot;);</code></pre></dd>
</dl>
<p>RoundRobinPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L352-L353" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router2: ActorRef =
  context.actorOf(RoundRobinPool(5).props(Props[Worker]), &quot;router2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L188-L189" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router2 =
    getContext().actorOf(new RoundRobinPool(5).props(Props.create(Worker.class)), &quot;router2&quot;);</code></pre></dd>
</dl>
<p>RoundRobinGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L42-L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router3 {
    router = round-robin-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L357-L358" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router3: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router3&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L193" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router3 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router3&quot;);</code></pre></dd>
</dl>
<p>RoundRobinGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router4: ActorRef =
  context.actorOf(RoundRobinGroup(paths).props(), &quot;router4&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
ActorRef router4 = getContext().actorOf(new RoundRobinGroup(paths).props(), &quot;router4&quot;);</code></pre></dd>
</dl>
<h3><a href="#randompool-and-randomgroup" name="randompool-and-randomgroup" class="anchor"><span class="anchor-link"></span></a>RandomPool and RandomGroup</h3>
<p>This router type selects one of its routees randomly for each message.</p>
<p>RandomPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L51-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router5 {
    router = random-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L367-L368" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router5: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router5&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L201-L202" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router5 =
    getContext().actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router5&quot;);</code></pre></dd>
</dl>
<p>RandomPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L372-L373" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router6: ActorRef =
  context.actorOf(RandomPool(5).props(Props[Worker]), &quot;router6&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L206-L207" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router6 =
    getContext().actorOf(new RandomPool(5).props(Props.create(Worker.class)), &quot;router6&quot;);</code></pre></dd>
</dl>
<p>RandomGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L60-L65" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router7 {
    router = random-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L377-L378" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router7: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router7&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L211" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router7 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router7&quot;);</code></pre></dd>
</dl>
<p>RandomGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router8: ActorRef =
  context.actorOf(RandomGroup(paths).props(), &quot;router8&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
ActorRef router8 = getContext().actorOf(new RandomGroup(paths).props(), &quot;router8&quot;);</code></pre></dd>
</dl>
<a id="balancing-pool"></a>
<h3><a href="#balancingpool" name="balancingpool" class="anchor"><span class="anchor-link"></span></a>BalancingPool</h3>
<p>A Router that will try to redistribute work from busy routees to idle routees. All routees share the same mailbox.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The BalancingPool has the property that its routees do not have truly distinct identity: they have different names, but talking to them will not end up at the right actor in most cases. Therefore you cannot use it for workflows that require state to be kept within the routee, you would in this case have to include the whole state in the messages.</p>
<p>With a <a href="#smallestmailboxpool">SmallestMailboxPool</a> you can have a vertically scaling service that can interact in a stateful fashion with other services in the back-end before replying to the original client. The other advantage is that it does not place a restriction on the message queue implementation as BalancingPool does.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>Do not use <a href="#broadcast-messages">Broadcast Messages</a> when you use <a href="#balancing-pool">BalancingPool</a> for routers, as described in <a href="#router-special-messages">Specially Handled Messages</a>.</p></div>
<p>BalancingPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L69-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router9 {
    router = balancing-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L387-L388" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router9: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router9&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L219-L220" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router9 =
    getContext().actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router9&quot;);</code></pre></dd>
</dl>
<p>BalancingPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L392-L393" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router10: ActorRef =
  context.actorOf(BalancingPool(5).props(Props[Worker]), &quot;router10&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L224-L225" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router10 =
    getContext().actorOf(new BalancingPool(5).props(Props.create(Worker.class)), &quot;router10&quot;);</code></pre></dd>
</dl>
<p>Addition configuration for the balancing dispatcher, which is used by the pool, can be configured in the <code>pool-dispatcher</code> section of the router deployment configuration.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L78-L86" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router9b {
    router = balancing-pool
    nr-of-instances = 5
    pool-dispatcher {
      attempt-teamwork = off
    }
  }
}</code></pre>
<p>The <code>BalancingPool</code> automatically uses a special <code>BalancingDispatcher</code> for its routees - disregarding any dispatcher that is set on the routee Props object. This is needed in order to implement the balancing semantics via sharing the same mailbox by all the routees.</p>
<p>While it is not possible to change the dispatcher used by the routees, it is possible to fine tune the used <em>executor</em>. By default the <code>fork-join-dispatcher</code> is used and can be configured as explained in <a href="dispatchers.html">Dispatchers</a>. In situations where the routees are expected to perform blocking operations it may be useful to replace it with a <code>thread-pool-executor</code> hinting the number of allocated threads explicitly:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L90-L104" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router10b {
    router = balancing-pool
    nr-of-instances = 5
    pool-dispatcher {
      executor = &quot;thread-pool-executor&quot;

      # allocate exactly 5 threads for this pool
      thread-pool-executor {
        core-pool-size-min = 5
        core-pool-size-max = 5
      }
    }
  }
}</code></pre>
<p>It is also possible to change the <code>mailbox</code> used by the balancing dispatcher for scenarios where the default unbounded mailbox is not well suited. An example of such a scenario could arise whether there exists the need to manage priority for each message. You can then implement a priority mailbox and configure your dispatcher:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L108-L116" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router10c {
    router = balancing-pool
    nr-of-instances = 5
    pool-dispatcher {
      mailbox = myapp.myprioritymailbox
    }
  }
}</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>Bear in mind that <code>BalancingDispatcher</code> requires a message queue that must be thread-safe for multiple concurrent consumers. So it is mandatory for the message queue backing a custom mailbox for this kind of dispatcher to implement akka.dispatch.MultipleConsumerSemantics. See details on how to implement your custom mailbox in <a href="mailboxes.html">Mailboxes</a>.</p></div>
<p>There is no Group variant of the BalancingPool.</p>
<h3><a href="#smallestmailboxpool" name="smallestmailboxpool" class="anchor"><span class="anchor-link"></span></a>SmallestMailboxPool</h3>
<p>A Router that tries to send to the non-suspended child routee with fewest messages in mailbox. The selection is done in this order:</p>
<ul>
  <li>pick any idle routee (not processing message) with empty mailbox</li>
  <li>pick any routee with empty mailbox</li>
  <li>pick routee with fewest pending messages in mailbox</li>
  <li>pick any remote routee, remote actors are consider lowest priority, since their mailbox size is unknown</li>
</ul>
<p>SmallestMailboxPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L120-L125" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router11 {
    router = smallest-mailbox-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L406-L407" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router11: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router11&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L229-L231" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router11 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router11&quot;);</code></pre></dd>
</dl>
<p>SmallestMailboxPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L411-L412" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router12: ActorRef =
  context.actorOf(SmallestMailboxPool(5).props(Props[Worker]), &quot;router12&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L235-L237" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router12 =
    getContext()
        .actorOf(new SmallestMailboxPool(5).props(Props.create(Worker.class)), &quot;router12&quot;);</code></pre></dd>
</dl>
<p>There is no Group variant of the SmallestMailboxPool because the size of the mailbox and the internal dispatching state of the actor is not practically available from the paths of the routees.</p>
<h3><a href="#broadcastpool-and-broadcastgroup" name="broadcastpool-and-broadcastgroup" class="anchor"><span class="anchor-link"></span></a>BroadcastPool and BroadcastGroup</h3>
<p>A broadcast router forwards the message it receives to <em>all</em> its routees.</p>
<p>BroadcastPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L129-L134" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router13 {
    router = broadcast-pool
    nr-of-instances = 5
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L416-L417" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router13: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router13&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L241-L243" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router13 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router13&quot;);</code></pre></dd>
</dl>
<p>BroadcastPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L421-L422" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router14: ActorRef =
  context.actorOf(BroadcastPool(5).props(Props[Worker]), &quot;router14&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L247-L248" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router14 =
    getContext().actorOf(new BroadcastPool(5).props(Props.create(Worker.class)), &quot;router14&quot;);</code></pre></dd>
</dl>
<p>BroadcastGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L138-L143" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router15 {
    router = broadcast-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L426-L427" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router15: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router15&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L252" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router15 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router15&quot;);</code></pre></dd>
</dl>
<p>BroadcastGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router16: ActorRef =
  context.actorOf(BroadcastGroup(paths).props(), &quot;router16&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
ActorRef router16 = getContext().actorOf(new BroadcastGroup(paths).props(), &quot;router16&quot;);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>Broadcast routers always broadcast <em>every</em> message to their routees. If you do not want to broadcast every message, then you can use a non-broadcasting router and use <a href="#broadcast-messages">Broadcast Messages</a> as needed.</p></div>
<h3><a href="#scattergatherfirstcompletedpool-and-scattergatherfirstcompletedgroup" name="scattergatherfirstcompletedpool-and-scattergatherfirstcompletedgroup" class="anchor"><span class="anchor-link"></span></a>ScatterGatherFirstCompletedPool and ScatterGatherFirstCompletedGroup</h3>
<p>The ScatterGatherFirstCompletedRouter will send the message on to all its routees. It then waits for first reply it gets back. This result will be sent back to original sender. Other replies are discarded.</p>
<p>It is expecting at least one reply within a configured duration, otherwise it will reply with <code>akka.pattern.AskTimeoutException</code> in a <code>akka.actor.Status.Failure</code>.</p>
<p>ScatterGatherFirstCompletedPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L147-L153" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router17 {
    router = scatter-gather-pool
    nr-of-instances = 5
    within = 10 seconds
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L436-L437" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router17: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router17&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L260-L262" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router17 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router17&quot;);</code></pre></dd>
</dl>
<p>ScatterGatherFirstCompletedPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L441-L443" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router18: ActorRef =
  context.actorOf(ScatterGatherFirstCompletedPool(5, within = 10.seconds).
    props(Props[Worker]), &quot;router18&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L266-L271" target="_blank" title="Go to snippet source"></a><code class="language-java">Duration within = Duration.ofSeconds(10);
ActorRef router18 =
    getContext()
        .actorOf(
            new ScatterGatherFirstCompletedPool(5, within).props(Props.create(Worker.class)),
            &quot;router18&quot;);</code></pre></dd>
</dl>
<p>ScatterGatherFirstCompletedGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L157-L163" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router19 {
    router = scatter-gather-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
    within = 10 seconds
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L447-L448" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router19: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router19&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L275" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router19 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router19&quot;);</code></pre></dd>
</dl>
<p>ScatterGatherFirstCompletedGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router20: ActorRef =
  context.actorOf(ScatterGatherFirstCompletedGroup(
    paths,
    within = 10.seconds).props(), &quot;router20&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
Duration within2 = Duration.ofSeconds(10);
ActorRef router20 =
    getContext()
        .actorOf(new ScatterGatherFirstCompletedGroup(paths, within2).props(), &quot;router20&quot;);</code></pre></dd>
</dl>
<h3><a href="#tailchoppingpool-and-tailchoppinggroup" name="tailchoppingpool-and-tailchoppinggroup" class="anchor"><span class="anchor-link"></span></a>TailChoppingPool and TailChoppingGroup</h3>
<p>The TailChoppingRouter will first send the message to one, randomly picked, routee and then after a small delay to a second routee (picked randomly from the remaining routees) and so on. It waits for first reply it gets back and forwards it back to original sender. Other replies are discarded.</p>
<p>The goal of this router is to decrease latency by performing redundant queries to multiple routees, assuming that one of the other actors may still be faster to respond than the initial one.</p>
<p>This optimisation was described nicely in a blog post by Peter Bailis: <a href="http://www.bailis.org/blog/doing-redundant-work-to-speed-up-distributed-queries/">Doing redundant work to speed up distributed queries</a>.</p>
<p>TailChoppingPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L167-L174" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router21 {
    router = tail-chopping-pool
    nr-of-instances = 5
    within = 10 seconds
    tail-chopping-router.interval = 20 milliseconds
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L459-L460" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router21: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router21&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L286-L288" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router21 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router21&quot;);</code></pre></dd>
</dl>
<p>TailChoppingPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L464-L466" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router22: ActorRef =
  context.actorOf(TailChoppingPool(5, within = 10.seconds, interval = 20.millis).
    props(Props[Worker]), &quot;router22&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L292-L298" target="_blank" title="Go to snippet source"></a><code class="language-java">Duration within3 = Duration.ofSeconds(10);
Duration interval = Duration.ofMillis(20);
ActorRef router22 =
    getContext()
        .actorOf(
            new TailChoppingPool(5, within3, interval).props(Props.create(Worker.class)),
            &quot;router22&quot;);</code></pre></dd>
</dl>
<p>TailChoppingGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L178-L185" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router23 {
    router = tail-chopping-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
    within = 10 seconds
    tail-chopping-router.interval = 20 milliseconds
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L470-L471" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router23: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router23&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L302" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router23 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router23&quot;);</code></pre></dd>
</dl>
<p>TailChoppingGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router24: ActorRef =
  context.actorOf(TailChoppingGroup(
    paths,
    within = 10.seconds, interval = 20.millis).props(), &quot;router24&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
Duration within4 = Duration.ofSeconds(10);
Duration interval2 = Duration.ofMillis(20);
ActorRef router24 =
    getContext().actorOf(new TailChoppingGroup(paths, within4, interval2).props(), &quot;router24&quot;);</code></pre></dd>
</dl>
<h3><a href="#consistenthashingpool-and-consistenthashinggroup" name="consistenthashingpool-and-consistenthashinggroup" class="anchor"><span class="anchor-link"></span></a>ConsistentHashingPool and ConsistentHashingGroup</h3>
<p>The ConsistentHashingPool uses <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a> to select a routee based on the sent message. This <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html">article</a> gives good insight into how consistent hashing is implemented.</p>
<p>There is 3 ways to define what data to use for the consistent hash key.</p>
<ul>
  <li>You can define <span class="group-scala"><code>hashMapping</code></span><span class="group-java"><code>withHashMapper</code></span> of the router to map incoming messages to their consistent hash key. This makes the decision transparent for the sender.</li>
  <li>The messages may implement <code>akka.routing.ConsistentHashingRouter.ConsistentHashable</code>. The key is part of the message and it&rsquo;s convenient to define it together with the message definition.</li>
  <li>The messages can be wrapped in a <code>akka.routing.ConsistentHashingRouter.ConsistentHashableEnvelope</code> to define what data to use for the consistent hash key. The sender knows the key to use.</li>
</ul>
<p>These ways to define the consistent hash key can be use together and at the same time for one router. The <span class="group-scala"><code>hashMapping</code></span><span class="group-java"><code>withHashMapper</code></span> is tried first.</p>
<p>Code example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/ConsistentHashingRouterDocSpec.scala#L15-L34" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
import akka.routing.ConsistentHashingRouter.ConsistentHashable

class Cache extends Actor {
  var cache = Map.empty[String, String]

  def receive = {
    case Entry(key, value) ⇒ cache += (key -&gt; value)
    case Get(key)          ⇒ sender() ! cache.get(key)
    case Evict(key)        ⇒ cache -= key
  }
}

final case class Evict(key: String)

final case class Get(key: String) extends ConsistentHashable {
  override def consistentHashKey: Any = key
}

final case class Entry(key: String, value: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/ConsistentHashingRouterDocTest.java#L43-L114" target="_blank" title="Go to snippet source"></a><code class="language-java">static class Cache extends AbstractActor {
  Map&lt;String, String&gt; cache = new HashMap&lt;String, String&gt;();

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Entry.class,
            entry -&gt; {
              cache.put(entry.key, entry.value);
            })
        .match(
            Get.class,
            get -&gt; {
              Object value = cache.get(get.key);
              getSender().tell(value == null ? NOT_FOUND : value, getSelf());
            })
        .match(
            Evict.class,
            evict -&gt; {
              cache.remove(evict.key);
            })
        .build();
  }
}

static final class Evict implements Serializable {
  private static final long serialVersionUID = 1L;
  public final String key;

  public Evict(String key) {
    this.key = key;
  }
}

static final class Get implements Serializable, ConsistentHashable {
  private static final long serialVersionUID = 1L;
  public final String key;

  public Get(String key) {
    this.key = key;
  }

  public Object consistentHashKey() {
    return key;
  }
}

static final class Entry implements Serializable {
  private static final long serialVersionUID = 1L;
  public final String key;
  public final String value;

  public Entry(String key, String value) {
    this.key = key;
    this.value = value;
  }
}

static final String NOT_FOUND = &quot;NOT_FOUND&quot;;</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/ConsistentHashingRouterDocSpec.scala#L48-L75" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Props
import akka.routing.ConsistentHashingPool
import akka.routing.ConsistentHashingRouter.ConsistentHashMapping
import akka.routing.ConsistentHashingRouter.ConsistentHashableEnvelope

def hashMapping: ConsistentHashMapping = {
  case Evict(key) ⇒ key
}

val cache: ActorRef =
  context.actorOf(ConsistentHashingPool(10, hashMapping = hashMapping).
    props(Props[Cache]), name = &quot;cache&quot;)

cache ! ConsistentHashableEnvelope(
  message = Entry(&quot;hello&quot;, &quot;HELLO&quot;), hashKey = &quot;hello&quot;)
cache ! ConsistentHashableEnvelope(
  message = Entry(&quot;hi&quot;, &quot;HI&quot;), hashKey = &quot;hi&quot;)

cache ! Get(&quot;hello&quot;)
expectMsg(Some(&quot;HELLO&quot;))

cache ! Get(&quot;hi&quot;)
expectMsg(Some(&quot;HI&quot;))

cache ! Evict(&quot;hi&quot;)
cache ! Get(&quot;hi&quot;)
expectMsg(None)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/ConsistentHashingRouterDocTest.java#L124-L156" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>final ConsistentHashMapper hashMapper =
    new ConsistentHashMapper() {
      @Override
      public Object hashKey(Object message) {
        if (message instanceof Evict) {
          return ((Evict) message).key;
        } else {
          return null;
        }
      }
    };

ActorRef cache =
    system.actorOf(
        new ConsistentHashingPool(10)
            .withHashMapper(hashMapper)
            .props(Props.create(Cache.class)),
        &quot;cache&quot;);

cache.tell(new ConsistentHashableEnvelope(new Entry(&quot;hello&quot;, &quot;HELLO&quot;), &quot;hello&quot;), getRef());
cache.tell(new ConsistentHashableEnvelope(new Entry(&quot;hi&quot;, &quot;HI&quot;), &quot;hi&quot;), getRef());

cache.tell(new Get(&quot;hello&quot;), getRef());
expectMsgEquals(&quot;HELLO&quot;);

cache.tell(new Get(&quot;hi&quot;), getRef());
expectMsgEquals(&quot;HI&quot;);

cache.tell(new Evict(&quot;hi&quot;), getRef());
cache.tell(new Get(&quot;hi&quot;), getRef());
expectMsgEquals(NOT_FOUND);
</code></pre></dd>
</dl>
<p>In the above example you see that the <code>Get</code> message implements <code>ConsistentHashable</code> itself, while the <code>Entry</code> message is wrapped in a <code>ConsistentHashableEnvelope</code>. The <code>Evict</code> message is handled by the <code>hashMapping</code> partial function.</p>
<p>ConsistentHashingPool defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L189-L195" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router25 {
    router = consistent-hashing-pool
    nr-of-instances = 5
    virtual-nodes-factor = 10
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L482-L483" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router25: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router25&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L313-L315" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router25 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router25&quot;);</code></pre></dd>
</dl>
<p>ConsistentHashingPool defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L487-L490" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router26: ActorRef =
  context.actorOf(
    ConsistentHashingPool(5).props(Props[Worker]),
    &quot;router26&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L319-L321" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router26 =
    getContext()
        .actorOf(new ConsistentHashingPool(5).props(Props.create(Worker.class)), &quot;router26&quot;);</code></pre></dd>
</dl>
<p>ConsistentHashingGroup defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L199-L205" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router27 {
    router = consistent-hashing-group
    routees.paths = [&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;]
    virtual-nodes-factor = 10
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L494-L495" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router27: ActorRef =
  context.actorOf(FromConfig.props(), &quot;router27&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L325" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router27 = getContext().actorOf(FromConfig.getInstance().props(), &quot;router27&quot;);</code></pre></dd>
</dl>
<p>ConsistentHashingGroup defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L343" target="_blank" title="Go to snippet source"></a><code class="language-scala">val paths = List(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;)
val router28: ActorRef =
  context.actorOf(ConsistentHashingGroup(paths).props(), &quot;router28&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L179" target="_blank" title="Go to snippet source"></a><code class="language-java">List&lt;String&gt; paths = Arrays.asList(&quot;/user/workers/w1&quot;, &quot;/user/workers/w2&quot;, &quot;/user/workers/w3&quot;);
ActorRef router28 = getContext().actorOf(new ConsistentHashingGroup(paths).props(), &quot;router28&quot;);</code></pre></dd>
</dl>
<p><code>virtual-nodes-factor</code> is the number of virtual nodes per routee that is used in the consistent hash node ring to make the distribution more uniform.</p>
<a id="router-special-messages"></a>
<h2><a href="#specially-handled-messages" name="specially-handled-messages" class="anchor"><span class="anchor-link"></span></a>Specially Handled Messages</h2>
<p>Most messages sent to router actors will be forwarded according to the routers&rsquo; routing logic. However there are a few types of messages that have special behavior.</p>
<p>Note that these special messages, except for the <code>Broadcast</code> message, are only handled by self contained router actors and not by the <code>akka.routing.Router</code> component described in <a href="#simple-router">A Simple Router</a>.</p>
<a id="broadcast-messages"></a>
<h3><a href="#broadcast-messages" name="broadcast-messages" class="anchor"><span class="anchor-link"></span></a>Broadcast Messages</h3>
<p>A <code>Broadcast</code> message can be used to send a message to <em>all</em> of a router&rsquo;s routees. When a router receives a <code>Broadcast</code> message, it will broadcast that message&rsquo;s <em>payload</em> to all routees, no matter how that router would normally route its messages.</p>
<p>The example below shows how you would use a <code>Broadcast</code> message to send a very important message to every routee of a router.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L559-L560" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.routing.Broadcast
router ! Broadcast(&quot;Watch out for Davy Jones&#39; locker&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L387" target="_blank" title="Go to snippet source"></a><code class="language-java">router.tell(new Broadcast(&quot;Watch out for Davy Jones&#39; locker&quot;), getTestActor());</code></pre></dd>
</dl>
<p>In this example the router receives the <code>Broadcast</code> message, extracts its payload (<code>&quot;Watch out for Davy Jones&#39; locker&quot;</code>), and then sends the payload on to all of the router&rsquo;s routees. It is up to each routee actor to handle the received payload message.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Do not use <a href="#broadcast-messages">Broadcast Messages</a> when you use <a href="#balancing-pool">BalancingPool</a> for routers. Routees on <a href="#balancing-pool">BalancingPool</a> shares the same mailbox instance, thus some routees can possibly get the broadcast message multiple times, while other routees get no broadcast message.</p></div>
<h3><a href="#poisonpill-messages" name="poisonpill-messages" class="anchor"><span class="anchor-link"></span></a>PoisonPill Messages</h3>
<p>A <code>PoisonPill</code> message has special handling for all actors, including for routers. When any actor receives a <code>PoisonPill</code> message, that actor will be stopped. See the <a href="actors.html#poison-pill">PoisonPill</a> documentation for details.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L568-L569" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.PoisonPill
router ! PoisonPill</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L401" target="_blank" title="Go to snippet source"></a><code class="language-java">router.tell(PoisonPill.getInstance(), getTestActor());</code></pre></dd>
</dl>
<p>For a router, which normally passes on messages to routees, it is important to realise that <code>PoisonPill</code> messages are processed by the router only. <code>PoisonPill</code> messages sent to a router will <em>not</em> be sent on to routees.</p>
<p>However, a <code>PoisonPill</code> message sent to a router may still affect its routees, because it will stop the router and when the router stops it also stops its children. Stopping children is normal actor behavior. The router will stop routees that it has created as children. Each child will process its current message and then stop. This may lead to some messages being unprocessed. See the documentation on <a href="actors.html#stopping-actors">Stopping actors</a> for more information.</p>
<p>If you wish to stop a router and its routees, but you would like the routees to first process all the messages currently in their mailboxes, then you should not send a <code>PoisonPill</code> message to the router. Instead you should wrap a <code>PoisonPill</code> message inside a <code>Broadcast</code> message so that each routee will receive the <code>PoisonPill</code> message. Note that this will stop all routees, even if the routees aren&rsquo;t children of the router, i.e. even routees programmatically provided to the router.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L577-L579" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.PoisonPill
import akka.routing.Broadcast
router ! Broadcast(PoisonPill)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L415" target="_blank" title="Go to snippet source"></a><code class="language-java">router.tell(new Broadcast(PoisonPill.getInstance()), getTestActor());</code></pre></dd>
</dl>
<p>With the code shown above, each routee will receive a <code>PoisonPill</code> message. Each routee will continue to process its messages as normal, eventually processing the <code>PoisonPill</code>. This will cause the routee to stop. After all routees have stopped the router will itself be stopped automatically unless it is a dynamic router, e.g. using a resizer.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Brendan W McAdams&rsquo; excellent blog post <a href="http://bytes.codes/2013/01/17/Distributing_Akka_Workloads_And_Shutting_Down_After/">Distributing Akka Workloads - And Shutting Down Afterwards</a> discusses in more detail how <code>PoisonPill</code> messages can be used to shut down routers and routees.</p></div>
<h3><a href="#kill-messages" name="kill-messages" class="anchor"><span class="anchor-link"></span></a>Kill Messages</h3>
<p><code>Kill</code> messages are another type of message that has special handling. See <a href="actors.html#killing-actors">Killing an Actor</a> for general information about how actors handle <code>Kill</code> messages.</p>
<p>When a <code>Kill</code> message is sent to a router the router processes the message internally, and does <em>not</em> send it on to its routees. The router will throw an <code>ActorKilledException</code> and fail. It will then be either resumed, restarted or terminated, depending how it is supervised.</p>
<p>Routees that are children of the router will also be suspended, and will be affected by the supervision directive that is applied to the router. Routees that are not the routers children, i.e. those that were created externally to the router, will not be affected.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L587-L588" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Kill
router ! Kill</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L429" target="_blank" title="Go to snippet source"></a><code class="language-java">router.tell(Kill.getInstance(), getTestActor());</code></pre></dd>
</dl>
<p>As with the <code>PoisonPill</code> message, there is a distinction between killing a router, which indirectly kills its children (who happen to be routees), and killing routees directly (some of whom may not be children.) To kill routees directly the router should be sent a <code>Kill</code> message wrapped in a <code>Broadcast</code> message.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L596-L598" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Kill
import akka.routing.Broadcast
router ! Broadcast(Kill)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L443" target="_blank" title="Go to snippet source"></a><code class="language-java">router.tell(new Broadcast(Kill.getInstance()), getTestActor());</code></pre></dd>
</dl>
<h3><a href="#management-messages" name="management-messages" class="anchor"><span class="anchor-link"></span></a>Management Messages</h3>
<ul>
  <li>Sending <code>akka.routing.GetRoutees</code> to a router actor will make it send back its currently used routees in a <code>akka.routing.Routees</code> message.</li>
  <li>Sending <code>akka.routing.AddRoutee</code> to a router actor will add that routee to its collection of routees.</li>
  <li>Sending <code>akka.routing.RemoveRoutee</code> to a router actor will remove that routee to its collection of routees.</li>
  <li>Sending <code>akka.routing.AdjustPoolSize</code> to a pool router actor will add or remove that number of routees to its collection of routees.</li>
</ul>
<p>These management messages may be handled after other messages, so if you send <code>AddRoutee</code> immediately followed by an ordinary message you are not guaranteed that the routees have been changed when the ordinary message is routed. If you need to know when the change has been applied you can send <code>AddRoutee</code> followed by <code>GetRoutees</code> and when you receive the <code>Routees</code> reply you know that the preceding change has been applied.</p>
<a id="resizable-routers"></a>
<h2><a href="#dynamically-resizable-pool" name="dynamically-resizable-pool" class="anchor"><span class="anchor-link"></span></a>Dynamically Resizable Pool</h2>
<p><span class="group-scala">Most</span><span class="group-java">All</span> pools can be used with a fixed number of routees or with a resize strategy to adjust the number of routees dynamically.</p>
<p>There are two types of resizers: the default <code>Resizer</code> and the <code>OptimalSizeExploringResizer</code>.</p>
<h3><a href="#default-resizer" name="default-resizer" class="anchor"><span class="anchor-link"></span></a>Default Resizer</h3>
<p>The default resizer ramps up and down pool size based on pressure, measured by the percentage of busy routees in the pool. It ramps up pool size if the pressure is higher than a certain threshold and backs off if the pressure is lower than certain threshold. Both thresholds are configurable.</p>
<p>Pool with default resizer defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L253-L262" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router29 {
    router = round-robin-pool
    resizer {
      lower-bound = 2
      upper-bound = 15
      messages-per-resize = 100
    }
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L504-L505" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router29: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router29&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L333-L335" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router29 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router29&quot;);</code></pre></dd>
</dl>
<p>Several more configuration options are available and described in <code>akka.actor.deployment.default.resizer</code> section of the reference <a href="general/configuration.html">configuration</a>.</p>
<p>Pool with resizer defined in code:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L509-L513" target="_blank" title="Go to snippet source"></a><code class="language-scala">val resizer = DefaultResizer(lowerBound = 2, upperBound = 15)
val router30: ActorRef =
  context.actorOf(
    RoundRobinPool(5, Some(resizer)).props(Props[Worker]),
    &quot;router30&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L339-L344" target="_blank" title="Go to snippet source"></a><code class="language-java">DefaultResizer resizer = new DefaultResizer(2, 15);
ActorRef router30 =
    getContext()
        .actorOf(
            new RoundRobinPool(5).withResizer(resizer).props(Props.create(Worker.class)),
            &quot;router30&quot;);</code></pre></dd>
</dl>
<p><em>It is also worth pointing out that if you define the <code>router</code> in the configuration file then this value will be used instead of any programmatically sent parameters.</em></p>
<h3><a href="#optimal-size-exploring-resizer" name="optimal-size-exploring-resizer" class="anchor"><span class="anchor-link"></span></a>Optimal Size Exploring Resizer</h3>
<p>The <code>OptimalSizeExploringResizer</code> resizes the pool to an optimal size that provides the most message throughput.</p>
<p>This resizer works best when you expect the pool size to performance function to be a convex function. For example, when you have a CPU bound tasks, the optimal size is bound to the number of CPU cores. When your task is IO bound, the optimal size is bound to optimal number of concurrent connections to that IO service - e.g. a 4 node elastic search cluster may handle 4-8 concurrent requests at optimal speed.</p>
<p>It achieves this by keeping track of message throughput at each pool size and performing the following three resizing operations (one at a time) periodically:</p>
<ul>
  <li>Downsize if it hasn&rsquo;t seen all routees ever fully utilized for a period of time.</li>
  <li>Explore to a random nearby pool size to try and collect throughput metrics.</li>
  <li>Optimize to a nearby pool size with a better (than any other nearby sizes) throughput metrics.</li>
</ul>
<p>When the pool is fully-utilized (i.e. all routees are busy), it randomly choose between exploring and optimizing. When the pool has not been fully-utilized for a period of time, it will downsize the pool to the last seen max utilization multiplied by a configurable ratio.</p>
<p>By constantly exploring and optimizing, the resizer will eventually walk to the optimal size and remain nearby. When the optimal size changes it will start walking towards the new one.</p>
<p>It keeps a performance log so it&rsquo;s stateful as well as having a larger memory footprint than the default <code>Resizer</code>. The memory usage is O(n) where n is the number of sizes you allow, i.e. upperBound - lowerBound.</p>
<p>Pool with <code>OptimalSizeExploringResizer</code> defined in configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L266-L275" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /parent/router31 {
    router = round-robin-pool
    optimal-size-exploring-resizer {
      enabled = on
      action-interval = 5s
      downsize-after-underutilized-for = 72h
    }
  }
}</code></pre>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L517-L518" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router31: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), &quot;router31&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L348-L350" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef router31 =
    getContext()
        .actorOf(FromConfig.getInstance().props(Props.create(Worker.class)), &quot;router31&quot;);</code></pre></dd>
</dl>
<p>Several more configuration options are available and described in <code>akka.actor.deployment.default.optimal-size-exploring-resizer</code> section of the reference <a href="general/configuration.html">configuration</a>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Resizing is triggered by sending messages to the actor pool, but it is not completed synchronously; instead a message is sent to the “head” <code>RouterActor</code> to perform the size change. Thus you cannot rely on resizing to instantaneously create new workers when all others are busy, because the message just sent will be queued to the mailbox of a busy actor. To remedy this, configure the pool to use a balancing dispatcher, see <a href="#configuring-dispatchers">Configuring Dispatchers</a> for more information.</p></div>
<a id="router-design"></a>
<h2><a href="#how-routing-is-designed-within-akka" name="how-routing-is-designed-within-akka" class="anchor"><span class="anchor-link"></span></a>How Routing is Designed within Akka</h2>
<p>On the surface routers look like normal actors, but they are actually implemented differently. Routers are designed to be extremely efficient at receiving messages and passing them quickly on to routees.</p>
<p>A normal actor can be used for routing messages, but an actor&rsquo;s single-threaded processing can become a bottleneck. Routers can achieve much higher throughput with an optimization to the usual message-processing pipeline that allows concurrent routing. This is achieved by embedding routers&rsquo; routing logic directly in their <code>ActorRef</code> rather than in the router actor. Messages sent to a router&rsquo;s <code>ActorRef</code> can be immediately routed to the routee, bypassing the single-threaded router actor entirely.</p>
<p>The cost to this is that the internals of routing code are more complicated than if routers were implemented with normal actors. Fortunately all of this complexity is invisible to consumers of the routing API. However, it is something to be aware of when implementing your own routers.</p>
<a id="custom-router"></a>
<h2><a href="#custom-router" name="custom-router" class="anchor"><span class="anchor-link"></span></a>Custom Router</h2>
<p>You can create your own router should you not find any of the ones provided by Akka sufficient for your needs. In order to roll your own router you have to fulfill certain criteria which are explained in this section.</p>
<p>Before creating your own router you should consider whether a normal actor with router-like behavior might do the job just as well as a full-blown router. As explained <a href="#router-design">above</a>, the primary benefit of routers over normal actors is their higher performance. But they are somewhat more complicated to write than normal actors. Therefore if lower maximum throughput is acceptable in your application you may wish to stick with traditional actors. This section, however, assumes that you wish to get maximum performance and so demonstrates how you can create your own router.</p>
<p>The router created in this example is replicating each message to a few destinations.</p>
<p>Start with the routing logic:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L44-L57" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.collection.immutable
import java.util.concurrent.ThreadLocalRandom
import akka.routing.RoundRobinRoutingLogic
import akka.routing.RoutingLogic
import akka.routing.Routee
import akka.routing.SeveralRoutees

class RedundancyRoutingLogic(nbrCopies: Int) extends RoutingLogic {
  val roundRobin = RoundRobinRoutingLogic()
  def select(message: Any, routees: immutable.IndexedSeq[Routee]): Routee = {
    val targets = (1 to nbrCopies).map(_ ⇒ roundRobin.select(message, routees))
    SeveralRoutees(targets)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/CustomRouterDocTest.java#L49-L66" target="_blank" title="Go to snippet source"></a><code class="language-java">static class RedundancyRoutingLogic implements RoutingLogic {
  private final int nbrCopies;

  public RedundancyRoutingLogic(int nbrCopies) {
    this.nbrCopies = nbrCopies;
  }

  RoundRobinRoutingLogic roundRobin = new RoundRobinRoutingLogic();

  @Override
  public Routee select(Object message, IndexedSeq&lt;Routee&gt; routees) {
    List&lt;Routee&gt; targets = new ArrayList&lt;Routee&gt;();
    for (int i = 0; i &lt; nbrCopies; i++) {
      targets.add(roundRobin.select(message, routees));
    }
    return new SeveralRoutees(targets);
  }
}</code></pre></dd>
</dl>
<p><code>select</code> will be called for each message and in this example pick a few destinations by round-robin, by reusing the existing <code>RoundRobinRoutingLogic</code> and wrap the result in a <code>SeveralRoutees</code> instance. <code>SeveralRoutees</code> will send the message to all of the supplied routes.</p>
<p>The implementation of the routing logic must be thread safe, since it might be used outside of actors.</p>
<p>A unit test of the routing logic: </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L67-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class TestRoutee(n: Int) extends Routee {
  override def send(message: Any, sender: ActorRef): Unit = ()
}

  val logic = new RedundancyRoutingLogic(nbrCopies = 3)

  val routees = for (n ← 1 to 7) yield TestRoutee(n)

  val r1 = logic.select(&quot;msg&quot;, routees)
  r1.asInstanceOf[SeveralRoutees].routees should be(
    Vector(TestRoutee(1), TestRoutee(2), TestRoutee(3)))

  val r2 = logic.select(&quot;msg&quot;, routees)
  r2.asInstanceOf[SeveralRoutees].routees should be(
    Vector(TestRoutee(4), TestRoutee(5), TestRoutee(6)))

  val r3 = logic.select(&quot;msg&quot;, routees)
  r3.asInstanceOf[SeveralRoutees].routees should be(
    Vector(TestRoutee(7), TestRoutee(1), TestRoutee(2)))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/CustomRouterDocTest.java#L71-L131" target="_blank" title="Go to snippet source"></a><code class="language-java">static final class TestRoutee implements Routee {
  public final int n;

  public TestRoutee(int n) {
    this.n = n;
  }

  @Override
  public void send(Object message, ActorRef sender) {}

  @Override
  public int hashCode() {
    return n;
  }

  @Override
  public boolean equals(Object obj) {
    return (obj instanceof TestRoutee) &amp;&amp; n == ((TestRoutee) obj).n;
  }
}

  RedundancyRoutingLogic logic = new RedundancyRoutingLogic(3);

  List&lt;Routee&gt; routeeList = new ArrayList&lt;Routee&gt;();
  for (int n = 1; n &lt;= 7; n++) {
    routeeList.add(new TestRoutee(n));
  }
  IndexedSeq&lt;Routee&gt; routees = immutableIndexedSeq(routeeList);

  SeveralRoutees r1 = (SeveralRoutees) logic.select(&quot;msg&quot;, routees);
  assertEquals(r1.getRoutees().get(0), routeeList.get(0));
  assertEquals(r1.getRoutees().get(1), routeeList.get(1));
  assertEquals(r1.getRoutees().get(2), routeeList.get(2));

  SeveralRoutees r2 = (SeveralRoutees) logic.select(&quot;msg&quot;, routees);
  assertEquals(r2.getRoutees().get(0), routeeList.get(3));
  assertEquals(r2.getRoutees().get(1), routeeList.get(4));
  assertEquals(r2.getRoutees().get(2), routeeList.get(5));

  SeveralRoutees r3 = (SeveralRoutees) logic.select(&quot;msg&quot;, routees);
  assertEquals(r3.getRoutees().get(0), routeeList.get(6));
  assertEquals(r3.getRoutees().get(1), routeeList.get(0));
  assertEquals(r3.getRoutees().get(2), routeeList.get(1));
</code></pre></dd>
</dl>
<p>You could stop here and use the <code>RedundancyRoutingLogic</code> with a <code>akka.routing.Router</code> as described in <a href="#simple-router">A Simple Router</a>.</p>
<p>Let us continue and make this into a self contained, configurable, router actor.</p>
<p>Create a class that extends <code>Pool</code>, <code>Group</code> or <code>CustomRouterConfig</code>. That class is a factory for the routing logic and holds the configuration for the router. Here we make it a <code>Group</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L75-L93" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.dispatch.Dispatchers
import akka.routing.Group
import akka.routing.Router
import akka.japi.Util.immutableSeq
import com.typesafe.config.Config

final case class RedundancyGroup(routeePaths: immutable.Iterable[String], nbrCopies: Int) extends Group {

  def this(config: Config) = this(
    routeePaths = immutableSeq(config.getStringList(&quot;routees.paths&quot;)),
    nbrCopies = config.getInt(&quot;nbr-copies&quot;))

  override def paths(system: ActorSystem): immutable.Iterable[String] = routeePaths

  override def createRouter(system: ActorSystem): Router =
    new Router(new RedundancyRoutingLogic(nbrCopies))

  override val routerDispatcher: String = Dispatchers.DefaultDispatcherId
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RedundancyGroup.java#L8-L46" target="_blank" title="Go to snippet source"></a><code class="language-java">import java.util.List;

import akka.actor.ActorSystem;
import akka.dispatch.Dispatchers;
import akka.routing.Router;

import com.typesafe.config.Config;

import akka.routing.GroupBase;
import static jdocs.routing.CustomRouterDocTest.RedundancyRoutingLogic;

public class RedundancyGroup extends GroupBase {
  private final List&lt;String&gt; paths;
  private final int nbrCopies;

  public RedundancyGroup(List&lt;String&gt; paths, int nbrCopies) {
    this.paths = paths;
    this.nbrCopies = nbrCopies;
  }

  public RedundancyGroup(Config config) {
    this(config.getStringList(&quot;routees.paths&quot;), config.getInt(&quot;nbr-copies&quot;));
  }

  @Override
  public java.lang.Iterable&lt;String&gt; getPaths(ActorSystem system) {
    return paths;
  }

  @Override
  public Router createRouter(ActorSystem system) {
    return new Router(new RedundancyRoutingLogic(nbrCopies));
  }

  @Override
  public String routerDispatcher() {
    return Dispatchers.DefaultDispatcherId();
  }
}</code></pre></dd>
</dl>
<p>This can be used exactly as the router actors provided by Akka.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L124-L131" target="_blank" title="Go to snippet source"></a><code class="language-scala">for (n ← 1 to 10) system.actorOf(Props[Storage], &quot;s&quot; + n)

val paths = for (n ← 1 to 10) yield (&quot;/user/s&quot; + n)
val redundancy1: ActorRef =
  system.actorOf(
    RedundancyGroup(paths, nbrCopies = 3).props(),
    name = &quot;redundancy1&quot;)
redundancy1 ! &quot;important&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/CustomRouterDocTest.java#L140-L150" target="_blank" title="Go to snippet source"></a><code class="language-java">for (int n = 1; n &lt;= 10; n++) {
  system.actorOf(Props.create(Storage.class), &quot;s&quot; + n);
}

List&lt;String&gt; paths = new ArrayList&lt;String&gt;();
for (int n = 1; n &lt;= 10; n++) {
  paths.add(&quot;/user/s&quot; + n);
}

ActorRef redundancy1 = system.actorOf(new RedundancyGroup(paths, 3).props(), &quot;redundancy1&quot;);
redundancy1.tell(&quot;important&quot;, getTestActor());</code></pre></dd>
</dl>
<p>Note that we added a constructor in <code>RedundancyGroup</code> that takes a <code>Config</code> parameter. That makes it possible to define it in configuration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L21-L27" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /redundancy2 {
    router = &quot;jdocs.routing.RedundancyGroup&quot;
    routees.paths = [&quot;/user/s1&quot;, &quot;/user/s2&quot;, &quot;/user/s3&quot;]
    nbr-copies = 5
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L33-L39" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /redundancy2 {
    router = &quot;jdocs.routing.RedundancyGroup&quot;
    routees.paths = [&quot;/user/s1&quot;, &quot;/user/s2&quot;, &quot;/user/s3&quot;]
    nbr-copies = 5
  }
}</code></pre></dd>
</dl>
<p>Note the fully qualified class name in the <code>router</code> property. The router class must extend <code>akka.routing.RouterConfig</code> (<code>Pool</code>, <code>Group</code> or <code>CustomRouterConfig</code>) and have constructor with one <code>com.typesafe.config.Config</code> parameter. The deployment section of the configuration is passed to the constructor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/CustomRouterDocSpec.scala#L137-L140" target="_blank" title="Go to snippet source"></a><code class="language-scala">val redundancy2: ActorRef = system.actorOf(
  FromConfig.props(),
  name = &quot;redundancy2&quot;)
redundancy2 ! &quot;very important&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/CustomRouterDocTest.java#L158-L159" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef redundancy2 = system.actorOf(FromConfig.getInstance().props(), &quot;redundancy2&quot;);
redundancy2.tell(&quot;very important&quot;, getTestActor());</code></pre></dd>
</dl>
<h2><a href="#configuring-dispatchers" name="configuring-dispatchers" class="anchor"><span class="anchor-link"></span></a>Configuring Dispatchers</h2>
<p>The dispatcher for created children of the pool will be taken from <code>Props</code> as described in <a href="dispatchers.html">Dispatchers</a>.</p>
<p>To make it easy to define the dispatcher of the routees of the pool you can define the dispatcher inline in the deployment section of the config.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L279-L288" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka.actor.deployment {
  /poolWithDispatcher {
    router = random-pool
    nr-of-instances = 5
    pool-dispatcher {
      fork-join-executor.parallelism-min = 5
      fork-join-executor.parallelism-max = 5
    }
  }
}</code></pre>
<p>That is the only thing you need to do enable a dedicated dispatcher for a pool.</p><div class="callout note "><div class="callout-title">Note</div>
<p>If you use a group of actors and route to their paths, then they will still use the same dispatcher that was configured for them in their <code>Props</code>, it is not possible to change an actors dispatcher after it has been created.</p></div>
<p>The “head” router cannot always run on the same dispatcher, because it does not process the same type of messages, hence this special actor does not use the dispatcher configured in <code>Props</code>, but takes the <code>routerDispatcher</code> from the <code>RouterConfig</code> instead, which defaults to the actor system’s default dispatcher. All standard routers allow setting this property in their constructor or factory method, custom routers have to implement the method in a suitable way.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/routing/RouterDocSpec.scala#L548-L552" target="_blank" title="Go to snippet source"></a><code class="language-scala">val router: ActorRef = system.actorOf(
  // “head” router actor will run on &quot;router-dispatcher&quot; dispatcher
  // Worker routees will run on &quot;pool-dispatcher&quot; dispatcher
  RandomPool(5, routerDispatcher = &quot;router-dispatcher&quot;).props(Props[Worker]),
  name = &quot;poolWithDispatcher&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/routing/RouterDocTest.java#L373-L377" target="_blank" title="Go to snippet source"></a><code class="language-java">Props props =
    // “head” router actor will run on &quot;router-dispatcher&quot; dispatcher
    // Worker routees will run on &quot;pool-dispatcher&quot; dispatcher
    new RandomPool(5).withDispatcher(&quot;router-dispatcher&quot;).props(Props.create(Worker.class));
ActorRef router = system.actorOf(props, &quot;poolWithDispatcher&quot;);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>It is not allowed to configure the <code>routerDispatcher</code> to be a <code>akka.dispatch.BalancingDispatcherConfigurator</code> since the messages meant for the special router actor cannot be processed by any other actor.</p></div>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="mailboxes.html"><i class="icon-prev"></i> <span class="link-prev">Mailboxes</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="fsm.html">FSM <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/routing.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
