<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Actors &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/actors.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="actors.html#creating-actors" class="header">Creating Actors</a></li>
      <li><a href="actors.html#actor-api" class="header">Actor API</a></li>
      <li><a href="actors.html#identifying-actors-via-actor-selection" class="header">Identifying Actors via Actor Selection</a></li>
      <li><a href="actors.html#messages-and-immutability" class="header">Messages and immutability</a></li>
      <li><a href="actors.html#send-messages" class="header">Send messages</a></li>
      <li><a href="actors.html#receive-messages" class="header">Receive messages</a></li>
      <li><a href="actors.html#reply-to-messages" class="header">Reply to messages</a></li>
      <li><a href="actors.html#receive-timeout" class="header">Receive timeout</a></li>
      <li><a href="actors.html#timers-scheduled-messages" class="header">Timers, scheduled messages</a></li>
      <li><a href="actors.html#stopping-actors" class="header">Stopping actors</a></li>
      <li><a href="actors.html#become-unbecome" class="header">Become/Unbecome</a></li>
      <li><a href="actors.html#stash" class="header">Stash</a></li>
      <li><a href="actors.html#actors-and-exceptions" class="header">Actors and exceptions</a></li>
      <li><a href="actors.html#extending-actors-using-partialfunction-chaining" class="header group-scala">Extending Actors using PartialFunction chaining</a></li>
      <li><a href="actors.html#initialization-patterns" class="header">Initialization patterns</a></li>
    </ul></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="actors.html#creating-actors" class="header">Creating Actors</a></li>
      <li><a href="actors.html#actor-api" class="header">Actor API</a></li>
      <li><a href="actors.html#identifying-actors-via-actor-selection" class="header">Identifying Actors via Actor Selection</a></li>
      <li><a href="actors.html#messages-and-immutability" class="header">Messages and immutability</a></li>
      <li><a href="actors.html#send-messages" class="header">Send messages</a></li>
      <li><a href="actors.html#receive-messages" class="header">Receive messages</a></li>
      <li><a href="actors.html#reply-to-messages" class="header">Reply to messages</a></li>
      <li><a href="actors.html#receive-timeout" class="header">Receive timeout</a></li>
      <li><a href="actors.html#timers-scheduled-messages" class="header">Timers, scheduled messages</a></li>
      <li><a href="actors.html#stopping-actors" class="header">Stopping actors</a></li>
      <li><a href="actors.html#become-unbecome" class="header">Become/Unbecome</a></li>
      <li><a href="actors.html#stash" class="header">Stash</a></li>
      <li><a href="actors.html#actors-and-exceptions" class="header">Actors and exceptions</a></li>
      <li><a href="actors.html#extending-actors-using-partialfunction-chaining" class="header group-scala">Extending Actors using PartialFunction chaining</a></li>
      <li><a href="actors.html#initialization-patterns" class="header">Initialization patterns</a></li>
    </ul></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#actors" name="actors" class="anchor"><span class="anchor-link"></span></a>Actors</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Actors, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> provides a higher level of abstraction for writing concurrent and distributed systems. It alleviates the developer from having to deal with explicit locking and thread management, making it easier to write correct concurrent and parallel systems. Actors were defined in the 1973 paper by Carl Hewitt but have been popularized by the Erlang language, and used for example at Ericsson with great success to build highly concurrent and reliable telecom systems.</p>
<p>The API of Akka’s Actors is similar to Scala Actors which has borrowed some of its syntax from Erlang.</p>
<h2><a href="#creating-actors" name="creating-actors" class="anchor"><span class="anchor-link"></span></a>Creating Actors</h2><div class="callout note "><div class="callout-title">Note</div>
<p>Since Akka enforces parental supervision every actor is supervised and (potentially) the supervisor of its children, it is advisable that you familiarize yourself with <a href="general/actor-systems.html">Actor Systems</a> and <a href="general/supervision.html">supervision</a> and it may also help to read <a href="general/addressing.html">Actor References, Paths and Addresses</a>.</p></div>
<h3><a href="#defining-an-actor-class" name="defining-an-actor-class" class="anchor"><span class="anchor-link"></span></a>Defining an Actor class</h3><div class="group-scala">
<p>Actors are implemented by extending the <code>Actor</code> base trait and implementing the <code>receive</code> method. The <code>receive</code> method should define a series of case statements (which has the type <code>PartialFunction[Any, Unit]</code>) that defines which messages your Actor can handle, using standard Scala pattern matching, along with the implementation of how the messages should be processed.</p></div><div class="group-java">
<p>Actor classes are implemented by extending the <code>AbstractActor</code> class and setting the “initial behavior” in <code>createReceive</code> method.</p>
<p><code>createReceive</code> method has no arguments and returns <code>AbstractActor.Receive</code>. It defines which messages your Actor can handle, along with the implementation of how the messages should be processed. You can build such behavior with a builder named <code>ReceiveBuilder</code>. This build has convenient factory in <code>AbstractActor</code> called <code>receiveBuilder</code>.</p></div>
<p>Here is an example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L13-L16" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case &quot;test&quot; ⇒ log.info(&quot;received test&quot;)
    case _      ⇒ log.info(&quot;received unknown message&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/MyActor.java#L8-L11" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;

public class MyActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            s -&gt; {
              log.info(&quot;Received String message: {}&quot;, s);
            })
        .matchAny(o -&gt; log.info(&quot;received unknown message&quot;))
        .build();
  }
}</code></pre></dd>
</dl>
<p>Please note that the Akka Actor <span class="group-scala"><code>receive</code></span> message loop is exhaustive, which is different compared to Erlang and the late Scala Actors. This means that you need to provide a pattern match for all messages that it can accept and if you want to be able to handle unknown messages then you need to have a default case as in the example above. Otherwise an <code>akka.actor.UnhandledMessage(message,
sender, recipient)</code> will be published to the <code>ActorSystem</code>&rsquo;s <code>EventStream</code>.</p>
<p>Note further that the return type of the behavior defined above is <code>Unit</code>; if the actor shall reply to the received message then this must be done explicitly as explained below.</p>
<p>The result of the <span class="group-scala"><code>receive</code> method is a partial function object, which is</span> <span class="group-java"><code>createReceive</code> method is <code>AbstractActor.Receive</code> which is a wrapper around partial scala function object. It is</span> stored within the actor as its “initial behavior”, see <a href="#become-unbecome">Become/Unbecome</a> for further information on changing the behavior of an actor after its construction.</p><div class="group-scala">
<h4><a href="#here-is-another-example-that-you-can-edit-and-run-in-the-browser-" name="here-is-another-example-that-you-can-edit-and-run-in-the-browser-" class="anchor"><span class="anchor-link"></span></a>Here is another example that you can edit and run in the browser:</h4>

        <div data-scalafiddle    data-template=Akka  data-minheight=400px data-layout=v75>
          <pre class="prettyprint"><code class="language-scala">import akka.actor.{ ActorSystem, Actor, ActorRef, Props, PoisonPill }
import language.postfixOps
import scala.concurrent.duration._

case object Ping
case object Pong

class Pinger extends Actor {
  var countDown = 100

  def receive = {
    case Pong ⇒
      println(s"${self.path} received pong, count down $countDown")

      if (countDown > 0) {
        countDown -= 1
        sender() ! Ping
      } else {
        sender() ! PoisonPill
        self ! PoisonPill
      }
  }
}

class Ponger(pinger: ActorRef) extends Actor {
  def receive = {
    case Ping ⇒
      println(s"${self.path} received ping")
      pinger ! Pong
  }
}

    val system = ActorSystem("pingpong")

    val pinger = system.actorOf(Props[Pinger], "pinger")

    val ponger = system.actorOf(Props(classOf[Ponger], pinger), "ponger")

    import system.dispatcher
    system.scheduler.scheduleOnce(500 millis) {
      ponger ! Ping
    }
</code></pre>
          </pre>
        </div>
        <script defer src="https://embed.scalafiddle.io/integration.js"></script>
        </div>
<h3><a href="#props" name="props" class="anchor"><span class="anchor-link"></span></a>Props</h3>
<p><code>Props</code> is a configuration class to specify options for the creation of actors, think of it as an immutable and thus freely shareable recipe for creating an actor including associated deployment information (e.g. which dispatcher to use, see more below). Here are some examples of how to create a <code>Props</code> instance.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L411-L415" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Props

val props1 = Props[MyActor]
val props2 = Props(new ActorWithArgs(&quot;arg&quot;)) // careful, see below
val props3 = Props(classOf[ActorWithArgs], &quot;arg&quot;) // no support for value class arguments</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L30" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.Props;
Props props1 = Props.create(MyActor.class);
Props props2 =
    Props.create(ActorWithArgs.class, () -&gt; new ActorWithArgs(&quot;arg&quot;)); // careful, see below
Props props3 = Props.create(ActorWithArgs.class, &quot;arg&quot;);</code></pre></dd>
</dl>
<p>The second variant shows how to pass constructor arguments to the <code>Actor</code> being created, but it should only be used outside of actors as explained below.</p>
<p>The last line shows a possibility to pass constructor arguments regardless of the context it is being used in. The presence of a matching constructor is verified during construction of the <code>Props</code> object, resulting in an <code>IllegalArgumentException</code> if no or multiple matching constructors are found.</p><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>The recommended approach to create the actor <code>Props</code> is not supported for cases when the actor constructor takes value classes as arguments.</p></div>
<h4><a href="#dangerous-variants" name="dangerous-variants" class="anchor"><span class="anchor-link"></span></a>Dangerous Variants</h4>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L419-L421" target="_blank" title="Go to snippet source"></a><code class="language-scala">// NOT RECOMMENDED within another actor:
// encourages to close over enclosing class
val props7 = Props(new MyActor)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L522-L524" target="_blank" title="Go to snippet source"></a><code class="language-java">// NOT RECOMMENDED within another actor:
// encourages to close over enclosing class
Props props7 = Props.create(ActorWithArgs.class, () -&gt; new ActorWithArgs(&quot;arg&quot;));</code></pre></dd>
</dl>
<p>This method is not recommended to be used within another actor because it encourages to close over the enclosing scope, resulting in non-serializable <code>Props</code> and possibly race conditions (breaking the actor encapsulation). On the other hand using this variant in a <code>Props</code> factory in the actor’s companion object as documented under “Recommended Practices” below is completely fine.</p>
<p>There were two use-cases for these methods: passing constructor arguments to the actor—which is solved by the newly introduced <span class="group-scala"><code>Props.apply(clazz, args)</code></span> <span class="group-java"><code>Props.create(clazz, args)</code></span> method above or the recommended practice below—and creating actors “on the spot” as anonymous classes. The latter should be solved by making these actors named classes instead (if they are not declared within a top-level <code>object</code> then the enclosing instance’s <code>this</code> reference needs to be passed as the first argument).</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Declaring one actor within another is very dangerous and breaks actor encapsulation. Never pass an actor’s <code>this</code> reference into <code>Props</code>!</p></div><div class="group-scala">
<h4><a href="#edge-cases" name="edge-cases" class="anchor"><span class="anchor-link"></span></a>Edge cases</h4>
<p>There are two edge cases in actor creation with <code>Props</code>:</p>
<ul>
  <li>An actor with <code>AnyVal</code> arguments.</li>
</ul>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L12-L13" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class MyValueClass(v: Int) extends AnyVal
</code></pre>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L19-L24" target="_blank" title="Go to snippet source"></a><code class="language-scala">class ValueActor(value: MyValueClass) extends Actor {
  def receive = {
    case multiplier: Long ⇒ sender() ! (value.v * multiplier)
  }
}
val valueClassProp = Props(classOf[ValueActor], MyValueClass(5)) // Unsupported</code></pre>
<ul>
  <li>An actor with default constructor values.</li>
</ul>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/PropsEdgeCaseSpec.scala#L28-L42" target="_blank" title="Go to snippet source"></a><code class="language-scala">class DefaultValueActor(a: Int, b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! ((a + x) * b)
  }
}

val defaultValueProp1 = Props(classOf[DefaultValueActor], 2.0) // Unsupported

class DefaultValueActor2(b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x * b)
  }
}
val defaultValueProp2 = Props[DefaultValueActor2] // Unsupported
val defaultValueProp3 = Props(classOf[DefaultValueActor2]) // Unsupported</code></pre>
<p>In both cases an <code>IllegalArgumentException</code> will be thrown stating no matching constructor could be found.</p>
<p>The next section explains the recommended ways to create <code>Actor</code> props in a way, which simultaneously safe-guards against these edge cases.</p></div>
<h4><a href="#recommended-practices" name="recommended-practices" class="anchor"><span class="anchor-link"></span></a>Recommended Practices</h4>
<p>It is a good idea to provide <span class="group-scala">factory methods on the companion object of each <code>Actor</code></span> <span class="group-java">static factory methods for each <code>Actor</code></span> which help keeping the creation of suitable <code>Props</code> as close to the actor definition as possible. This also avoids the pitfalls associated with using the <span class="group-scala"><code>Props.apply(...)</code> method which takes a by-name argument, since within a companion object</span> <span class="group-java"> <code>Props.create(...)</code> method which takes arguments as constructor parameters, since within static method</span> the given code block will not retain a reference to its enclosing scope:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L73-L99" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DemoActor {
  /**
   * Create Props for an actor of this type.
   *
   * @param magicNumber The magic number to be passed to this actor’s constructor.
   * @return a Props for creating this actor, which can then be further configured
   *         (e.g. calling `.withDispatcher()` on it)
   */
  def props(magicNumber: Int): Props = Props(new DemoActor(magicNumber))
}

class DemoActor(magicNumber: Int) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x + magicNumber)
  }
}

class SomeOtherActor extends Actor {
  // Props(new DemoActor(42)) would not be safe
  context.actorOf(DemoActor.props(42), &quot;demo&quot;)
  // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L182-L227" target="_blank" title="Go to snippet source"></a><code class="language-java">static class DemoActor extends AbstractActor {
  /**
   * Create Props for an actor of this type.
   *
   * @param magicNumber The magic number to be passed to this actor’s constructor.
   * @return a Props for creating this actor, which can then be further configured (e.g. calling
   *     `.withDispatcher()` on it)
   */
  static Props props(Integer magicNumber) {
    // You need to specify the actual type of the returned actor
    // since Java 8 lambdas have some runtime type information erased
    return Props.create(DemoActor.class, () -&gt; new DemoActor(magicNumber));
  }

  private final Integer magicNumber;

  public DemoActor(Integer magicNumber) {
    this.magicNumber = magicNumber;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Integer.class,
            i -&gt; {
              getSender().tell(i + magicNumber, getSelf());
            })
        .build();
  }
}

static class SomeOtherActor extends AbstractActor {
  // Props(new DemoActor(42)) would not be safe
  ActorRef demoActor = getContext().actorOf(DemoActor.props(42), &quot;demo&quot;);
  // ...
}</code></pre></dd>
</dl>
<p>Another good practice is to declare what messages an Actor can receive <span class="group-scala">in the companion object of the Actor</span> <span class="group-java">as close to the actor definition as possible (e.g. as static classes inside the Actor or using other suitable class)</span>, which makes easier to know what it can receive:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L107-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">object MyActor {
  case class Greeting(from: String)
  case object Goodbye
}
class MyActor extends Actor with ActorLogging {
  import MyActor._
  def receive = {
    case Greeting(greeter) ⇒ log.info(s&quot;I was greeted by $greeter.&quot;)
    case Goodbye           ⇒ log.info(&quot;Someone said goodbye to me.&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L232-L256" target="_blank" title="Go to snippet source"></a><code class="language-java">static class DemoMessagesActor extends AbstractLoggingActor {

  public static class Greeting {
    private final String from;

    public Greeting(String from) {
      this.from = from;
    }

    public String getGreeter() {
      return from;
    }
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            Greeting.class,
            g -&gt; {
              log().info(&quot;I was greeted by {}&quot;, g.getGreeter());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<h3><a href="#creating-actors-with-props" name="creating-actors-with-props" class="anchor"><span class="anchor-link"></span></a>Creating Actors with Props</h3>
<p>Actors are created by passing a <code>Props</code> instance into the <code>actorOf</code> factory method which is available on <code>ActorSystem</code> and <code>ActorContext</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L427-L431" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorSystem

// ActorSystem is a heavy object: create only one per application
val system = ActorSystem(&quot;mySystem&quot;)
val myActor = system.actorOf(Props[MyActor], &quot;myactor2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L33-L34" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorRef;
import akka.actor.ActorSystem;</code></pre></dd>
</dl>
<p>Using the <code>ActorSystem</code> will create top-level actors, supervised by the actor system’s provided guardian actor, while using an actor’s context will create a child actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L44-L51" target="_blank" title="Go to snippet source"></a><code class="language-scala">class FirstActor extends Actor {
  val child = context.actorOf(Props[MyActor], name = &quot;myChild&quot;)
  def receive = {
    case x ⇒ sender() ! x
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L81-L90" target="_blank" title="Go to snippet source"></a><code class="language-java">static class FirstActor extends AbstractActor {
  final ActorRef child = getContext().actorOf(Props.create(MyActor.class), &quot;myChild&quot;);

  @Override
  public Receive createReceive() {
    return receiveBuilder().matchAny(x -&gt; getSender().tell(x, getSelf())).build();
  }
}</code></pre></dd>
</dl>
<p>It is recommended to create a hierarchy of children, grand-children and so on such that it fits the logical failure-handling structure of the application, see <a href="general/actor-systems.html">Actor Systems</a>.</p>
<p>The call to <code>actorOf</code> returns an instance of <code>ActorRef</code>. This is a handle to the actor instance and the only way to interact with it. The <code>ActorRef</code> is immutable and has a one to one relationship with the Actor it represents. The <code>ActorRef</code> is also serializable and network-aware. This means that you can serialize it, send it over the wire and use it on a remote host and it will still be representing the same Actor on the original node, across the network.</p>
<p>The name parameter is optional, but you should preferably name your actors, since that is used in log messages and for identifying actors. The name must not be empty or start with <code>$</code>, but it may contain URL encoded characters (eg. <code>%20</code> for a blank space). If the given name is already in use by another child to the same parent an <code>InvalidActorNameException</code> is thrown.</p>
<p>Actors are automatically started asynchronously when created.</p><div class="group-scala">
<h4><a href="#value-classes-as-constructor-arguments" name="value-classes-as-constructor-arguments" class="anchor"><span class="anchor-link"></span></a>Value classes as constructor arguments</h4>
<p>The recommended way to instantiate actor props uses reflection at runtime to determine the correct actor constructor to be invoked and due to technical limitations is not supported when said constructor takes arguments that are value classes. In these cases you should either unpack the arguments or create the props by calling the constructor manually:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L59-L68" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Argument(val value: String) extends AnyVal
class ValueClassActor(arg: Argument) extends Actor {
  def receive = { case _ ⇒ () }
}

object ValueClassActor {
  def props1(arg: Argument) = Props(classOf[ValueClassActor], arg) // fails at runtime
  def props2(arg: Argument) = Props(classOf[ValueClassActor], arg.value) // ok
  def props3(arg: Argument) = Props(new ValueClassActor(arg)) // ok
}</code></pre></div>
<h3><a href="#dependency-injection" name="dependency-injection" class="anchor"><span class="anchor-link"></span></a>Dependency Injection</h3>
<p>If your <code>Actor</code> has a constructor that takes parameters then those need to be part of the <code>Props</code> as well, as described <a href="Props_">above</a>. But there are cases when a factory method must be used, for example when the actual constructor arguments are determined by a dependency injection framework.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L452-L468" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.IndirectActorProducer

class DependencyInjector(applicationContext: AnyRef, beanName: String)
  extends IndirectActorProducer {

  override def actorClass = classOf[Actor]
  override def produce =
    new Echo(beanName)

  def this(beanName: String) = this(&quot;&quot;, beanName)
}

val actorRef = system.actorOf(
  Props(classOf[DependencyInjector], applicationContext, &quot;hello&quot;),
  &quot;helloBean&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/DependencyInjectionDocTest.java#L19-L20" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.Actor;
import akka.actor.IndirectActorProducer;
class DependencyInjector implements IndirectActorProducer {
  final Object applicationContext;
  final String beanName;

  public DependencyInjector(Object applicationContext, String beanName) {
    this.applicationContext = applicationContext;
    this.beanName = beanName;
  }

  @Override
  public Class&lt;? extends Actor&gt; actorClass() {
    return TheActor.class;
  }

  @Override
  public TheActor produce() {
    TheActor result;
    result = new TheActor((String) applicationContext);
    return result;
  }
}

  final ActorRef myActor =
      getContext()
          .actorOf(
              Props.create(DependencyInjector.class, applicationContext, &quot;TheActor&quot;), &quot;TheActor&quot;);</code></pre></dd>
</dl><div class="callout warning "><div class="callout-title">Warning</div>
<p>You might be tempted at times to offer an <code>IndirectActorProducer</code> which always returns the same instance, e.g. by using a <span class="group-scala"><code>lazy val</code>.</span> <span class="group-java">static field.</span> This is not supported, as it goes against the meaning of an actor restart, which is described here: <a href="general/supervision.html#supervision-restart">What Restarting Means</a>.</p>
<p>When using a dependency injection framework, actor beans <em>MUST NOT</em> have singleton scope.</p></div>
<p>Techniques for dependency injection and integration with dependency injection frameworks are described in more depth in the <a href="http://letitcrash.com/post/55958814293/akka-dependency-injection">Using Akka with Dependency Injection</a> guideline and the <a href="https://github.com/typesafehub/activator-akka-java-spring">Akka Java Spring</a> tutorial.</p>
<h3><a href="#the-inbox" name="the-inbox" class="anchor"><span class="anchor-link"></span></a>The Inbox</h3>
<p>When writing code outside of actors which shall communicate with actors, the <code>ask</code> pattern can be a solution (see below), but there are two things it cannot do: receiving multiple replies (e.g. by subscribing an <code>ActorRef</code> to a notification service) and watching other actors’ lifecycle. For these purposes there is the <code>Inbox</code> class:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-tests/src/test/scala/akka/actor/ActorDSLSpec.scala#L37-L41" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ActorDSL._

implicit val i = inbox()
echo ! &quot;hello&quot;
i.receive() should ===(&quot;hello&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/InboxDocTest.java#L35-L45" target="_blank" title="Go to snippet source"></a><code class="language-java">final Inbox inbox = Inbox.create(system);
inbox.send(target, &quot;hello&quot;);
try {
  assert inbox.receive(Duration.ofSeconds(1)).equals(&quot;world&quot;);
} catch (java.util.concurrent.TimeoutException e) {
  // timeout
}</code></pre></dd>
</dl><div class="group-scala">
<p>There is an implicit conversion from inbox to actor reference which means that in this example the sender reference will be that of the actor hidden away within the inbox. This allows the reply to be received on the last line. Watching an actor is quite simple as well:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-tests/src/test/scala/akka/actor/ActorDSLSpec.scala#L47-L52" target="_blank" title="Go to snippet source"></a><code class="language-scala">val target = // some actor
val i = inbox()
i watch target</code></pre></div><div class="group-java">
<p>The <code>send</code> method wraps a normal <code>tell</code> and supplies the internal actor’s reference as the sender. This allows the reply to be received on the last line. Watching an actor is quite simple as well:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/InboxDocTest.java#L54-L61" target="_blank" title="Go to snippet source"></a><code class="language-java">final Inbox inbox = Inbox.create(system);
inbox.watch(target);
target.tell(PoisonPill.getInstance(), ActorRef.noSender());
try {
  assert inbox.receive(Duration.ofSeconds(1)) instanceof Terminated;
} catch (java.util.concurrent.TimeoutException e) {
  // timeout
}</code></pre></div>
<h2><a href="#actor-api" name="actor-api" class="anchor"><span class="anchor-link"></span></a>Actor API</h2>
<p><span class="group-scala">The <code>Actor</code> trait defines only one abstract method, the above mentioned <code>receive</code>, which implements the behavior of the actor.</span> <span class="group-java">The <code>AbstractActor</code> class defines a method called <code>createReceive</code>, that is used to set the “initial behavior” of the actor.</span></p>
<p>If the current actor behavior does not match a received message, <code>unhandled</code> is called, which by default publishes an <code>akka.actor.UnhandledMessage(message, sender, recipient)</code> on the actor system’s event stream (set configuration item <code>akka.actor.debug.unhandled</code> to <code>on</code> to have them converted into actual Debug messages).</p>
<p>In addition, it offers:</p>
<ul>
  <li><span class="group-scala"><code>self</code></span> <span class="group-java"><code>getSelf()</code></span> reference to the <code>ActorRef</code> of the actor</li>
  <li><span class="group-scala"><code>sender</code></span> <span class="group-java"><code>getSender()</code></span> reference sender Actor of the last received message, typically used as described in  <span class="group-scala"><a href="#actor-reply">Actor.Reply</a></span>  <span class="group-java"><a href="#lambdaactor-reply">LambdaActor.Reply</a></span></li>
  <li><span class="group-scala"><code>supervisorStrategy</code></span> <span class="group-java"><code>supervisorStrategy()</code></span> user overridable definition the strategy to use for supervising child actors</li>
</ul>
<p>This strategy is typically declared inside the actor in order to have access to the actor’s internal state within the decider function: since failure is communicated as a message sent to the supervisor and processed like other messages (albeit outside of the normal behavior), all values and variables within the actor are available, as is the <code>sender</code> reference (which will be the immediate child reporting the failure; if the original failure occurred within a distant descendant it is still reported one level up at a time).</p>
<ul>
  <li><span class="group-scala"><code>context</code></span> <span class="group-java"><code>getContext()</code></span> exposes contextual information for the actor and the current message, such as:
    <ul>
      <li>factory methods to create child actors (<code>actorOf</code>)</li>
      <li>system that the actor belongs to</li>
      <li>parent supervisor</li>
      <li>supervised children</li>
      <li>lifecycle monitoring</li>
      <li>hotswap behavior stack as described in <span class="group-scala"><a href="#actor-hotswap">Actor.HotSwap</a></span> <span class="group-java"><a href="#actor-hotswap">Become/Unbecome</a></span></li>
    </ul>
  </li>
</ul><div class="group-scala">
<p>You can import the members in the <code>context</code> to avoid prefixing access with <code>context.</code></p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L330-L336" target="_blank" title="Go to snippet source"></a><code class="language-scala">class FirstActor extends Actor {
  import context._
  val myActor = actorOf(Props[MyActor], name = &quot;myactor&quot;)
  def receive = {
    case x ⇒ myActor ! x
  }
}</code></pre></div>
<p>The remaining visible methods are user-overridable life-cycle hooks which are described in the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor/src/main/scala/akka/actor/Actor.scala#L569-L615" target="_blank" title="Go to snippet source"></a><code class="language-scala">def preStart(): Unit = ()

def postStop(): Unit = ()

def preRestart(@unused reason: Throwable, @unused message: Option[Any]): Unit = {
  context.children foreach { child ⇒
    context.unwatch(child)
    context.stop(child)
  }
  postStop()
}

def postRestart(@unused reason: Throwable): Unit = {
  preStart()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L272-L286" target="_blank" title="Go to snippet source"></a><code class="language-java">public void preStart() {}

public void preRestart(Throwable reason, Optional&lt;Object&gt; message) {
  for (ActorRef each : getContext().getChildren()) {
    getContext().unwatch(each);
    getContext().stop(each);
  }
  postStop();
}

public void postRestart(Throwable reason) {
  preStart();
}

public void postStop() {}</code></pre></dd>
</dl>
<p>The implementations shown above are the defaults provided by the <span class="group-scala"><code>Actor</code> trait.</span> <span class="group-java"><code>AbstractActor</code> class.</span></p>
<a id="actor-lifecycle"></a>
<h3><a href="#actor-lifecycle" name="actor-lifecycle" class="anchor"><span class="anchor-link"></span></a>Actor Lifecycle</h3>
<p><img src="./images/actor_lifecycle.png" alt="actor_lifecycle.png" /></p>
<p>A path in an actor system represents a &ldquo;place&rdquo; which might be occupied by a living actor. Initially (apart from system initialized actors) a path is empty. When <code>actorOf()</code> is called it assigns an <em>incarnation</em> of the actor described by the passed <code>Props</code> to the given path. An actor incarnation is identified by the path <em>and a UID</em>. </p>
<p>It is worth noting about the difference between:</p>
<ul>
  <li>restart</li>
  <li>stop, followed by re-creation of actor</li>
</ul>
<p>as explained below.</p>
<p>A restart only swaps the <code>Actor</code> instance defined by the <code>Props</code> but the incarnation and hence the UID remains the same. As long as the incarnation is same, you can keep using the same <code>ActorRef</code>. Restart is handled by the <a href="fault-tolerance.html#creating-a-supervisor-strategy">Supervision Strategy</a> of actor&rsquo;s parent actor, and there is more discussion about <a href="general/supervision.html#supervision-restart">what restart means</a>.</p>
<p>The lifecycle of an incarnation ends when the actor is stopped. At that point the appropriate lifecycle events are called and watching actors are notified of the termination. After the incarnation is stopped, the path can be reused again by creating an actor with <code>actorOf()</code>. In this case the name of the new incarnation will be the same as the previous one but the UIDs will differ. An actor can be stopped by the actor itself, another actor or the <code>ActorSystem</code> (see <a href="#stopping-actors">Stopping actors</a>).</p><div class="callout note "><div class="callout-title">Note</div>
<p>It is important to note that Actors do not stop automatically when no longer referenced, every Actor that is created must also explicitly be destroyed. The only simplification is that stopping a parent Actor will also recursively stop all the child Actors that this parent has created.</p></div>
<p>An <code>ActorRef</code> always represents an incarnation (path and UID) not just a given path. Therefore if an actor is stopped and a new one with the same name is created an <code>ActorRef</code> of the old incarnation will not point to the new one.</p>
<p><code>ActorSelection</code> on the other hand points to the path (or multiple paths if wildcards are used) and is completely oblivious to which incarnation is currently occupying it. <code>ActorSelection</code> cannot be watched for this reason. It is possible to resolve the current incarnation&rsquo;s <code>ActorRef</code> living under the path by sending an <code>Identify</code> message to the <code>ActorSelection</code> which will be replied to with an <code>ActorIdentity</code> containing the correct reference (see <a href="#actorselection">ActorSelection</a>). This can also be done with the <code>resolveOne</code> method of the <code>ActorSelection</code>, which returns a <code>Future</code> of the matching <code>ActorRef</code>.</p>
<a id="deathwatch"></a>
<h3><a href="#lifecycle-monitoring-aka-deathwatch" name="lifecycle-monitoring-aka-deathwatch" class="anchor"><span class="anchor-link"></span></a>Lifecycle Monitoring aka DeathWatch</h3>
<p>In order to be notified when another actor terminates (i.e. stops permanently, not temporary failure and restart), an actor may register itself for reception of the <code>Terminated</code> message dispatched by the other actor upon termination (see <a href="#stopping-actors">Stopping Actors</a>). This service is provided by the <code>DeathWatch</code> component of the actor system.</p>
<p>Registering a monitor is easy:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L576-L588" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Actor, Props, Terminated }

class WatchActor extends Actor {
  val child = context.actorOf(Props.empty, &quot;child&quot;)
  context.watch(child) // &lt;-- this is the only call needed for registration
  var lastSender = context.system.deadLetters

  def receive = {
    case &quot;kill&quot; ⇒
      context.stop(child); lastSender = sender()
    case Terminated(`child`) ⇒ lastSender ! &quot;finished&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L54" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.Terminated;
static class WatchActor extends AbstractActor {
  private final ActorRef child = getContext().actorOf(Props.empty(), &quot;target&quot;);
  private ActorRef lastSender = system.deadLetters();

  public WatchActor() {
    getContext().watch(child); // &lt;-- this is the only call needed for registration
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;kill&quot;,
            s -&gt; {
              getContext().stop(child);
              lastSender = getSender();
            })
        .match(
            Terminated.class,
            t -&gt; t.actor().equals(child),
            t -&gt; {
              lastSender.tell(&quot;finished&quot;, getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>It should be noted that the <code>Terminated</code> message is generated independent of the order in which registration and termination occur. In particular, the watching actor will receive a <code>Terminated</code> message even if the watched actor has already been terminated at the time of registration.</p>
<p>Registering multiple times does not necessarily lead to multiple messages being generated, but there is no guarantee that only exactly one such message is received: if termination of the watched actor has generated and queued the message, and another registration is done before this message has been processed, then a second message will be queued, because registering for monitoring of an already terminated actor leads to the immediate generation of the <code>Terminated</code> message.</p>
<p>It is also possible to deregister from watching another actor’s liveliness using <code>context.unwatch(target)</code>. This works even if the <code>Terminated</code> message has already been enqueued in the mailbox; after calling <code>unwatch</code> no <code>Terminated</code> message for that actor will be processed anymore.</p>
<a id="start-hook"></a>
<h3><a href="#start-hook" name="start-hook" class="anchor"><span class="anchor-link"></span></a>Start Hook</h3>
<p>Right after starting the actor, its <code>preStart</code> method is invoked.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L126-L128" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def preStart(): Unit = {
  child = context.actorOf(Props[MyActor], &quot;child&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L300-L303" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public void preStart() {
  target = getContext().actorOf(Props.create(MyActor.class, &quot;target&quot;));
}</code></pre></dd>
</dl>
<p>This method is called when the actor is first created. During restarts it is called by the default implementation of <code>postRestart</code>, which means that by overriding that method you can choose whether the initialization code in this method is called only exactly once for this actor or for every restart. Initialization code which is part of the actor’s constructor will always be called when an instance of the actor class is created, which happens at every restart.</p>
<a id="restart-hook"></a>
<h3><a href="#restart-hooks" name="restart-hooks" class="anchor"><span class="anchor-link"></span></a>Restart Hooks</h3>
<p>All actors are supervised, i.e. linked to another actor with a fault handling strategy. Actors may be restarted in case an exception is thrown while processing a message (see <a href="general/supervision.html">supervision</a>). This restart involves the hooks mentioned above:</p>
<p>1.  The old actor is informed by calling <code>preRestart</code> with the exception which caused the restart and the message which triggered that exception; the latter may be <code>None</code> if the restart was not caused by processing a message, e.g. when a supervisor does not trap the exception and is restarted in turn by its supervisor, or if an actor is restarted due to a sibling’s failure. If the message is available, then that message’s sender is also accessible in the usual way (i.e. by calling <code>sender</code>).  This method is the best place for cleaning up, preparing hand-over to the fresh actor instance, etc. By default it stops all children and calls <code>postStop</code>.  2. The initial factory from the <code>actorOf</code> call is used to produce the fresh instance.  3. The new actor’s <code>postRestart</code> method is invoked with the exception which caused the restart. By default the <code>preStart</code> is called, just as in the normal start-up case.</p>
<p>An actor restart replaces only the actual actor object; the contents of the mailbox is unaffected by the restart, so processing of messages will resume after the <code>postRestart</code> hook returns. The message that triggered the exception will not be received again. Any message sent to an actor while it is being restarted will be queued to its mailbox as usual.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Be aware that the ordering of failure notifications relative to user messages is not deterministic. In particular, a parent might restart its child before it has processed the last messages sent by the child before the failure. See <a href="general/message-delivery-reliability.html#message-ordering">Discussion: Message Ordering</a> for details.</p></div>
<a id="stop-hook"></a>
<h3><a href="#stop-hook" name="stop-hook" class="anchor"><span class="anchor-link"></span></a>Stop Hook</h3>
<p>After stopping an actor, its <code>postStop</code> hook is called, which may be used e.g. for deregistering this actor from other services. This hook is guaranteed to run after message queuing has been disabled for this actor, i.e. messages sent to a stopped actor will be redirected to the <code>deadLetters</code> of the <code>ActorSystem</code>.</p>
<a id="actorselection"></a>
<h2><a href="#identifying-actors-via-actor-selection" name="identifying-actors-via-actor-selection" class="anchor"><span class="anchor-link"></span></a>Identifying Actors via Actor Selection</h2>
<p>As described in <a href="general/addressing.html">Actor References, Paths and Addresses</a>, each actor has a unique logical path, which is obtained by following the chain of actors from child to parent until reaching the root of the actor system, and it has a physical path, which may differ if the supervision chain includes any remote supervisors. These paths are used by the system to look up actors, e.g. when a remote message is received and the recipient is searched, but they are also useful more directly: actors may look up other actors by specifying absolute or relative paths—logical or physical—and receive back an <code>ActorSelection</code> with the result:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L617-L620" target="_blank" title="Go to snippet source"></a><code class="language-scala">// will look up this absolute path
context.actorSelection(&quot;/user/serviceA/aggregator&quot;)
// will look up sibling beneath same supervisor
context.actorSelection(&quot;../joe&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L326-L329" target="_blank" title="Go to snippet source"></a><code class="language-java">// will look up this absolute path
getContext().actorSelection(&quot;/user/serviceA/actor&quot;);
// will look up sibling beneath same supervisor
getContext().actorSelection(&quot;../joe&quot;);</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>It is always preferable to communicate with other Actors using their ActorRef instead of relying upon ActorSelection. Exceptions are</p>
<ul>
  <li>sending messages using the <a href="persistence.html#at-least-once-delivery">At-Least-Once Delivery</a> facility</li>
  <li>initiating first contact with a remote system</li>
</ul>
<p>In all other cases ActorRefs can be provided during Actor creation or initialization, passing them from parent to child or introducing Actors by sending their ActorRefs to other Actors within messages.</p></div>
<p>The supplied path is parsed as a <code>java.net.URI</code>, which means that it is split on <code>/</code> into path elements. If the path starts with <code>/</code>, it is absolute and the look-up starts at the root guardian (which is the parent of <code>&quot;/user&quot;</code>); otherwise it starts at the current actor. If a path element equals <code>..</code>, the look-up will take a step “up” towards the supervisor of the currently traversed actor, otherwise it will step “down” to the named child. It should be noted that the <code>..</code> in actor paths here always means the logical structure, i.e. the supervisor.</p>
<p>The path elements of an actor selection may contain wildcard patterns allowing for broadcasting of messages to that section:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L623-L626" target="_blank" title="Go to snippet source"></a><code class="language-scala">// will look all children to serviceB with names starting with worker
context.actorSelection(&quot;/user/serviceB/worker*&quot;)
// will look up all siblings beneath same supervisor
context.actorSelection(&quot;../*&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L333-L336" target="_blank" title="Go to snippet source"></a><code class="language-java">// will look all children to serviceB with names starting with worker
getContext().actorSelection(&quot;/user/serviceB/worker*&quot;);
// will look up all siblings beneath same supervisor
getContext().actorSelection(&quot;../*&quot;);</code></pre></dd>
</dl>
<p>Messages can be sent via the <code>ActorSelection</code> and the path of the <code>ActorSelection</code> is looked up when delivering each message. If the selection does not match any actors the message will be dropped.</p>
<p>To acquire an <code>ActorRef</code> for an <code>ActorSelection</code> you need to send a message to the selection and use the <span class="group-scala"><code>sender()</code></span> <span class="group-java"><code>getSender()</code></span> reference of the reply from the actor. There is a built-in <code>Identify</code> message that all Actors will understand and automatically reply to with a <code>ActorIdentity</code> message containing the <code>ActorRef</code>. This message is handled specially by the actors which are traversed in the sense that if a concrete name lookup fails (i.e. a non-wildcard path element does not correspond to a live actor) then a negative result is generated. Please note that this does not mean that delivery of that reply is guaranteed, it still is a normal message.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L636-L653" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Actor, Props, Identify, ActorIdentity, Terminated }

class Follower extends Actor {
  val identifyId = 1
  context.actorSelection(&quot;/user/another&quot;) ! Identify(identifyId)

  def receive = {
    case ActorIdentity(`identifyId`, Some(ref)) ⇒
      context.watch(ref)
      context.become(active(ref))
    case ActorIdentity(`identifyId`, None) ⇒ context.stop(self)

  }

  def active(another: ActorRef): Actor.Receive = {
    case Terminated(`another`) ⇒ context.stop(self)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L37-L39" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorIdentity;
import akka.actor.ActorSelection;
import akka.actor.Identify;
static class Follower extends AbstractActor {
  final Integer identifyId = 1;

  public Follower() {
    ActorSelection selection = getContext().actorSelection(&quot;/user/another&quot;);
    selection.tell(new Identify(identifyId), getSelf());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ActorIdentity.class,
            id -&gt; id.getActorRef().isPresent(),
            id -&gt; {
              ActorRef ref = id.getActorRef().get();
              getContext().watch(ref);
              getContext().become(active(ref));
            })
        .match(
            ActorIdentity.class,
            id -&gt; !id.getActorRef().isPresent(),
            id -&gt; {
              getContext().stop(getSelf());
            })
        .build();
  }

  final AbstractActor.Receive active(final ActorRef another) {
    return receiveBuilder()
        .match(
            Terminated.class, t -&gt; t.actor().equals(another), t -&gt; getContext().stop(getSelf()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>You can also acquire an <code>ActorRef</code> for an <code>ActorSelection</code> with the <code>resolveOne</code> method of the <code>ActorSelection</code>. It returns a <code>Future</code> of the matching <code>ActorRef</code> if such an actor exists. <span class="group-java">(see also <a href="java8-compat.html">Java 8 Compatibility</a> for Java compatibility).</span> It is completed with failure <code>akka.actor.ActorNotFound</code> if no such actor exists or the identification didn&rsquo;t complete within the supplied <code>timeout</code>.</p>
<p>Remote actor addresses may also be looked up, if <a href="remoting.html">remoting</a> is enabled:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L629" target="_blank" title="Go to snippet source"></a><code class="language-scala">context.actorSelection(&quot;akka.tcp://app@otherhost:1234/user/serviceB&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L340" target="_blank" title="Go to snippet source"></a><code class="language-java">getContext().actorSelection(&quot;akka.tcp://app@otherhost:1234/user/serviceB&quot;);</code></pre></dd>
</dl>
<p>An example demonstrating actor look-up is given in <a href="remoting.html#remote-sample">Remoting Sample</a>.</p>
<h2><a href="#messages-and-immutability" name="messages-and-immutability" class="anchor"><span class="anchor-link"></span></a>Messages and immutability</h2><div class="callout warning "><div class="callout-title">IMPORTANT</div>
<p>Messages can be any kind of object but have to be immutable. <span class="group-scala">Scala</span> <span class="group-java">Akka</span> can’t enforce immutability (yet) so this has to be by convention. <span class="group-scala">Primitives like String, Int, Boolean are always immutable. Apart from these the recommended approach is to use Scala case classes which are immutable (if you don’t explicitly expose the state) and works great with pattern matching at the receiver side.</span></p></div>
<p>Here is an <span class="group-scala">example:</span> <span class="group-java">example of an immutable message:</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L316-L319" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class User(name: String)

// define the case class
case class Register(user: User)
val user = User(&quot;Mike&quot;)
// create a new case class message
val message = Register(user)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ImmutableMessage.java#L12-L28" target="_blank" title="Go to snippet source"></a><code class="language-java">public class ImmutableMessage {
  private final int sequenceNumber;
  private final List&lt;String&gt; values;

  public ImmutableMessage(int sequenceNumber, List&lt;String&gt; values) {
    this.sequenceNumber = sequenceNumber;
    this.values = Collections.unmodifiableList(new ArrayList&lt;String&gt;(values));
  }

  public int getSequenceNumber() {
    return sequenceNumber;
  }

  public List&lt;String&gt; getValues() {
    return values;
  }
}</code></pre></dd>
</dl>
<h2><a href="#send-messages" name="send-messages" class="anchor"><span class="anchor-link"></span></a>Send messages</h2>
<p>Messages are sent to an Actor through one of the following methods.</p>
<ul>
  <li><span class="group-scala"><code>!</code></span> <span class="group-java"><code>tell</code> </span> means “fire-and-forget”, e.g. send a message asynchronously and return immediately. <span class="group-scala">Also known as <code>tell</code>.</span></li>
  <li><span class="group-scala"><code>?</code></span> <span class="group-java"><code>ask</code></span> sends a message asynchronously and returns a  representing a possible reply. <span class="group-scala">Also known as <code>ask</code>.</span></li>
</ul>
<p>Message ordering is guaranteed on a per-sender basis.</p><div class="callout note "><div class="callout-title">Note</div>
<p>There are performance implications of using <code>ask</code> since something needs to keep track of when it times out, there needs to be something that bridges a <code>Promise</code> into an <code>ActorRef</code> and it also needs to be reachable through remoting. So always prefer <code>tell</code> for performance, and only <code>ask</code> if you must.</p></div><div class="group-java">
<p>In all these methods you have the option of passing along your own <code>ActorRef</code>. Make it a practice of doing so because it will allow the receiver actors to be able to respond to your message, since the sender reference is sent along with the message.</p></div>
<a id="actors-tell-sender"></a>
<h3><a href="#tell-fire-forget" name="tell-fire-forget" class="anchor"><span class="anchor-link"></span></a>Tell: Fire-forget</h3>
<p>This is the preferred way of sending messages. No blocking waiting for a message. This gives the best concurrency and scalability characteristics.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L479" target="_blank" title="Go to snippet source"></a><code class="language-scala">actorRef ! message</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L311-L312" target="_blank" title="Go to snippet source"></a><code class="language-java">// don’t forget to think about who is the sender (2nd argument)
target.tell(message, getSelf());</code></pre></dd>
</dl><div class="group-scala">
<p>If invoked from within an Actor, then the sending actor reference will be implicitly passed along with the message and available to the receiving Actor in its <code>sender(): ActorRef</code> member method. The target actor can use this to reply to the original sender, by using <code>sender() ! replyMsg</code>.</p>
<p>If invoked from an instance that is <strong>not</strong> an Actor the sender will be <code>deadLetters</code> actor reference by default.</p></div><div class="group-java">
<p>The sender reference is passed along with the message and available within the receiving actor via its <code>getSender()</code> method while processing this message. Inside of an actor it is usually <code>getSelf()</code> who shall be the sender, but there can be cases where replies shall be routed to some other actor—e.g. the parent—in which the second argument to <code>tell</code> would be a different one. Outside of an actor and if no reply is needed the second argument can be <code>null</code>; if a reply is needed outside of an actor you can use the ask-pattern described next..</p></div>
<a id="actors-ask"></a>
<h3><a href="#ask-send-and-receive-future" name="ask-send-and-receive-future" class="anchor"><span class="anchor-link"></span></a>Ask: Send-And-Receive-Future</h3>
<p>The <code>ask</code> pattern involves actors as well as futures, hence it is offered as a use pattern rather than a method on <code>ActorRef</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L684-L699" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.pattern.{ ask, pipe }
import system.dispatcher // The ExecutionContext that will be used
final case class Result(x: Int, s: String, d: Double)
case object Request

implicit val timeout = Timeout(5 seconds) // needed for `?` below

val f: Future[Result] =
  for {
    x ← ask(actorA, Request).mapTo[Int] // call pattern directly
    s ← (actorB ask Request).mapTo[String] // call by implicit conversion
    d ← (actorC ? Request).mapTo[Double] // call by symbolic name
  } yield Result(x, s, d)

f pipeTo actorD // .. or ..
pipe(f) to actorD</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L42-L45" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.ask;
import static akka.pattern.Patterns.pipe;

import java.util.concurrent.CompletableFuture;
final Duration t = Duration.ofSeconds(5);

// using 1000ms timeout
CompletableFuture&lt;Object&gt; future1 =
    ask(actorA, &quot;request&quot;, Duration.ofMillis(1000)).toCompletableFuture();

// using timeout from above
CompletableFuture&lt;Object&gt; future2 = ask(actorB, &quot;another request&quot;, t).toCompletableFuture();

CompletableFuture&lt;Result&gt; transformed =
    CompletableFuture.allOf(future1, future2)
        .thenApply(
            v -&gt; {
              String x = (String) future1.join();
              String s = (String) future2.join();
              return new Result(x, s);
            });

pipe(transformed, system.dispatcher()).to(actorC);</code></pre></dd>
</dl>
<p>This example demonstrates <code>ask</code> together with the <code>pipeTo</code> pattern on futures, because this is likely to be a common combination. Please note that all of the above is completely non-blocking and asynchronous: <code>ask</code> produces a , <span class="group-scala">three</span> <span class="group-java">two</span> of which are composed into a new future using the <span class="group-scala">for-comprehension and then <code>pipeTo</code> installs an <code>onComplete</code>-handler on the <code>Future</code> to affect</span> <span class="group-java"><code>CompletableFuture.allOf</code> and <code>thenApply</code> methods and then <code>pipe</code> installs a handler on the <code>CompletionStage</code> to effect</span> the submission of the aggregated <code>Result</code> to another actor.</p>
<p>Using <code>ask</code> will send a message to the receiving Actor as with <code>tell</code>, and the receiving actor must reply with <span class="group-scala"><code>sender() ! reply</code></span> <span class="group-java"><code>getSender().tell(reply, getSelf())</code> </span> in order to complete the returned  with a value. The <code>ask</code> operation involves creating an internal actor for handling this reply, which needs to have a timeout after which it is destroyed in order not to leak resources; see more below.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>To complete the  with an exception you need to send an <code>akka.actor.Status.Failure</code> message to the sender. This is <em>not done automatically</em> when an actor throws an exception while processing a message. </p>
<p></p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L144-L151" target="_blank" title="Go to snippet source"></a><code class="language-scala">try {
  val result = operation()
  sender() ! result
} catch {
  case e: Exception ⇒
    sender() ! akka.actor.Status.Failure(e)
    throw e
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L353-L359" target="_blank" title="Go to snippet source"></a><code class="language-java">try {
  String result = operation();
  getSender().tell(result, getSelf());
} catch (Exception e) {
  getSender().tell(new akka.actor.Status.Failure(e), getSelf());
  throw e;
}</code></pre></dd>
</dl>
<p>If the actor does not complete the , it will expire after the timeout period, <span class="group-scala">completing it with an <code>AskTimeoutException</code>. The timeout is taken from one of the following locations in order of precedence:</span> <span class="group-java">specified as parameter to the <code>ask</code> method; this will complete the <code>CompletionStage</code> with an <code>AskTimeoutException</code>.</span></p><div class="group-scala">
<ol>
  <li>
    <p>explicitly given timeout as in:</p>
    <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L502-L504" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._
import akka.pattern.ask
val future = myActor.ask(&quot;hello&quot;)(5 seconds)</code></pre>
  </li>
  <li>
    <p>implicit argument of type <code>akka.util.Timeout</code>, e.g.</p>
    <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L489-L493" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._
import akka.util.Timeout
import akka.pattern.ask
implicit val timeout = Timeout(5 seconds)
val future = myActor ? &quot;hello&quot;</code></pre>
  </li>
</ol>
<p>See <a href="futures.html">Futures</a> for more information on how to await or query a future.</p></div>
<p>The  can be used to register a callback to get a notification when the  completes, giving you a way to avoid blocking.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>When using future callbacks, <span class="group-scala">such as <code>onComplete</code>, or <code>map</code></span><span class="group-scala">such as <code>thenRun</code>, or <code>thenApply</code></span> inside actors you need to carefully avoid closing over the containing actor’s reference, i.e. do not call methods or access mutable state on the enclosing actor from within the callback. This would break the actor encapsulation and may introduce synchronization bugs and race conditions because the callback will be scheduled concurrently to the enclosing actor. Unfortunately there is not yet a way to detect these illegal accesses at compile time. See also: <a href="general/jmm.html#jmm-shared-state">Actors and shared mutable state</a></p></div>
<h3><a href="#forward-message" name="forward-message" class="anchor"><span class="anchor-link"></span></a>Forward message</h3>
<p>You can forward a message from one actor to another. This means that the original sender address/reference is maintained even though the message is going through a &lsquo;mediator&rsquo;. This can be useful when writing actors that work as routers, load-balancers, replicators etc.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L443" target="_blank" title="Go to snippet source"></a><code class="language-scala">target forward message</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L316" target="_blank" title="Go to snippet source"></a><code class="language-java">target.forward(result, getContext());</code></pre></dd>
</dl>
<h2><a href="#receive-messages" name="receive-messages" class="anchor"><span class="anchor-link"></span></a>Receive messages</h2>
<p>An Actor has to <span class="group-scala">implement the <code>receive</code> method to receive messages:</span> <span class="group-java">define its initial receive behavior by implementing the <code>createReceive</code> method in the <code>AbstractActor</code>:</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor/src/main/scala/akka/actor/Actor.scala#L360-L503" target="_blank" title="Go to snippet source"></a><code class="language-scala">type Receive = PartialFunction[Any, Unit]

def receive: Actor.Receive</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L95-L98" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public Receive createReceive() {
  return receiveBuilder().match(String.class, s -&gt; System.out.println(s.toLowerCase())).build();
}</code></pre></dd>
</dl><div class="group-scala">
<p>This method returns a <code>PartialFunction</code>, e.g. a ‘match/case’ clause in which the message can be matched against the different case clauses using Scala pattern matching. Here is an example:</p></div><div class="group-java">
<p>The return type is <code>AbstractActor.Receive</code> that defines which messages your Actor can handle, along with the implementation of how the messages should be processed. You can build such behavior with a builder named <code>ReceiveBuilder</code>. Here is an example:</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L13-L16" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case &quot;test&quot; ⇒ log.info(&quot;received test&quot;)
    case _      ⇒ log.info(&quot;received unknown message&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/MyActor.java#L8-L11" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;

public class MyActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            s -&gt; {
              log.info(&quot;Received String message: {}&quot;, s);
            })
        .matchAny(o -&gt; log.info(&quot;received unknown message&quot;))
        .build();
  }
}</code></pre></dd>
</dl><div class="group-java">
<p>In case you want to provide many <code>match</code> cases but want to avoid creating a long call trail, you can split the creation of the builder into multiple statements as in the example:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/GraduallyBuiltActor.java#L8-L12" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;
import akka.japi.pf.ReceiveBuilder;

public class GraduallyBuiltActor extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  @Override
  public Receive createReceive() {
    ReceiveBuilder builder = ReceiveBuilder.create();

    builder.match(
        String.class,
        s -&gt; {
          log.info(&quot;Received String message: {}&quot;, s);
        });

    // do some other stuff in between

    builder.matchAny(o -&gt; log.info(&quot;received unknown message&quot;));

    return builder.build();
  }
}</code></pre>
<p>Using small methods is a good practice, also in actors. It&rsquo;s recommended to delegate the actual work of the message processing to methods instead of defining a huge <code>ReceiveBuilder</code> with lots of code in each lambda. A well structured actor can look like this:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L104-L132" target="_blank" title="Go to snippet source"></a><code class="language-java">static class WellStructuredActor extends AbstractActor {

  public static class Msg1 {}

  public static class Msg2 {}

  public static class Msg3 {}

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(Msg1.class, this::receiveMsg1)
        .match(Msg2.class, this::receiveMsg2)
        .match(Msg3.class, this::receiveMsg3)
        .build();
  }

  private void receiveMsg1(Msg1 msg) {
    // actual work
  }

  private void receiveMsg2(Msg2 msg) {
    // actual work
  }

  private void receiveMsg3(Msg3 msg) {
    // actual work
  }
}</code></pre>
<p>That has benefits such as:</p>
<ul>
  <li>easier to see what kind of messages the actor can handle</li>
  <li>readable stack traces in case of exceptions</li>
  <li>works better with performance profiling tools</li>
  <li>Java HotSpot has a better opportunity for making optimizations</li>
</ul>
<p>The <code>Receive</code> can be implemented in other ways than using the <code>ReceiveBuilder</code> since it in the end is just a wrapper around a Scala <code>PartialFunction</code>. In Java, you can implement <code>PartialFunction</code> by extending <code>AbstractPartialFunction</code>. For example, one could implement an adapter to <a href="http://www.vavr.io/vavr-docs/#_pattern_matching">Vavr Pattern Matching DSL</a>. See the <a href="https://developer.lightbend.com/start/?group=akka&project=akka-sample-vavr">Akka Vavr sample project</a> for more details.</p>
<p>If the validation of the <code>ReceiveBuilder</code> match logic turns out to be a bottleneck for some of your actors you can consider to implement it at lower level by extending <code>UntypedAbstractActor</code> instead of <code>AbstractActor</code>. The partial functions created by the <code>ReceiveBuilder</code> consist of multiple lambda expressions for every match statement, where each lambda is referencing the code to be run. This is something that the JVM can have problems optimizing and the resulting code might not be as performant as the untyped version. When extending <code>UntypedAbstractActor</code> each message is received as an untyped <code>Object</code> and you have to inspect and cast it to the actual message type in other ways, like this:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L137-L164" target="_blank" title="Go to snippet source"></a><code class="language-java">static class OptimizedActor extends UntypedAbstractActor {

  public static class Msg1 {}

  public static class Msg2 {}

  public static class Msg3 {}

  @Override
  public void onReceive(Object msg) throws Exception {
    if (msg instanceof Msg1) receiveMsg1((Msg1) msg);
    else if (msg instanceof Msg2) receiveMsg2((Msg2) msg);
    else if (msg instanceof Msg3) receiveMsg3((Msg3) msg);
    else unhandled(msg);
  }

  private void receiveMsg1(Msg1 msg) {
    // actual work
  }

  private void receiveMsg2(Msg2 msg) {
    // actual work
  }

  private void receiveMsg3(Msg3 msg) {
    // actual work
  }
}</code></pre></div>
<a id="actor-reply"></a>
<h2><a href="#reply-to-messages" name="reply-to-messages" class="anchor"><span class="anchor-link"></span></a>Reply to messages</h2>
<p>If you want to have a handle for replying to a message, you can use <span class="group-scala"><code>sender()</code></span> <span class="group-java"><code>getSender()</code></span>, which gives you an ActorRef. You can reply by sending to that ActorRef with <span class="group-scala"><code>sender() ! replyMsg</code>.</span> <span class="group-java"><code>getSender().tell(replyMsg, getSelf())</code>.</span> You can also store the ActorRef for replying later, or passing on to other actors. If there is no sender (a message was sent without an actor or future context) then the sender defaults to a &lsquo;dead-letter&rsquo; actor ref.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L712" target="_blank" title="Go to snippet source"></a><code class="language-scala">sender() ! x // replies will go to this actor</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/MyActor.java#L27" target="_blank" title="Go to snippet source"></a><code class="language-java">getSender().tell(s, getSelf());</code></pre></dd>
</dl>
<h2><a href="#receive-timeout" name="receive-timeout" class="anchor"><span class="anchor-link"></span></a>Receive timeout</h2>
<p>The <code>ActorContext</code> <code>setReceiveTimeout</code> defines the inactivity timeout after which the sending of a <code>ReceiveTimeout</code> message is triggered. When specified, the receive function should be able to handle an <code>akka.actor.ReceiveTimeout</code> message. 1 millisecond is the minimum supported timeout.</p>
<p>Please note that the receive timeout might fire and enqueue the <code>ReceiveTimeout</code> message right after another message was enqueued; hence it is <strong>not guaranteed</strong> that upon reception of the receive timeout there must have been an idle period beforehand as configured via this method.</p>
<p>Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity periods). Pass in <code>Duration.Undefined</code> to switch off this feature.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L511-L525" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.ReceiveTimeout
import scala.concurrent.duration._
class MyActor extends Actor {
  // To set an initial delay
  context.setReceiveTimeout(30 milliseconds)
  def receive = {
    case &quot;Hello&quot; ⇒
      // To set in a response to a message
      context.setReceiveTimeout(100 milliseconds)
    case ReceiveTimeout ⇒
      // To turn it off
      context.setReceiveTimeout(Duration.Undefined)
      throw new RuntimeException(&quot;Receive timed out&quot;)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L540-L573" target="_blank" title="Go to snippet source"></a><code class="language-java">static class ReceiveTimeoutActor extends AbstractActor {
  public ReceiveTimeoutActor() {
    // To set an initial delay
    getContext().setReceiveTimeout(Duration.ofSeconds(10));
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;Hello&quot;,
            s -&gt; {
              // To set in a response to a message
              getContext().setReceiveTimeout(Duration.ofSeconds(1));
            })
        .match(
            ReceiveTimeout.class,
            r -&gt; {
              // To turn it off
              getContext().cancelReceiveTimeout();
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Messages marked with <code>NotInfluenceReceiveTimeout</code> will not reset the timer. This can be useful when <code>ReceiveTimeout</code> should be fired by external inactivity but not influenced by internal activity, e.g. scheduled tick messages.</p>
<a id="actors-timers"></a>
<h2><a href="#timers-scheduled-messages" name="timers-scheduled-messages" class="anchor"><span class="anchor-link"></span></a>Timers, scheduled messages</h2>
<p>Messages can be scheduled to be sent at a later point by using the <a href="scheduler.html">Scheduler</a> directly, but when scheduling periodic or single messages in an actor to itself it&rsquo;s more convenient and safe to use the support for named timers. The lifecycle of scheduled messages can be difficult to manage when the actor is restarted and that is taken care of by the timers.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/TimerDocSpec.scala#L9-L31" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._

import akka.actor.Actor
import akka.actor.Timers

object MyActor {
  private case object TickKey
  private case object FirstTick
  private case object Tick
}

class MyActor extends Actor with Timers {
  import MyActor._
  timers.startSingleTimer(TickKey, FirstTick, 500.millis)

  def receive = {
    case FirstTick ⇒
      // do something useful here
      timers.startPeriodicTimer(TickKey, Tick, 1.second)
    case Tick ⇒
    // do something useful here
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/TimerDocTest.java#L8-L45" target="_blank" title="Go to snippet source"></a><code class="language-java">import java.time.Duration;
import akka.actor.AbstractActorWithTimers;

static class MyActor extends AbstractActorWithTimers {

  private static Object TICK_KEY = &quot;TickKey&quot;;

  private static final class FirstTick {}

  private static final class Tick {}

  public MyActor() {
    getTimers().startSingleTimer(TICK_KEY, new FirstTick(), Duration.ofMillis(500));
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            FirstTick.class,
            message -&gt; {
              // do something useful here
              getTimers().startPeriodicTimer(TICK_KEY, new Tick(), Duration.ofSeconds(1));
            })
        .match(
            Tick.class,
            message -&gt; {
              // do something useful here
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Each timer has a key and can be replaced or cancelled. It&rsquo;s guaranteed that a message from the previous incarnation of the timer with the same key is not received, even though it might already be enqueued in the mailbox when it was cancelled or the new timer was started.</p>
<p>The timers are bound to the lifecycle of the actor that owns it, and thus are cancelled automatically when it is restarted or stopped. Note that the <code>TimerScheduler</code> is not thread-safe, i.e. it must only be used within the actor that owns it.</p>
<a id="stopping-actors"></a>
<h2><a href="#stopping-actors" name="stopping-actors" class="anchor"><span class="anchor-link"></span></a>Stopping actors</h2>
<p>Actors are stopped by invoking the <code>stop</code> method of a <code>ActorRefFactory</code>, i.e. <code>ActorContext</code> or <code>ActorSystem</code>. Typically the context is used for stopping the actor itself or child actors and the system for stopping top level actors. The actual termination of the actor is performed asynchronously, i.e. <code>stop</code> may return before the actor is stopped.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L161-L174" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyActor extends Actor {

  val child: ActorRef = ???

  def receive = {
    case &quot;interrupt-child&quot; ⇒
      context stop child

    case &quot;done&quot; ⇒
      context stop self
  }

}
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/MyStoppingActor.java#L8-L24" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorRef;
import akka.actor.AbstractActor;

public class MyStoppingActor extends AbstractActor {

  ActorRef child = null;

  // ... creation of child ...

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(&quot;interrupt-child&quot;, m -&gt; getContext().stop(child))
        .matchEquals(&quot;done&quot;, m -&gt; getContext().stop(getSelf()))
        .build();
  }
}</code></pre></dd>
</dl>
<p>Processing of the current message, if any, will continue before the actor is stopped, but additional messages in the mailbox will not be processed. By default these messages are sent to the <code>deadLetters</code> of the <code>ActorSystem</code>, but that depends on the mailbox implementation.</p>
<p>Termination of an actor proceeds in two steps: first the actor suspends its mailbox processing and sends a stop command to all its children, then it keeps processing the internal termination notifications from its children until the last one is gone, finally terminating itself (invoking <code>postStop</code>, dumping mailbox, publishing <code>Terminated</code> on the <a href="#deathwatch">DeathWatch</a>, telling its supervisor). This procedure ensures that actor system sub-trees terminate in an orderly fashion, propagating the stop command to the leaves and collecting their confirmation back to the stopped supervisor. If one of the actors does not respond (i.e. processing a message for extended periods of time and therefore not receiving the stop command), this whole process will be stuck.</p>
<p>Upon <code>ActorSystem.terminate()</code>, the system guardian actors will be stopped, and the aforementioned process will ensure proper termination of the whole system.</p>
<p>The <code>postStop()</code> hook is invoked after an actor is fully stopped. This enables cleaning up of resources:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L132-L136" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def postStop(): Unit = {
  ()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L306-L320" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public void postStop() {
  final String message = &quot;stopped&quot;;
  // don’t forget to think about who is the sender (2nd argument)
  target.tell(message, getSelf());
  final Object result = &quot;&quot;;
  target.forward(result, getContext());
  target = null;
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>Since stopping an actor is asynchronous, you cannot immediately reuse the name of the child you just stopped; this will result in an <code>InvalidActorNameException</code>. Instead, <code>watch()</code> the terminating actor and create its replacement in response to the <code>Terminated</code> message which will eventually arrive.</p></div>
<a id="poison-pill"></a>
<h3><a href="#poisonpill" name="poisonpill" class="anchor"><span class="anchor-link"></span></a>PoisonPill</h3>
<p>You can also send an actor the <code>akka.actor.PoisonPill</code> message, which will stop the actor when the message is processed. <code>PoisonPill</code> is enqueued as ordinary messages and will be handled after messages that were already queued in the mailbox.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L403-L404" target="_blank" title="Go to snippet source"></a><code class="language-scala">watch(victim)
victim ! PoisonPill</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L844" target="_blank" title="Go to snippet source"></a><code class="language-java">victim.tell(akka.actor.PoisonPill.getInstance(), ActorRef.noSender());</code></pre></dd>
</dl>
<a id="killing-actors"></a>
<h3><a href="#killing-an-actor" name="killing-an-actor" class="anchor"><span class="anchor-link"></span></a>Killing an Actor</h3>
<p>You can also &ldquo;kill&rdquo; an actor by sending a <code>Kill</code> message. Unlike <code>PoisonPill</code> this will cause the actor to throw a <code>ActorKilledException</code>, triggering a failure. The actor will suspend operation and its supervisor will be asked how to handle the failure, which may mean resuming the actor, restarting it or terminating it completely. See <a href="general/supervision.html#supervision-directives">What Supervision Means</a> for more information.</p>
<p>Use <code>Kill</code> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L604-L610" target="_blank" title="Go to snippet source"></a><code class="language-scala">context.watch(victim) // watch the Actor to receive Terminated message once it dies

victim ! Kill

expectMsgPF(hint = &quot;expecting victim to terminate&quot;) {
  case Terminated(v) if v == victim ⇒ v // the Actor has indeed terminated
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L828-L831" target="_blank" title="Go to snippet source"></a><code class="language-java">victim.tell(akka.actor.Kill.getInstance(), ActorRef.noSender());

// expecting the actor to indeed terminate:
expectTerminated(Duration.ofSeconds(3), victim);</code></pre></dd>
</dl>
<p>In general though it is not recommended to overly rely on either <code>PoisonPill</code> or <code>Kill</code> in designing your actor interactions, as often times a protocol-level message like <code>PleaseCleanupAndStop</code> which the actor knows how to handle is encouraged. The messages are there for being able to stop actors over which design you do not have control over.</p>
<h3><a href="#graceful-stop" name="graceful-stop" class="anchor"><span class="anchor-link"></span></a>Graceful Stop</h3>
<p><code>gracefulStop</code> is useful if you need to wait for termination or compose ordered termination of several actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L667-L677" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.pattern.gracefulStop
import scala.concurrent.Await

try {
  val stopped: Future[Boolean] = gracefulStop(actorRef, 5 seconds, Manager.Shutdown)
  Await.result(stopped, 6 seconds)
  // the actor has been stopped
} catch {
  // the actor wasn&#39;t stopped within 5 seconds
  case e: akka.pattern.AskTimeoutException ⇒
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L48-L51" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.gracefulStop;
import akka.pattern.AskTimeoutException;
import java.util.concurrent.CompletionStage;

try {
  CompletionStage&lt;Boolean&gt; stopped =
      gracefulStop(actorRef, Duration.ofSeconds(5), Manager.SHUTDOWN);
  stopped.toCompletableFuture().get(6, TimeUnit.SECONDS);
  // the actor has been stopped
} catch (AskTimeoutException e) {
  // the actor wasn&#39;t stopped within 5 seconds
}</code></pre></dd>
</dl>
<p>When <code>gracefulStop()</code> returns successfully, the actor’s <code>postStop()</code> hook will have been executed: there exists a happens-before edge between the end of <code>postStop()</code> and the return of <code>gracefulStop()</code>.</p>
<p>In the above example a custom <code>Manager.Shutdown</code> message is sent to the target actor to initiate the process of stopping the actor. You can use <code>PoisonPill</code> for this, but then you have limited possibilities to perform interactions with other actors before stopping the target actor. Simple cleanup tasks can be handled in <code>postStop</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Keep in mind that an actor stopping and its name being deregistered are separate events which happen asynchronously from each other. Therefore it may be that you will find the name still in use after <code>gracefulStop()</code> returned. In order to guarantee proper deregistration, only reuse names from within a supervisor you control and only in response to a <code>Terminated</code> message, i.e. not for top-level actors.</p></div>
<a id="coordinated-shutdown"></a>
<h3><a href="#coordinated-shutdown" name="coordinated-shutdown" class="anchor"><span class="anchor-link"></span></a>Coordinated Shutdown</h3>
<p>There is an extension named <code>CoordinatedShutdown</code> that will stop certain actors and services in a specific order and perform registered tasks during the shutdown process.</p>
<p>The order of the shutdown phases is defined in configuration <code>akka.coordinated-shutdown.phases</code>. The default phases are defined as:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor/src/main/resources/reference.conf#L1128-L1231" target="_blank" title="Go to snippet source"></a><code class="language-conf"># CoordinatedShutdown is enabled by default and will run the tasks that
# are added to these phases by individual Akka modules and user logic.
#
# The phases are ordered as a DAG by defining the dependencies between the phases
# to make sure shutdown tasks are run in the right order.
#
# In general user tasks belong in the first few phases, but there may be use
# cases where you would want to hook in new phases or register tasks later in
# the DAG.
#
# Each phase is defined as a named config section with the
# following optional properties:
# - timeout=15s: Override the default-phase-timeout for this phase.
# - recover=off: If the phase fails the shutdown is aborted
#                and depending phases will not be executed.
# - enabled=off: Skip all tasks registered in this phase. DO NOT use
#                this to disable phases unless you are absolutely sure what the
#                consequences are. Many of the built in tasks depend on other tasks
#                having been executed in earlier phases and may break if those are disabled.
# depends-on=[]: Run the phase after the given phases
phases {

  # The first pre-defined phase that applications can add tasks to.
  # Note that more phases can be added in the application&#39;s
  # configuration by overriding this phase with an additional
  # depends-on.
  before-service-unbind {
  }

  # Stop accepting new incoming connections.
  # This is where you can register tasks that makes a server stop accepting new connections. Already
  # established connections should be allowed to continue and complete if possible.
  service-unbind {
    depends-on = [before-service-unbind]
  }

  # Wait for requests that are in progress to be completed.
  # This is where you register tasks that will wait for already established connections to complete, potentially
  # also first telling them that it is time to close down.
  service-requests-done {
    depends-on = [service-unbind]
  }

  # Final shutdown of service endpoints.
  # This is where you would add tasks that forcefully kill connections that are still around.
  service-stop {
    depends-on = [service-requests-done]
  }

  # Phase for custom application tasks that are to be run
  # after service shutdown and before cluster shutdown.
  before-cluster-shutdown {
    depends-on = [service-stop]
  }

  # Graceful shutdown of the Cluster Sharding regions.
  # This phase is not meant for users to add tasks to.
  cluster-sharding-shutdown-region {
    timeout = 10 s
    depends-on = [before-cluster-shutdown]
  }

  # Emit the leave command for the node that is shutting down.
  # This phase is not meant for users to add tasks to.
  cluster-leave {
    depends-on = [cluster-sharding-shutdown-region]
  }

  # Shutdown cluster singletons
  # This is done as late as possible to allow the shard region shutdown triggered in
  # the &quot;cluster-sharding-shutdown-region&quot; phase to complete before the shard coordinator is shut down.
  # This phase is not meant for users to add tasks to.
  cluster-exiting {
    timeout = 10 s
    depends-on = [cluster-leave]
  }

  # Wait until exiting has been completed
  # This phase is not meant for users to add tasks to.
  cluster-exiting-done {
    depends-on = [cluster-exiting]
  }

  # Shutdown the cluster extension
  # This phase is not meant for users to add tasks to.
  cluster-shutdown {
    depends-on = [cluster-exiting-done]
  }

  # Phase for custom application tasks that are to be run
  # after cluster shutdown and before ActorSystem termination.
  before-actor-system-terminate {
    depends-on = [cluster-shutdown]
  }

  # Last phase. See terminate-actor-system and exit-jvm above.
  # Don&#39;t add phases that depends on this phase because the
  # dispatcher and scheduler of the ActorSystem have been shutdown.
  # This phase is not meant for users to add tasks to.
  actor-system-terminate {
    timeout = 10 s
    depends-on = [before-actor-system-terminate]
  }
}</code></pre>
<p>More phases can be added in the application&rsquo;s configuration if needed by overriding a phase with an additional <code>depends-on</code>. Especially the phases <code>before-service-unbind</code>, <code>before-cluster-shutdown</code> and <code>before-actor-system-terminate</code> are intended for application specific phases or tasks.</p>
<p>The default phases are defined in a single linear order, but the phases can be ordered as a directed acyclic graph (DAG) by defining the dependencies between the phases. The phases are ordered with <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological</a> sort of the DAG.</p>
<p>Tasks can be added to a phase with:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L741-L747" target="_blank" title="Go to snippet source"></a><code class="language-scala">CoordinatedShutdown(system).addTask(
  CoordinatedShutdown.PhaseBeforeServiceUnbind, &quot;someTaskName&quot;) { () ⇒
    import akka.pattern.ask
    import system.dispatcher
    implicit val timeout = Timeout(5.seconds)
    (someActor ? &quot;stop&quot;).map(_ ⇒ Done)
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L855-L862" target="_blank" title="Go to snippet source"></a><code class="language-java">CoordinatedShutdown.get(system)
    .addTask(
        CoordinatedShutdown.PhaseBeforeServiceUnbind(),
        &quot;someTaskName&quot;,
        () -&gt; {
          return akka.pattern.Patterns.ask(someActor, &quot;stop&quot;, Duration.ofSeconds(5))
              .thenApply(reply -&gt; Done.getInstance());
        });</code></pre></dd>
</dl>
<p>The returned <span class="group-scala"><code>Future[Done]</code></span> <span class="group-java"><code>CompletionStage&lt;Done&gt;</code></span> should be completed when the task is completed. The task name parameter is only used for debugging/logging.</p>
<p>Tasks added to the same phase are executed in parallel without any ordering assumptions. Next phase will not start until all tasks of previous phase have been completed.</p>
<p>If tasks are not completed within a configured timeout (see <a href="general/configuration.html#config-akka-actor">reference.conf</a>) the next phase will be started anyway. It is possible to configure <code>recover=off</code> for a phase to abort the rest of the shutdown process if a task fails or is not completed within the timeout.</p>
<p>Tasks should typically be registered as early as possible after system startup. When running the coordinated shutdown tasks that have been registered will be performed but tasks that are added too late will not be run.</p>
<p>To start the coordinated shutdown process you can invoke <span class="group-scala"><code>run</code></span> <span class="group-java"><code>runAll</code></span> on the <code>CoordinatedShutdown</code> extension:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L759" target="_blank" title="Go to snippet source"></a><code class="language-scala">val done: Future[Done] = CoordinatedShutdown(system).run(CoordinatedShutdown.UnknownReason)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L873-L874" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletionStage&lt;Done&gt; done =
    CoordinatedShutdown.get(system).runAll(CoordinatedShutdown.unknownReason());</code></pre></dd>
</dl>
<p>It&rsquo;s safe to call the <span class="group-scala"><code>run</code></span> <span class="group-java"><code>runAll</code></span> method multiple times. It will only run once.</p>
<p>That also means that the <code>ActorSystem</code> will be terminated in the last phase. By default, the JVM is not forcefully stopped (it will be stopped if all non-daemon threads have been terminated). To enable a hard <code>System.exit</code> as a final action you can configure:</p>
<pre><code>akka.coordinated-shutdown.exit-jvm = on
</code></pre>
<p>When using <a href="cluster-usage.html">Akka Cluster</a> the <code>CoordinatedShutdown</code> will automatically run when the cluster node sees itself as <code>Exiting</code>, i.e. leaving from another node will trigger the shutdown process on the leaving node. Tasks for graceful leaving of cluster including graceful shutdown of Cluster Singletons and Cluster Sharding are added automatically when Akka Cluster is used, i.e. running the shutdown process will also trigger the graceful leaving if it&rsquo;s not already in progress.</p>
<p>By default, the <code>CoordinatedShutdown</code> will be run when the JVM process exits, e.g. via <code>kill SIGTERM</code> signal (<code>SIGINT</code> ctrl-c doesn&rsquo;t work). This behavior can be disabled with:</p>
<pre><code>akka.coordinated-shutdown.run-by-jvm-shutdown-hook=off
</code></pre>
<p>If you have application specific JVM shutdown hooks it&rsquo;s recommended that you register them via the <code>CoordinatedShutdown</code> so that they are running before Akka internal shutdown hooks, e.g. those shutting down Akka Remoting (Artery).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L751-L753" target="_blank" title="Go to snippet source"></a><code class="language-scala">CoordinatedShutdown(system).addJvmShutdownHook {
  println(&quot;custom JVM shutdown hook...&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L866-L867" target="_blank" title="Go to snippet source"></a><code class="language-java">CoordinatedShutdown.get(system)
    .addJvmShutdownHook(() -&gt; System.out.println(&quot;custom JVM shutdown hook...&quot;));</code></pre></dd>
</dl>
<p>For some tests it might be undesired to terminate the <code>ActorSystem</code> via <code>CoordinatedShutdown</code>. You can disable that by adding the following to the configuration of the <code>ActorSystem</code> that is used in the test:</p>
<pre><code># Don&#39;t terminate ActorSystem via CoordinatedShutdown in tests
akka.coordinated-shutdown.terminate-actor-system = off
akka.coordinated-shutdown.run-by-jvm-shutdown-hook = off
akka.cluster.run-coordinated-shutdown-when-down = off
</code></pre>
<a id="actor-hotswap"></a>
<h2><a href="#become-unbecome" name="become-unbecome" class="anchor"><span class="anchor-link"></span></a>Become/Unbecome</h2>
<h3><a href="#upgrade" name="upgrade" class="anchor"><span class="anchor-link"></span></a>Upgrade</h3>
<p>Akka supports hotswapping the Actor’s message loop (e.g. its implementation) at runtime: invoke the <code>context.become</code> method from within the Actor. <code>become</code> takes a <span class="group-scala"><code>PartialFunction[Any, Unit]</code></span> <span class="group-java"><code>PartialFunction&lt;Object, BoxedUnit&gt;</code></span> that implements the new message handler. The hotswapped code is kept in a Stack which can be pushed and popped.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Please note that the actor will revert to its original behavior when restarted by its Supervisor.</p></div>
<p>To hotswap the Actor behavior using <code>become</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L530-L546" target="_blank" title="Go to snippet source"></a><code class="language-scala">class HotSwapActor extends Actor {
  import context._
  def angry: Receive = {
    case &quot;foo&quot; ⇒ sender() ! &quot;I am already angry?&quot;
    case &quot;bar&quot; ⇒ become(happy)
  }

  def happy: Receive = {
    case &quot;bar&quot; ⇒ sender() ! &quot;I am already happy :-)&quot;
    case &quot;foo&quot; ⇒ become(angry)
  }

  def receive = {
    case &quot;foo&quot; ⇒ become(angry)
    case &quot;bar&quot; ⇒ become(happy)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L590-L631" target="_blank" title="Go to snippet source"></a><code class="language-java">static class HotSwapActor extends AbstractActor {
  private AbstractActor.Receive angry;
  private AbstractActor.Receive happy;

  public HotSwapActor() {
    angry =
        receiveBuilder()
            .matchEquals(
                &quot;foo&quot;,
                s -&gt; {
                  getSender().tell(&quot;I am already angry?&quot;, getSelf());
                })
            .matchEquals(
                &quot;bar&quot;,
                s -&gt; {
                  getContext().become(happy);
                })
            .build();

    happy =
        receiveBuilder()
            .matchEquals(
                &quot;bar&quot;,
                s -&gt; {
                  getSender().tell(&quot;I am already happy :-)&quot;, getSelf());
                })
            .matchEquals(
                &quot;foo&quot;,
                s -&gt; {
                  getContext().become(angry);
                })
            .build();
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(&quot;foo&quot;, s -&gt; getContext().become(angry))
        .matchEquals(&quot;bar&quot;, s -&gt; getContext().become(happy))
        .build();
  }
}</code></pre></dd>
</dl>
<p>This variant of the <code>become</code> method is useful for many different things, such as to implement a Finite State Machine (FSM, for an example see <span class="group-scala"><a href="http://www.lightbend.com/activator/template/akka-sample-fsm-scala">Dining Hakkers</a>).</span> <span class="group-java"><a href="http://www.lightbend.com/activator/template/akka-sample-fsm-java-lambda">Dining Hakkers</a>).</span> It will replace the current behavior (i.e. the top of the behavior stack), which means that you do not use <code>unbecome</code>, instead always the next behavior is explicitly installed.</p>
<p>The other way of using <code>become</code> does not replace but add to the top of the behavior stack. In this case care must be taken to ensure that the number of “pop” operations (i.e. <code>unbecome</code>) matches the number of “push” ones in the long run, otherwise this amounts to a memory leak (which is why this behavior is not the default).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L209-L234" target="_blank" title="Go to snippet source"></a><code class="language-scala">case object Swap
class Swapper extends Actor {
  import context._
  val log = Logging(system, this)

  def receive = {
    case Swap ⇒
      log.info(&quot;Hi&quot;)
      become({
        case Swap ⇒
          log.info(&quot;Ho&quot;)
          unbecome() // resets the latest &#39;become&#39; (just for fun)
      }, discardOld = false) // push on top instead of replace
  }
}

object SwapperApp extends App {
  val system = ActorSystem(&quot;SwapperSystem&quot;)
  val swap = system.actorOf(Props[Swapper], name = &quot;swapper&quot;)
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L433-L473" target="_blank" title="Go to snippet source"></a><code class="language-java">static class Swapper extends AbstractLoggingActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            Swap,
            s -&gt; {
              log().info(&quot;Hi&quot;);
              getContext()
                  .become(
                      receiveBuilder()
                          .matchEquals(
                              Swap,
                              x -&gt; {
                                log().info(&quot;Ho&quot;);
                                getContext()
                                    .unbecome(); // resets the latest &#39;become&#39; (just for fun)
                              })
                          .build(),
                      false); // push on top instead of replace
            })
        .build();
  }
}

static class SwapperApp {
  public static void main(String[] args) {
    ActorSystem system = ActorSystem.create(&quot;SwapperSystem&quot;);
    ActorRef swapper = system.actorOf(Props.create(Swapper.class), &quot;swapper&quot;);
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    swapper.tell(Swap, ActorRef.noSender()); // logs Hi
    swapper.tell(Swap, ActorRef.noSender()); // logs Ho
    system.terminate();
  }
}</code></pre></dd>
</dl>
<h3><a href="#encoding-scala-actors-nested-receives-without-accidentally-leaking-memory" name="encoding-scala-actors-nested-receives-without-accidentally-leaking-memory" class="anchor"><span class="anchor-link"></span></a>Encoding Scala Actors nested receives without accidentally leaking memory</h3>
<p>See this <a href="http://github.com/akka/akka/tree/master/akka-docs/src/test/scala/docs/actor/UnnestedReceives.scala">Unnested receive example</a>.</p>
<a id="stash"></a>
<h2><a href="#stash" name="stash" class="anchor"><span class="anchor-link"></span></a>Stash</h2>
<p>The <span class="group-scala"><code>Stash</code> trait</span> <span class="group-java"><code>AbstractActorWithStash</code> class</span> enables an actor to temporarily stash away messages that can not or should not be handled using the actor&rsquo;s current behavior. Upon changing the actor&rsquo;s message handler, i.e., right before invoking <span class="group-scala"><code>context.become</code> or <code>context.unbecome</code></span> <span class="group-java"><code>getContext().become()</code> or <code>getContext().unbecome()</code></span>, all stashed messages can be &ldquo;unstashed&rdquo;, thereby prepending them to the actor&rsquo;s mailbox. This way, the stashed messages can be processed in the same order as they have been received originally. <span class="group-java">An actor that extends <code>AbstractActorWithStash</code> will automatically get a deque-based mailbox.</span></p><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>The trait <code>Stash</code> extends the marker trait <code>RequiresMessageQueue[DequeBasedMessageQueueSemantics]</code> which requests the system to automatically choose a deque based mailbox implementation for the actor. If you want more control over the mailbox, see the documentation on mailboxes: <a href="mailboxes.html">Mailboxes</a>.</p></div><div class="callout note group-java"><div class="callout-title">Note</div>
<p>The abstract class <code>AbstractActorWithStash</code> implements the marker interface <code>RequiresMessageQueue&lt;DequeBasedMessageQueueSemantics&gt;</code> which requests the system to automatically choose a deque based mailbox implementation for the actor. If you want more control over the mailbox, see the documentation on mailboxes: <a href="mailboxes.html">Mailboxes</a>.</p></div>
<p>Here is an example of the <span class="group-scala"><code>Stash</code></span> <span class="group-java"><code>AbstractActorWithStash</code> class</span> in action:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L555-L569" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Stash
class ActorWithProtocol extends Actor with Stash {
  def receive = {
    case &quot;open&quot; ⇒
      unstashAll()
      context.become({
        case &quot;write&quot; ⇒ // do writing...
        case &quot;close&quot; ⇒
          unstashAll()
          context.unbecome()
        case msg ⇒ stash()
      }, discardOld = false) // stack on top instead of replacing
    case msg ⇒ stash()
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/ActorDocTest.java#L655-L683" target="_blank" title="Go to snippet source"></a><code class="language-java">static class ActorWithProtocol extends AbstractActorWithStash {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchEquals(
            &quot;open&quot;,
            s -&gt; {
              getContext()
                  .become(
                      receiveBuilder()
                          .matchEquals(
                              &quot;write&quot;,
                              ws -&gt; {
                                /* do writing */
                              })
                          .matchEquals(
                              &quot;close&quot;,
                              cs -&gt; {
                                unstashAll();
                                getContext().unbecome();
                              })
                          .matchAny(msg -&gt; stash())
                          .build(),
                      false);
            })
        .matchAny(msg -&gt; stash())
        .build();
  }
}</code></pre></dd>
</dl>
<p>Invoking <code>stash()</code> adds the current message (the message that the actor received last) to the actor&rsquo;s stash. It is typically invoked when handling the default case in the actor&rsquo;s message handler to stash messages that aren&rsquo;t handled by the other cases. It is illegal to stash the same message twice; to do so results in an <code>IllegalStateException</code> being thrown. The stash may also be bounded in which case invoking <code>stash()</code> may lead to a capacity violation, which results in a <code>StashOverflowException</code>. The capacity of the stash can be configured using the <code>stash-capacity</code> setting (an <code>Int</code>) of the mailbox&rsquo;s configuration.</p>
<p>Invoking <code>unstashAll()</code> enqueues messages from the stash to the actor&rsquo;s mailbox until the capacity of the mailbox (if any) has been reached (note that messages from the stash are prepended to the mailbox). In case a bounded mailbox overflows, a <code>MessageQueueAppendFailedException</code> is thrown. The stash is guaranteed to be empty after calling <code>unstashAll()</code>.</p>
<p>The stash is backed by a <code>scala.collection.immutable.Vector</code>. As a result, even a very large number of messages may be stashed without a major impact on performance.</p><div class="callout warning group-scala"><div class="callout-title">Warning</div>
<p>Note that the <code>Stash</code> trait must be mixed into (a subclass of) the <code>Actor</code> trait before any trait/class that overrides the <code>preRestart</code> callback. This means it&rsquo;s not possible to write <code>Actor with MyActor with Stash</code> if <code>MyActor</code> overrides <code>preRestart</code>.</p></div>
<p>Note that the stash is part of the ephemeral actor state, unlike the mailbox. Therefore, it should be managed like other parts of the actor&rsquo;s state which have the same property. The <span class="group-scala"><code>Stash</code> trait’s</span> <span class="group-java"><code>AbstractActorWithStash</code></span> implementation of <code>preRestart</code> will call <code>unstashAll()</code>, which is usually the desired behavior.</p><div class="callout note "><div class="callout-title">Note</div>
<p>If you want to enforce that your actor can only work with an unbounded stash, then you should use the <span class="group-scala"><code>UnboundedStash</code> trait</span> <span class="group-java"><code>AbstractActorWithUnboundedStash</code> class</span> instead.</p></div>
<h2><a href="#actors-and-exceptions" name="actors-and-exceptions" class="anchor"><span class="anchor-link"></span></a>Actors and exceptions</h2>
<p>It can happen that while a message is being processed by an actor, that some kind of exception is thrown, e.g. a database exception.</p>
<h3><a href="#what-happens-to-the-message" name="what-happens-to-the-message" class="anchor"><span class="anchor-link"></span></a>What happens to the Message</h3>
<p>If an exception is thrown while a message is being processed (i.e. taken out of its mailbox and handed over to the current behavior), then this message will be lost. It is important to understand that it is not put back on the mailbox. So if you want to retry processing of a message, you need to deal with it yourself by catching the exception and retry your flow. Make sure that you put a bound on the number of retries since you don&rsquo;t want a system to livelock (so consuming a lot of cpu cycles without making progress).</p>
<h3><a href="#what-happens-to-the-mailbox" name="what-happens-to-the-mailbox" class="anchor"><span class="anchor-link"></span></a>What happens to the mailbox</h3>
<p>If an exception is thrown while a message is being processed, nothing happens to the mailbox. If the actor is restarted, the same mailbox will be there. So all messages on that mailbox will be there as well.</p>
<h3><a href="#what-happens-to-the-actor" name="what-happens-to-the-actor" class="anchor"><span class="anchor-link"></span></a>What happens to the actor</h3>
<p>If code within an actor throws an exception, that actor is suspended and the supervision process is started (see <a href="general/supervision.html">supervision</a>). Depending on the supervisor’s decision the actor is resumed (as if nothing happened), restarted (wiping out its internal state and starting from scratch) or terminated.</p><div class="group-scala">
<h2><a href="#extending-actors-using-partialfunction-chaining" name="extending-actors-using-partialfunction-chaining" class="anchor"><span class="anchor-link"></span></a>Extending Actors using PartialFunction chaining</h2>
<p>Sometimes it can be useful to share common behavior among a few actors, or compose one actor&rsquo;s behavior from multiple smaller functions. This is possible because an actor&rsquo;s <code>receive</code> method returns an <code>Actor.Receive</code>, which is a type alias for <code>PartialFunction[Any,Unit]</code>, and partial functions can be chained together using the <code>PartialFunction#orElse</code> method. You can chain as many functions as you need, however you should keep in mind that &ldquo;first match&rdquo; wins - which may be important when combining functions that both can handle the same type of message.</p>
<p>For example, imagine you have a set of actors which are either <code>Producers</code> or <code>Consumers</code>, yet sometimes it makes sense to have an actor share both behaviors. This can be achieved without having to duplicate code by extracting the behaviors to traits and implementing the actor&rsquo;s <code>receive</code> as combination of these partial functions.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/ActorDocSpec.scala#L238-L277" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>trait ProducerBehavior {
  this: Actor ⇒

  val producerBehavior: Receive = {
    case GiveMeThings ⇒
      sender() ! Give(&quot;thing&quot;)
  }
}

trait ConsumerBehavior {
  this: Actor with ActorLogging ⇒

  val consumerBehavior: Receive = {
    case ref: ActorRef ⇒
      ref ! GiveMeThings

    case Give(thing) ⇒
      log.info(&quot;Got a thing! It&#39;s {}&quot;, thing)
  }
}

class Producer extends Actor with ProducerBehavior {
  def receive = producerBehavior
}

class Consumer extends Actor with ActorLogging with ConsumerBehavior {
  def receive = consumerBehavior
}

class ProducerConsumer extends Actor with ActorLogging
  with ProducerBehavior with ConsumerBehavior {

  def receive = producerBehavior.orElse[Any, Unit](consumerBehavior)
}

// protocol
case object GiveMeThings
final case class Give(thing: Any)
</code></pre>
<p>Instead of inheritance the same pattern can be applied via composition - compose the receive method using partial functions from delegates.</p></div>
<h2><a href="#initialization-patterns" name="initialization-patterns" class="anchor"><span class="anchor-link"></span></a>Initialization patterns</h2>
<p>The rich lifecycle hooks of Actors provide a useful toolkit to implement various initialization patterns. During the lifetime of an <code>ActorRef</code>, an actor can potentially go through several restarts, where the old instance is replaced by a fresh one, invisibly to the outside observer who only sees the <code>ActorRef</code>.</p>
<p>Initialization might be necessary every time an actor is instantiated, but sometimes one needs initialization to happen only at the birth of the first instance when the <code>ActorRef</code> is created. The following sections provide patterns for different initialization needs.</p>
<h3><a href="#initialization-via-constructor" name="initialization-via-constructor" class="anchor"><span class="anchor-link"></span></a>Initialization via constructor</h3>
<p>Using the constructor for initialization has various benefits. First of all, it makes it possible to use <code>val</code> fields to store any state that does not change during the life of the actor instance, making the implementation of the actor more robust. The constructor is invoked when an actor instance is created calling <code>actorOf</code> and also on restart, therefore the internals of the actor can always assume that proper initialization happened. This is also the drawback of this approach, as there are cases when one would like to avoid reinitializing internals on restart. For example, it is often useful to preserve child actors across restarts. The following section provides a pattern for this case.</p>
<h3><a href="#initialization-via-prestart" name="initialization-via-prestart" class="anchor"><span class="anchor-link"></span></a>Initialization via preStart</h3>
<p>The method <code>preStart()</code> of an actor is only called once directly during the initialization of the first instance, that is, at creation of its <code>ActorRef</code>. In the case of restarts, <code>preStart()</code> is called from <code>postRestart()</code>, therefore if not overridden, <code>preStart()</code> is called on every restart. However, by overriding <code>postRestart()</code> one can disable this behavior, and ensure that there is only one call to <code>preStart()</code>.</p>
<p>One useful usage of this pattern is to disable creation of new <code>ActorRefs</code> for children during restarts. This can be achieved by overriding <code>preRestart()</code>. Below is the default implementation of these lifecycle hooks:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/InitializationDocSpec.scala#L18-L32" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def preStart(): Unit = {
  // Initialize children here
}

// Overriding postRestart to disable the call to preStart()
// after restarts
override def postRestart(reason: Throwable): Unit = ()

// The default implementation of preRestart() stops all the children
// of the actor. To opt-out from stopping the children, we
// have to override preRestart()
override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
  // Keep the call to postStop(), but no stopping of children
  postStop()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/InitializationDocTest.java#L43-L60" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public void preStart() {
  // Initialize children here
}

// Overriding postRestart to disable the call to preStart()
// after restarts
@Override
public void postRestart(Throwable reason) {}

// The default implementation of preRestart() stops all the children
// of the actor. To opt-out from stopping the children, we
// have to override preRestart()
@Override
public void preRestart(Throwable reason, Optional&lt;Object&gt; message) throws Exception {
  // Keep the call to postStop(), but no stopping of children
  postStop();
}</code></pre></dd>
</dl>
<p>Please note, that the child actors are <em>still restarted</em>, but no new <code>ActorRef</code> is created. One can recursively apply the same principles for the children, ensuring that their <code>preStart()</code> method is called only at the creation of their refs.</p>
<p>For more information see <a href="general/supervision.html#supervision-restart">What Restarting Means</a>.</p>
<h3><a href="#initialization-via-message-passing" name="initialization-via-message-passing" class="anchor"><span class="anchor-link"></span></a>Initialization via message passing</h3>
<p>There are cases when it is impossible to pass all the information needed for actor initialization in the constructor, for example in the presence of circular dependencies. In this case the actor should listen for an initialization message, and use <code>become()</code> or a finite state-machine state transition to encode the initialized and uninitialized states of the actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/InitializationDocSpec.scala#L38-L49" target="_blank" title="Go to snippet source"></a><code class="language-scala">var initializeMe: Option[String] = None

override def receive = {
  case &quot;init&quot; ⇒
    initializeMe = Some(&quot;Up and running&quot;)
    context.become(initialized, discardOld = true)

}

def initialized: Receive = {
  case &quot;U OK?&quot; ⇒ initializeMe foreach { sender() ! _ }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/InitializationDocTest.java#L69-L87" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public Receive createReceive() {
  return receiveBuilder()
      .matchEquals(
          &quot;init&quot;,
          m1 -&gt; {
            initializeMe = &quot;Up and running&quot;;
            getContext()
                .become(
                    receiveBuilder()
                        .matchEquals(
                            &quot;U OK?&quot;,
                            m2 -&gt; {
                              getSender().tell(initializeMe, getSelf());
                            })
                        .build());
          })
      .build();
}</code></pre></dd>
</dl>
<p>If the actor may receive messages before it has been initialized, a useful tool can be the <code>Stash</code> to save messages until the initialization finishes, and replaying them after the actor became initialized.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>This pattern should be used with care, and applied only when none of the patterns above are applicable. One of the potential issues is that messages might be lost when sent to remote actors. Also, publishing an <code>ActorRef</code> in an uninitialized state might lead to the condition that it receives a user message before the initialization has been done.</p></div>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="index-actors.html"><i class="icon-prev"></i> <span class="link-prev">Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="fault-tolerance.html">Fault Tolerance <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/actors.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
