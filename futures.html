<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Futures &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/futures.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="futures.html#dependency" class="header">Dependency</a></li>
      <li><a href="futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="futures.html#use-with-actors" class="header">Use with Actors</a></li>
      <li><a href="futures.html#use-the-pipe-pattern" class="header">Use the pipe pattern</a></li>
      <li><a href="futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="futures.html#define-ordering" class="header">Define Ordering</a></li>
      <li><a href="futures.html#auxiliary-methods" class="header">Auxiliary Methods</a></li>
      <li><a href="futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="futures.html#after" class="header">After</a></li>
      <li><a href="futures.html#retry" class="header">Retry</a></li>
      <li><a href="futures.html#java-8-completionstage-and-completablefuture" class="header group-java">Java 8, CompletionStage and CompletableFuture</a></li>
    </ul></li>
    <li><a href="agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a>
  <ul>
    <li><a href="futures.html#futures" class="active page">Futures</a>
    <ul>
      <li><a href="futures.html#dependency" class="header">Dependency</a></li>
      <li><a href="futures.html#introduction" class="header">Introduction</a></li>
      <li><a href="futures.html#execution-contexts" class="header">Execution Contexts</a></li>
      <li><a href="futures.html#use-with-actors" class="header">Use with Actors</a></li>
      <li><a href="futures.html#use-the-pipe-pattern" class="header">Use the pipe pattern</a></li>
      <li><a href="futures.html#use-directly" class="header">Use Directly</a></li>
      <li><a href="futures.html#functional-futures" class="header">Functional Futures</a></li>
      <li><a href="futures.html#callbacks" class="header">Callbacks</a></li>
      <li><a href="futures.html#define-ordering" class="header">Define Ordering</a></li>
      <li><a href="futures.html#auxiliary-methods" class="header">Auxiliary Methods</a></li>
      <li><a href="futures.html#exceptions" class="header">Exceptions</a></li>
      <li><a href="futures.html#after" class="header">After</a></li>
      <li><a href="futures.html#retry" class="header">Retry</a></li>
      <li><a href="futures.html#java-8-completionstage-and-completablefuture" class="header group-java">Java 8, CompletionStage and CompletableFuture</a></li>
    </ul></li>
    <li><a href="agents.html" class="page">Agents</a></li>
  </ul></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#futures" name="futures" class="anchor"><span class="anchor-link"></span></a>Futures</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>This section explains using plain Scala Futures but focuses on their interop with Akka Actors, so to follow those examples you will want to depend on:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>In the Scala Standard Library, a <a href="http://en.wikipedia.org/wiki/Futures_and_promises">Future</a> is a data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking).</p><div class="group-java">
<p>To be able to use this from Java, Akka provides a java friendly interface in <code>akka.dispatch.Futures</code>.</p>
<p>See also <a href="java8-compat.html">Java 8 Compatibility</a> for Java compatibility.</p></div>
<h2><a href="#execution-contexts" name="execution-contexts" class="anchor"><span class="anchor-link"></span></a>Execution Contexts</h2>
<p>In order to execute callbacks and operations, Futures need something called an <code>ExecutionContext</code>, which is very similar to a <code>java.util.concurrent.Executor</code>. if you have an <code>ActorSystem</code> in scope, it will use its default dispatcher as the <code>ExecutionContext</code>, or you can use the factory methods provided by the <span class="group-scala"><code>ExecutionContext</code> companion object</span><span class="group-java"><code>ExecutionContexts</code> class</span> to wrap <code>Executors</code> and <code>ExecutorServices</code>, or even create your own.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L139-L148" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.{ ExecutionContext, Promise }

implicit val ec = ExecutionContext.fromExecutorService(yourExecutorServiceGoesHere)

// Do stuff with your brand new shiny ExecutionContext
val f = Promise.successful(&quot;foo&quot;)

// Then shut your ExecutionContext down at some
// appropriate place in your program/application
ec.shutdown()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L8-L15" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.dispatch.*;
import jdocs.AbstractJavaTest;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;
import scala.concurrent.Await;
import scala.concurrent.Promise;
import akka.util.Timeout;

ExecutionContext ec = ExecutionContexts.fromExecutorService(yourExecutorServiceGoesHere);

// Use ec with your Futures
Future&lt;String&gt; f1 = Futures.successful(&quot;foo&quot;);

// Then you shut down the ExecutorService at the end of your application.
yourExecutorServiceGoesHere.shutdown();</code></pre></dd>
</dl>
<h3><a href="#within-actors" name="within-actors" class="anchor"><span class="anchor-link"></span></a>Within Actors</h3>
<p>Each actor is configured to be run on a <code>MessageDispatcher</code>, and that dispatcher doubles as an <code>ExecutionContext</code>. If the nature of the Future calls invoked by the actor matches or is compatible with the activities of that actor (e.g. all CPU bound and no latency requirements), then it may be easiest to reuse the dispatcher for running the Futures by importing <span class="group-scala"><code>context.dispatcher</code></span><span class="group-java"><code>getContext().getDispatcher()</code></span>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L518-L526" target="_blank" title="Go to snippet source"></a><code class="language-scala">class A extends Actor {
  import context.dispatcher
  val f = Future(&quot;hello&quot;)
  def receive = {
    case _ ⇒
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/ActorWithFuture.java#L8-L20" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractActor;
import akka.dispatch.Futures;

public class ActorWithFuture extends AbstractActor {
  ActorWithFuture() {
    Futures.future(() -&gt; &quot;hello&quot;, getContext().dispatcher());
  }

  @Override
  public Receive createReceive() {
    return AbstractActor.emptyBehavior();
  }
}</code></pre></dd>
</dl>
<h2><a href="#use-with-actors" name="use-with-actors" class="anchor"><span class="anchor-link"></span></a>Use with Actors</h2>
<p>There are generally two ways of getting a reply from an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span>: the first is by a sent message (<span class="group-scala"><code>actor ! msg</code></span><span class="group-java"><code>actorRef.tell(msg, sender)</code></span>), which only works if the original sender was an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span>) and the second is through a <code>Future</code>.</p>
<p>Using <span class="group-scala">an <code>Actor</code>&rsquo;s <code>?</code></span><span class="group-java">the <code>ActorRef</code>&rsquo;s <code>ask</code></span> method to send a message will return a <code>Future</code>. To wait for and retrieve the actual result the simplest method is:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L156-L163" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.Await
import akka.pattern.ask
import akka.util.Timeout
import scala.concurrent.duration._

implicit val timeout = Timeout(5 seconds)
val future = actor ? msg // enabled by the “ask” import
val result = Await.result(future, timeout.duration).asInstanceOf[String]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L8-L15" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.dispatch.*;
import jdocs.AbstractJavaTest;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;
import scala.concurrent.Await;
import scala.concurrent.Promise;
import akka.util.Timeout;

Timeout timeout = Timeout.create(Duration.ofSeconds(5));
Future&lt;Object&gt; future = Patterns.ask(actor, msg, timeout);
String result = (String) Await.result(future, timeout.duration());</code></pre></dd>
</dl>
<p>This will cause the current thread to block and wait for the <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span> to &lsquo;complete&rsquo; the <code>Future</code> with its reply. Blocking is discouraged though as it will cause performance problems. The blocking operations are located in <code>Await.result</code> and <code>Await.ready</code> to make it easy to spot where blocking occurs. Alternatives to blocking are discussed further within this documentation. Also note that the <code>Future</code> returned by an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span> is a <span class="group-scala"><code>Future[Any]</code></span><span class="group-java"><code>Future&lt;Object&gt;</code></span> since an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span> is dynamic. That is why the <span class="group-scala"><code>asInstanceOf</code></span><span class="group-java">cast to <code>String</code></span> is used in the above sample.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p><code>Await.result</code> and <code>Await.ready</code> are provided for exceptional situations where you <strong>must</strong> block, a good rule of thumb is to only use them if you know why you <strong>must</strong> block. For all other cases, use asynchronous composition as described below.</p></div><div class="group-scala">
<p>When using non-blocking it is better to use the <code>mapTo</code> method to safely try to cast a <code>Future</code> to an expected type:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L174-L177" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.Future
import akka.pattern.ask

val future: Future[String] = ask(actor, msg).mapTo[String]</code></pre>
<p>The <code>mapTo</code> method will return a new <code>Future</code> that contains the result if the cast was successful, or a <code>ClassCastException</code> if not. Handling <code>Exception</code>s will be discussed further within this documentation.</p></div>
<h2><a href="#use-the-pipe-pattern" name="use-the-pipe-pattern" class="anchor"><span class="anchor-link"></span></a>Use the pipe pattern</h2>
<p>Another useful message-transfer pattern is &ldquo;pipe&rdquo;, which is to send the result of <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletableFuture</code></span> to another actor, upon completion of the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletableFuture</code></span>. The pipe pattern can be used by importing <span class="group-java"><code>akka.pattern.Patterns.pipe</code>.</span><span class="group-scala"><code>akka.pattern.pipe</code>, and define or import an implicit instance of <code>ExecutionContext</code> in the scope.</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L39-L51" target="_blank" title="Go to snippet source"></a><code class="language-scala">class ActorUsingPipeTo(target: ActorRef) extends Actor {
  // akka.pattern.pipe needs to be imported
  import akka.pattern.{ ask, pipe }
  // implicit ExecutionContext should be in scope
  implicit val ec: ExecutionContext = context.dispatcher
  implicit val timeout: Timeout = 5.seconds

  def receive = {
    case _ ⇒
      val future = target ? &quot;some message&quot;
      future pipeTo sender() // use the pipe pattern
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L65" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.ask;
import static akka.pattern.Patterns.pipe;
public class ActorUsingPipeTo extends AbstractActor {
  ActorRef target;
  Duration timeout;

  ActorUsingPipeTo(ActorRef target) {
    this.target = target;
    this.timeout = Duration.ofSeconds(5);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            String.class,
            msg -&gt; {
              CompletableFuture&lt;Object&gt; fut =
                  ask(target, &quot;some message&quot;, timeout).toCompletableFuture();

              // the pipe pattern
              pipe(fut, getContext().dispatcher()).to(getSender());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>To see how this works in more detail, let&rsquo;s introduce a small example consisting of three different actors, <code>UserProxyActor</code>, <code>UserDataActor</code> and <code>UserActivityActor</code>. In this example, when you need information about a user, you send a request message to <code>UserProxyActor</code>, then it gets the corresponding result from the appropriate backend actor based on the request message type.</p>
<p align="center">
  <img src="images/futures-pipeto1.png">
</p>
<p align="center">
  <img src="images/futures-pipeto2.png">
</p>
<p>The message types you send to <code>UserProxyActor</code> are <code>GetUserData</code> and <code>GetUserActivities</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L121-L125" target="_blank" title="Go to snippet source"></a><code class="language-scala">object UserProxyActor {
  sealed trait Message
  case object GetUserData extends Message
  case object GetUserActivities extends Message
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L251-L253" target="_blank" title="Go to snippet source"></a><code class="language-java">public class GetUserData {}

public class GetUserActivities {}</code></pre></dd>
</dl>
<p>and <code>UserData</code> and <span class="group-scala"><code>List[UserActivity]</code></span><span class="group-java"><code>ArrayList&lt;UserActivity&gt;</code></span> are returned to the original sender in the end.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L55-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class UserData(data: String)
case class UserActivity(activity: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L146-L160" target="_blank" title="Go to snippet source"></a><code class="language-java">public class UserData {
  final String data;

  UserData(String data) {
    this.data = data;
  }
}

public class UserActivity {
  final String activity;

  UserActivity(String activity) {
    this.activity = activity;
  }
}</code></pre></dd>
</dl>
<p>The backend <code>UserDataActor</code> and <code>UserActivityActor</code> are defined as follows:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L60-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">class UserDataActor extends Actor {
  import UserDataActor._

  //holds the user data internally
  var internalData: UserData = UserData(&quot;initial data&quot;)

  def receive = {
    case Get ⇒
      sender() ! internalData
  }
}

object UserDataActor {
  case object Get
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L164-L179" target="_blank" title="Go to snippet source"></a><code class="language-java">public class UserDataActor extends AbstractActor {
  UserData internalData;

  UserDataActor() {
    this.internalData = new UserData(&quot;initial data&quot;);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(GetFromUserDataActor.class, msg -&gt; sender().tell(internalData, self()))
        .build();
  }
}

public class GetFromUserDataActor {}</code></pre></dd>
</dl>
<p><code>UserDataActor</code> holds the data in memory, so that it can return the current state of the user data quickly upon a request.</p>
<p>On the other hand, <code>UserActivityActor</code> queries into a <code>repository</code> to retrieve historical user activities then sends the result to the <code>sender()</code> which is <code>UserProxy</code> in this case, with the pipe pattern.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L78-L97" target="_blank" title="Go to snippet source"></a><code class="language-scala">trait UserActivityRepository {
  def queryHistoricalActivities(userId: String): Future[List[UserActivity]]
}

class UserActivityActor(val userId: String, repository: UserActivityRepository) extends Actor {
  import akka.pattern.pipe
  import UserActivityActor._
  implicit val ec: ExecutionContext = context.dispatcher

  def receive = {
    case Get ⇒
      // user&#39;s historical activities are retrieved
      // via the separate repository
      repository.queryHistoricalActivities(userId) pipeTo sender()
  }
}

object UserActivityActor {
  case object Get
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L68" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.pipe;
interface UserActivityRepository {
  CompletableFuture&lt;ArrayList&lt;UserActivity&gt;&gt; queryHistoricalActivities(String userId);
}

public class UserActivityActor extends AbstractActor {
  String userId;
  UserActivityRepository repository;

  UserActivityActor(String userId, UserActivityRepository repository) {
    this.userId = userId;
    this.repository = repository;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            GetFromUserActivityActor.class,
            msg -&gt; {
              CompletableFuture&lt;ArrayList&lt;UserActivity&gt;&gt; fut =
                  repository.queryHistoricalActivities(userId);

              pipe(fut, getContext().dispatcher()).to(sender());
            })
        .build();
  }
}

public class GetFromUserActivityActor {}</code></pre></dd>
</dl>
<p>Since it needs to talk to the separate <code>repository</code>, it takes time to retrieve the list of <code>UserActivity</code>, hence the return type of <code>queryHistoricalActivities</code> is <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletableFuture</code></span>. To send back the result to the <code>sender()</code> we used the <span class="group-scala"><code>pipeTo</code></span><span class="group-java"><code>pipe</code></span> method, so that the result of the <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletableFuture</code></span> is sent to <code>sender()</code> upon <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletableFuture</code></span>&rsquo;s completion.</p>
<p>Finally, the definition of <code>UserProxyActor</code> is as below.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L101-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">class UserProxyActor(
  userData:       ActorRef,
  userActivities: ActorRef
) extends Actor {
  import UserProxyActor._
  import akka.pattern.{ ask, pipe }
  implicit val ec: ExecutionContext = context.dispatcher

  implicit val timeout = Timeout(5 seconds)

  def receive = {
    case GetUserData ⇒
      (userData ? UserDataActor.Get) pipeTo sender()
    case GetUserActivities ⇒
      (userActivities ? UserActivityActor.Get) pipeTo sender()
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L65" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.ask;
import static akka.pattern.Patterns.pipe;
public class UserProxyActor extends AbstractActor {
  ActorRef userActor;
  ActorRef userActivityActor;
  Duration timeout = Duration.ofSeconds(5);

  UserProxyActor(ActorRef userActor, ActorRef userActivityActor) {
    this.userActor = userActor;
    this.userActivityActor = userActivityActor;
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            GetUserData.class,
            msg -&gt; {
              CompletableFuture&lt;Object&gt; fut =
                  ask(userActor, new GetUserData(), timeout).toCompletableFuture();

              pipe(fut, getContext().dispatcher());
            })
        .match(
            GetUserActivities.class,
            msg -&gt; {
              CompletableFuture&lt;Object&gt; fut =
                  ask(userActivityActor, new GetFromUserActivityActor(), timeout)
                      .toCompletableFuture();

              pipe(fut, getContext().dispatcher()).to(sender());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Note that the <span class="group-scala"><code>pipeTo</code></span><span class="group-java"><code>pipe</code></span> method used with the <span class="group-scala"><code>?</code></span><span class="group-java"><code>ask</code></span> method. Using <span class="group-scala"><code>pipeTo</code></span><span class="group-java"><code>pipe</code></span> with the <span class="group-scala"><code>?</code></span><span class="group-java"><code>ask</code></span> method is a common practice when you want to relay a message from one actor to another.</p>
<h2><a href="#use-directly" name="use-directly" class="anchor"><span class="anchor-link"></span></a>Use Directly</h2>
<p>A common use case within Akka is to have some computation performed concurrently without needing the extra utility of an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span>. If you find yourself creating a pool of <span class="group-scala"><code>Actor</code>s</span><span class="group-java"><code>AbstractActor</code>s</span> for the sole reason of performing a calculation in parallel, there is an easier (and faster) way:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L184-L191" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.Await
import scala.concurrent.Future
import scala.concurrent.duration._

val future = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
future foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L19-L28" target="_blank" title="Go to snippet source"></a><code class="language-java">import java.time.Duration;
import java.util.concurrent.*;

import scala.util.Try;

import akka.japi.Function;

import static akka.dispatch.Futures.future;
import static java.util.concurrent.TimeUnit.SECONDS;

Future&lt;String&gt; f =
    future(
        new Callable&lt;String&gt;() {
          public String call() {
            return &quot;Hello&quot; + &quot;World&quot;;
          }
        },
        system.dispatcher());

f.onComplete(new PrintResult&lt;Try&lt;String&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>In the above code the block passed to <code>Future</code> will be executed by the default <code>Dispatcher</code>, with the return value of the block used to complete the <code>Future</code> (in this case, the result would be the string: &ldquo;HelloWorld&rdquo;). Unlike a <code>Future</code> that is returned from an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span>, this <code>Future</code> is properly typed, and we also avoid the overhead of managing an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span>.</p>
<p>You can also create already completed Futures using the <span class="group-scala"><code>Future</code> companion</span><span class="group-java"><code>Futures</code> class</span>, which can be either successes:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L467" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future = Future.successful(&quot;Yay!&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L497" target="_blank" title="Go to snippet source"></a><code class="language-java">Future&lt;String&gt; future = Futures.successful(&quot;Yay!&quot;);</code></pre></dd>
</dl>
<p>Or failures:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L470" target="_blank" title="Go to snippet source"></a><code class="language-scala">val otherFuture = Future.failed[String](new IllegalArgumentException(&quot;Bang!&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L500" target="_blank" title="Go to snippet source"></a><code class="language-java">Future&lt;String&gt; otherFuture = Futures.failed(new IllegalArgumentException(&quot;Bang!&quot;));</code></pre></dd>
</dl>
<p>It is also possible to create an empty <code>Promise</code>, to be filled later, and obtain the corresponding <code>Future</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L473-L475" target="_blank" title="Go to snippet source"></a><code class="language-scala">val promise = Promise[String]()
val theFuture = promise.future
promise.success(&quot;hello&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L503-L505" target="_blank" title="Go to snippet source"></a><code class="language-java">Promise&lt;String&gt; promise = Futures.promise();
Future&lt;String&gt; theFuture = promise.future();
promise.success(&quot;hello&quot;);</code></pre></dd>
</dl><div class="group-java">
<p>For these examples <code>PrintResult</code> is defined as follows:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L109-L114" target="_blank" title="Go to snippet source"></a><code class="language-java">public static final class PrintResult&lt;T&gt; extends OnSuccess&lt;T&gt; {
  @Override
  public final void onSuccess(T t) {
    System.out.println(t);
  }
}</code></pre></div>
<h2><a href="#functional-futures" name="functional-futures" class="anchor"><span class="anchor-link"></span></a>Functional Futures</h2>
<p>Scala&rsquo;s <code>Future</code> has several monadic methods that are very similar to the ones used by Scala&rsquo;s collections. These allow you to create &lsquo;pipelines&rsquo; or &lsquo;streams&rsquo; that the result will travel through.</p>
<p>The first method for working with <code>Future</code> functionally is <code>map</code>. This method takes a <span class="group-scala"><code>Function</code></span><span class="group-java"><code>Mapper</code></span> which performs some operation on the result of the <code>Future</code>, and returning a new result. The return value of the <code>map</code> method is another <code>Future</code> that will contain the new result:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L198-L204" target="_blank" title="Go to snippet source"></a><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = f1 map { x ⇒
  x.length
}
f2 foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L19-L28" target="_blank" title="Go to snippet source"></a><code class="language-java">import java.time.Duration;
import java.util.concurrent.*;

import scala.util.Try;

import akka.japi.Function;

import static akka.dispatch.Futures.future;
import static java.util.concurrent.TimeUnit.SECONDS;

final ExecutionContext ec = system.dispatcher();

Future&lt;String&gt; f1 =
    future(
        new Callable&lt;String&gt;() {
          public String call() {
            return &quot;Hello&quot; + &quot;World&quot;;
          }
        },
        ec);

Future&lt;Integer&gt; f2 =
    f1.map(
        new Mapper&lt;String, Integer&gt;() {
          public Integer apply(String s) {
            return s.length();
          }
        },
        ec);

f2.onComplete(new PrintResult&lt;Try&lt;Integer&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>In this example we are joining two strings together within a <code>Future</code>. Instead of waiting for <span class="group-scala"><code>this</code></span><span class="group-java"><code>f1</code></span> to complete, we apply our function that calculates the length of the string using the <code>map</code> method. Now we have a second <code>Future</code>, <code>f2</code>, that will eventually contain an <span class="group-scala"><code>Int</code></span><span class="group-java"><code>Integer</code></span>. When our original <code>Future</code>, <code>f1</code>, completes, it will also apply our function and complete the second <code>Future</code> with its result. When we finally get the result, it will contain the number 10. Our original <code>Future</code> still contains the string &ldquo;HelloWorld&rdquo; and is unaffected by the <code>map</code>.</p>
<p>Something to note when using these methods: passed work is always dispatched on the provided <code>ExecutionContext</code>. Even if the <code>Future</code> has already been completed, when one of these methods is called.</p><div class="group-scala">
<p>The <code>map</code> method is fine if we are modifying a single <code>Future</code>, but if 2 or more <code>Future</code>s are involved <code>map</code> will not allow you to combine them together:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L213-L222" target="_blank" title="Go to snippet source"></a><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = Future.successful(3)
val f3 = f1 map { x ⇒
  f2 map { y ⇒
    x.length * y
  }
}
f3 foreach println</code></pre>
<p><code>f3</code> is a <code>Future[Future[Int]]</code> instead of the desired <code>Future[Int]</code>. Instead, the <code>flatMap</code> method should be used:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L229-L238" target="_blank" title="Go to snippet source"></a><code class="language-scala">val f1 = Future {
  &quot;Hello&quot; + &quot;World&quot;
}
val f2 = Future.successful(3)
val f3 = f1 flatMap { x ⇒
  f2 map { y ⇒
    x.length * y
  }
}
f3 foreach println</code></pre>
<p>Composing futures using nested combinators it can sometimes become quite complicated and hard to read, in these cases using Scala&rsquo;s &lsquo;for comprehensions&rsquo; usually yields more readable code. See next section for examples.</p>
<p>If you need to do conditional propagation, you can use <code>filter</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L246-L256" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future1 = Future.successful(4)
val future2 = future1.filter(_ % 2 == 0)

future2 foreach println

val failedFilter = future1.filter(_ % 2 == 1).recover {
  // When filter fails, it will have a java.util.NoSuchElementException
  case m: NoSuchElementException ⇒ 0
}

failedFilter foreach println</code></pre>
<h3><a href="#for-comprehensions" name="for-comprehensions" class="anchor"><span class="anchor-link"></span></a>For Comprehensions</h3>
<p>Since <code>Future</code> has a <code>map</code>, <code>filter</code> and <code>flatMap</code> method it can be used in a &lsquo;for comprehension&rsquo;:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L266-L276" target="_blank" title="Go to snippet source"></a><code class="language-scala">val f = for {
  a ← Future(10 / 2) // 10 / 2 = 5
  b ← Future(a + 1) //  5 + 1 = 6
  c ← Future(a - 1) //  5 - 1 = 4
  if c &gt; 3 // Future.filter
} yield b * c //  6 * 4 = 24

// Note that the execution of futures a, b, and c
// are not done in parallel.

f foreach println</code></pre>
<p>Something to keep in mind when doing this is even though it looks like parts of the above example can run in parallel, each step of the for comprehension is run sequentially. This will happen on separate threads for each step but there isn&rsquo;t much benefit over running the calculations all within a single <code>Future</code>. The real benefit comes when the <code>Future</code>s are created first, and then combining them together.</p></div>
<h3><a href="#composing-futures" name="composing-futures" class="anchor"><span class="anchor-link"></span></a>Composing Futures</h3><div class="group-scala">
<p>The example for comprehension above is an example of composing <code>Future</code>s. A common use case for this is combining the replies of several <code>Actor</code>s into a single calculation without resorting to calling <code>Await.result</code> or <code>Await.ready</code> to block for each result. First an example of using <code>Await.result</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L292-L301" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>val f1 = ask(actor1, msg1)
val f2 = ask(actor2, msg2)

val a = Await.result(f1, 3 seconds).asInstanceOf[Int]
val b = Await.result(f2, 3 seconds).asInstanceOf[Int]

val f3 = ask(actor3, (a + b))

val result = Await.result(f3, 3 seconds).asInstanceOf[Int]</code></pre>
<p>Here we wait for the results from the first 2 <code>Actor</code>s before sending that result to the third <code>Actor</code>. We called <code>Await.result</code> 3 times, which caused our little program to block 3 times before getting our final result. Now compare that to this example:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L316-L326" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>val f1 = ask(actor1, msg1)
val f2 = ask(actor2, msg2)

val f3 = for {
  a ← f1.mapTo[Int]
  b ← f2.mapTo[Int]
  c ← ask(actor3, (a + b)).mapTo[Int]
} yield c

f3 foreach println</code></pre>
<p>Here we have 2 actors processing a single message each. Once the 2 results are available (note that we don&rsquo;t block to get these results!), they are being added together and sent to a third <code>Actor</code>, which replies with a string, which we assign to &lsquo;result&rsquo;.</p>
<p>This is fine when dealing with a known amount of Actors, but can grow unwieldy if we have more than a handful. The <code>sequence</code> and <code>traverse</code> helper methods can make it easier to handle more complex use cases. Both of these methods are ways of turning, for a subclass <code>T</code> of <code>Traversable</code>, <code>T[Future[A]]</code> into a <code>Future[T[A]]</code>. For example:</p></div><div class="group-java">
<p>It is very often desirable to be able to combine different Futures with each other, below are some examples on how that can be done in a non-blocking fashion.</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L336-L344" target="_blank" title="Go to snippet source"></a><code class="language-scala">// oddActor returns odd numbers sequentially from 1 as a List[Future[Int]]
val listOfFutures = List.fill(100)(akka.pattern.ask(oddActor, GetNext).mapTo[Int])

// now we have a Future[List[Int]]
val futureList = Future.sequence(listOfFutures)

// Find the sum of the odd numbers
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L32-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.dispatch.Futures.sequence;

final ExecutionContext ec = system.dispatcher();
// Some source generating a sequence of Future&lt;Integer&gt;:s
Iterable&lt;Future&lt;Integer&gt;&gt; listOfFutureInts = source;

// now we have a Future[Iterable[Integer]]
Future&lt;Iterable&lt;Integer&gt;&gt; futureListOfInts = sequence(listOfFutureInts, ec);

// Find the sum of the odd numbers
Future&lt;Long&gt; futureSum =
    futureListOfInts.map(
        new Mapper&lt;Iterable&lt;Integer&gt;, Long&gt;() {
          public Long apply(Iterable&lt;Integer&gt; ints) {
            long sum = 0;
            for (Integer i : ints) sum += i;
            return sum;
          }
        },
        ec);

futureSum.onComplete(new PrintResult&lt;Try&lt;Long&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>To better explain what happened in the example, <code>Future.sequence</code> is taking the <span class="group-scala"><code>List[Future[Int]]</code></span><span class="group-java"><code>Iterable&lt;Future&lt;Integer&gt;&gt;</code></span> and turning it into a <span class="group-scala"><code>Future[List[Int]]</code></span><span class="group-java"><code>Future&lt;Iterable&lt;Integer&gt;&gt;</code></span>. We can then use <code>map</code> to work with the <span class="group-scala"><code>List[Int]</code></span><span class="group-java"><code>Iterable&lt;Integer&gt;</code></span> directly, and we aggregate the sum of the <span class="group-scala"><code>List</code></span><span class="group-java"><code>Iterable</code></span>.</p>
<p>The <code>traverse</code> method is similar to <code>sequence</code>, but it takes a sequence of <code>A</code> and applies a function <span class="group-scala"><code>A =&gt; Future[B]</code></span><span class="group-java">from <code>A</code> to <code>Future&lt;B&gt;</code></span> <span class="group-scala">to return a <code>Future[T[B]]</code> where <code>T</code> is again a subclass of Traversable. For example, to use <code>traverse</code> to sum the first 100 odd numbers:</span> <span class="group-java">and returns a <code>Future&lt;Iterable&lt;B&gt;&gt;</code>, enabling parallel map over the sequence, if you use <code>Futures.future</code> to create the <code>Future</code>.</span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L360-L362" target="_blank" title="Go to snippet source"></a><code class="language-scala">val futureList = Future.traverse((1 to 100).toList)(x ⇒ Future(x * 2 - 1))
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L37-L38" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.dispatch.Futures.traverse;

final ExecutionContext ec = system.dispatcher();
// Just a sequence of Strings
Iterable&lt;String&gt; listStrings = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);

Future&lt;Iterable&lt;String&gt;&gt; futureResult =
    traverse(
        listStrings,
        new Function&lt;String, Future&lt;String&gt;&gt;() {
          public Future&lt;String&gt; apply(final String r) {
            return future(
                new Callable&lt;String&gt;() {
                  public String call() {
                    return r.toUpperCase();
                  }
                },
                ec);
          }
        },
        ec);

// Returns the sequence of strings as upper case
futureResult.onComplete(new PrintResult&lt;Try&lt;Iterable&lt;String&gt;&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl><div class="group-scala">
<p>This is the same result as this example:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L351-L353" target="_blank" title="Go to snippet source"></a><code class="language-scala">val futureList = Future.sequence((1 to 100).toList.map(x ⇒ Future(x * 2 - 1)))
val oddSum = futureList.map(_.sum)
oddSum foreach println</code></pre>
<p>But it may be faster to use <code>traverse</code> as it doesn&rsquo;t have to create an intermediate <code>List[Future[Int]]</code>.</p></div>
<p>Then there&rsquo;s a method that&rsquo;s called <code>fold</code> that takes a start-value, a sequence of <code>Future</code>s and a function from the type of the start-value, a timeout, and the type of the futures and returns something with the same type as the start-value, and then applies the function to all elements in the sequence of futures, non-blockingly, the execution will be started when the last of the Futures is completed.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L369-L372" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Create a sequence of Futures
val futures = for (i ← 1 to 1000) yield Future(i * 2)
val futureSum = Future.fold(futures)(0)(_ + _)
futureSum foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L42-L44" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.japi.Function2;
import static akka.dispatch.Futures.fold;


final ExecutionContext ec = system.dispatcher();

// A sequence of Futures, in this case Strings
Iterable&lt;Future&lt;String&gt;&gt; futures = source;

// Start value is the empty string
Future&lt;String&gt; resultFuture =
    fold(
        &quot;&quot;,
        futures,
        new Function2&lt;String, String, String&gt;() {
          public String apply(String r, String t) {
            return r + t; // Just concatenate
          }
        },
        ec);

resultFuture.onComplete(new PrintResult&lt;Try&lt;String&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>That&rsquo;s all it takes!</p>
<p>If the sequence passed to <code>fold</code> is empty, it will return the start-value, in the case above, that will be 0. In some cases you don&rsquo;t have a start-value and you&rsquo;re able to use the value of the first completing <code>Future</code> in the sequence as the start-value, you can use <code>reduce</code>, it works like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L379-L382" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Create a sequence of Futures
val futures = for (i ← 1 to 1000) yield Future(i * 2)
val futureSum = Future.reduce(futures)(_ + _)
futureSum foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L48-L49" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.dispatch.Futures.reduce;


final ExecutionContext ec = system.dispatcher();
// A sequence of Futures, in this case Strings
Iterable&lt;Future&lt;String&gt;&gt; futures = source;

Future&lt;Object&gt; resultFuture =
    reduce(
        futures,
        new Function2&lt;Object, String, Object&gt;() {
          public Object apply(Object r, String t) {
            return r + t; // Just concatenate
          }
        },
        ec);

resultFuture.onComplete(new PrintResult&lt;Try&lt;Object&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>Same as with <code>fold</code>, the execution will be done asynchronously when the last of the <code>Future</code> is completed, you can also parallelize it by chunking your futures into sub-sequences and reduce them, and then reduce the reduced results again.</p>
<h2><a href="#callbacks" name="callbacks" class="anchor"><span class="anchor-link"></span></a>Callbacks</h2>
<p>Sometimes you just want to listen to a <code>Future</code> being completed, and react to that not by creating a new <code>Future</code>, but by side-effecting. For this, <code>Future</code> supports <code>onComplete</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L457-L460" target="_blank" title="Go to snippet source"></a><code class="language-scala">future onComplete {
  case Success(result)  ⇒ doSomethingOnSuccess(result)
  case Failure(failure) ⇒ doSomethingOnFailure(failure)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L642-L654" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();

future.onComplete(
    new OnComplete&lt;String&gt;() {
      public void onComplete(Throwable failure, String result) {
        if (failure != null) {
          // We got a failure, handle it here
        } else {
          // We got a result, do something with it
        }
      }
    },
    ec);</code></pre></dd>
</dl>
<h2><a href="#define-ordering" name="define-ordering" class="anchor"><span class="anchor-link"></span></a>Define Ordering</h2>
<p>Since callbacks are executed in any order and potentially in parallel, it can be tricky at the times when you need sequential ordering of operations. But there&rsquo;s a solution and its name is <code>andThen</code>. It creates a new <code>Future</code> with the specified callback, a <code>Future</code> that will have the same result as the <code>Future</code> it&rsquo;s called on, which allows for ordering like in the following sample:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L431-L436" target="_blank" title="Go to snippet source"></a><code class="language-scala">val result = Future { loadPage(url) } andThen {
  case Failure(exception) ⇒ log(exception)
} andThen {
  case _ ⇒ watchSomeTV()
}
result foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L551-L567" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; future1 =
    Futures.successful(&quot;value&quot;)
        .andThen(
            new OnComplete&lt;String&gt;() {
              public void onComplete(Throwable failure, String result) {
                if (failure != null) sendToIssueTracker(failure);
              }
            },
            ec)
        .andThen(
            new OnComplete&lt;String&gt;() {
              public void onComplete(Throwable failure, String result) {
                if (result != null) sendToTheInternetz(result);
              }
            },
            ec);</code></pre></dd>
</dl>
<h2><a href="#auxiliary-methods" name="auxiliary-methods" class="anchor"><span class="anchor-link"></span></a>Auxiliary Methods</h2>
<p><code>Future</code> <code>fallbackTo</code> combines 2 Futures into a new <code>Future</code>, and will hold the successful value of the second <code>Future</code> if the first <code>Future</code> fails.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L446-L447" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future4 = future1 fallbackTo future2 fallbackTo future3
future4 foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L686-L691" target="_blank" title="Go to snippet source"></a><code class="language-java">Future&lt;String&gt; future1 = Futures.failed(new IllegalStateException(&quot;OHNOES1&quot;));
Future&lt;String&gt; future2 = Futures.failed(new IllegalStateException(&quot;OHNOES2&quot;));
Future&lt;String&gt; future3 = Futures.successful(&quot;bar&quot;);
// Will have &quot;bar&quot; in this case
Future&lt;String&gt; future4 = future1.fallbackTo(future2).fallbackTo(future3);
future4.onComplete(new PrintResult&lt;Try&lt;String&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>You can also combine two Futures into a new <code>Future</code> that will hold a tuple of the two Futures successful results, using the <code>zip</code> operation.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L419-L420" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future3 = future1 zip future2 map { case (a, b) ⇒ a + &quot; &quot; + b }
future3 foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L663-L677" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; future1 = Futures.successful(&quot;foo&quot;);
Future&lt;String&gt; future2 = Futures.successful(&quot;bar&quot;);
Future&lt;String&gt; future3 =
    future1
        .zip(future2)
        .map(
            new Mapper&lt;scala.Tuple2&lt;String, String&gt;, String&gt;() {
              public String apply(scala.Tuple2&lt;String, String&gt; zipped) {
                return zipped._1() + &quot; &quot; + zipped._2();
              }
            },
            ec);

future3.onComplete(new PrintResult&lt;Try&lt;String&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<h2><a href="#exceptions" name="exceptions" class="anchor"><span class="anchor-link"></span></a>Exceptions</h2>
<p>Since the result of a <code>Future</code> is created concurrently to the rest of the program, exceptions must be handled differently. It doesn&rsquo;t matter if an <span class="group-scala"><code>Actor</code></span><span class="group-java"><code>AbstractActor</code></span> or the dispatcher is completing the <code>Future</code>, if an <code>Exception</code> is caught the <code>Future</code> will contain it instead of a valid result. If a <code>Future</code> does contain an <code>Exception</code>, calling <code>Await.result</code> will cause it to be thrown again so it can be handled properly.</p>
<p>It is also possible to handle an <code>Exception</code> by returning a different result. This is done with the <code>recover</code> method. For example:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L392-L395" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future = akka.pattern.ask(actor, msg1) recover {
  case e: ArithmeticException ⇒ 0
}
future foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L574-L593" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();

Future&lt;Integer&gt; future =
    future(
            new Callable&lt;Integer&gt;() {
              public Integer call() {
                return 1 / 0;
              }
            },
            ec)
        .recover(
            new Recover&lt;Integer&gt;() {
              public Integer recover(Throwable problem) throws Throwable {
                if (problem instanceof ArithmeticException) return 0;
                else throw problem;
              }
            },
            ec);

future.onComplete(new PrintResult&lt;Try&lt;Integer&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<p>In this example, if the actor replied with a <code>akka.actor.Status.Failure</code> containing the <code>ArithmeticException</code>, our <code>Future</code> would have a result of 0. The <code>recover</code> method works very similarly to the standard try/catch blocks, so multiple <code>Exception</code>s can be handled in this manner, and if an <code>Exception</code> is not handled this way it will behave as if we hadn&rsquo;t used the <code>recover</code> method.</p>
<p>You can also use the <code>recoverWith</code> method, which has the same relationship to <code>recover</code> as <code>flatMap</code> has to <code>map</code>, and is use like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L405-L410" target="_blank" title="Go to snippet source"></a><code class="language-scala">val future = akka.pattern.ask(actor, msg1) recoverWith {
  case e: ArithmeticException ⇒ Future.successful(0)
  case foo: IllegalArgumentException ⇒
    Future.failed[Int](new IllegalStateException(&quot;All br0ken!&quot;))
}
future foreach println</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L603-L629" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();

Future&lt;Integer&gt; future =
    future(
            new Callable&lt;Integer&gt;() {
              public Integer call() {
                return 1 / 0;
              }
            },
            ec)
        .recoverWith(
            new Recover&lt;Future&lt;Integer&gt;&gt;() {
              public Future&lt;Integer&gt; recover(Throwable problem) throws Throwable {
                if (problem instanceof ArithmeticException) {
                  return future(
                      new Callable&lt;Integer&gt;() {
                        public Integer call() {
                          return 0;
                        }
                      },
                      ec);
                } else throw problem;
              }
            },
            ec);

future.onComplete(new PrintResult&lt;Try&lt;Integer&gt;&gt;(), system.dispatcher());</code></pre></dd>
</dl>
<h2><a href="#after" name="after" class="anchor"><span class="anchor-link"></span></a>After</h2>
<p><code>akka.pattern.after</code> makes it easy to complete a <code>Future</code> with a value or exception after a timeout.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L485-L490" target="_blank" title="Go to snippet source"></a><code class="language-scala">// import akka.pattern.after

val delayed = akka.pattern.after(200 millis, using = system.scheduler)(Future.failed(
  new IllegalStateException(&quot;OHNOES&quot;)))
val future = Future { Thread.sleep(1000); &quot;foo&quot; }
val result = Future firstCompletedOf Seq(future, delayed)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L53-L55" target="_blank" title="Go to snippet source"></a><code class="language-java">import static akka.pattern.Patterns.after;

import java.util.Arrays;
final ExecutionContext ec = system.dispatcher();
Future&lt;String&gt; failExc = Futures.failed(new IllegalStateException(&quot;OHNOES1&quot;));
Timeout delay = Timeout.create(Duration.ofMillis(200));
Future&lt;String&gt; delayed = Patterns.after(delay.duration(), system.scheduler(), ec, failExc);
Future&lt;String&gt; future =
    future(
        new Callable&lt;String&gt;() {
          public String call() throws InterruptedException {
            Thread.sleep(1000);
            return &quot;foo&quot;;
          }
        },
        ec);
Future&lt;String&gt; result =
    Futures.firstCompletedOf(Arrays.&lt;Future&lt;String&gt;&gt;asList(future, delayed), ec);</code></pre></dd>
</dl>
<h2><a href="#retry" name="retry" class="anchor"><span class="anchor-link"></span></a>Retry</h2>
<p><span class="group-scala"><code>akka.pattern.retry</code></span><span class="group-java"><code>akka.pattern.Patterns.retry</code></span> will retry a <span class="group-scala"><code>Future</code> class</span><span class="group-java"><code>CompletionStage</code> class</span> some number of times with a delay between each attempt.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/future/FutureDocSpec.scala#L497-L510" target="_blank" title="Go to snippet source"></a><code class="language-scala">implicit val scheduler = system.scheduler
//Given some future that will succeed eventually
@volatile var failCount = 0
def attempt() = {
  if (failCount &lt; 5) {
    failCount += 1
    Future.failed(new IllegalStateException(failCount.toString))
  } else Future.successful(5)
}
//Return a new future that will retry up to 10 times
val retried = akka.pattern.retry(
  () ⇒ attempt(),
  10,
  100 milliseconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L59-L61" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>import static akka.pattern.Patterns.retry;

final ExecutionContext ec = system.dispatcher();
Callable&lt;CompletionStage&lt;String&gt;&gt; attempt = () -&gt; CompletableFuture.completedFuture(&quot;test&quot;);
CompletionStage&lt;String&gt; retriedFuture =
    retry(attempt, 3, java.time.Duration.ofMillis(200), system.scheduler(), ec);</code></pre></dd>
</dl><div class="group-java">
<h2><a href="#java-8-completionstage-and-completablefuture" name="java-8-completionstage-and-completablefuture" class="anchor"><span class="anchor-link"></span></a>Java 8, CompletionStage and CompletableFuture</h2>
<p>Starting with Akka 2.4.2 we have begun to introduce Java 8 <code>java.util.concurrent.CompletionStage</code> in Java APIs. It&rsquo;s a <code>scala.concurrent.Future</code> counterpart in Java; conversion from <code>scala.concurrent.Future</code> is done using <code>scala-java8-compat</code> library.</p>
<p>Unlike <code>scala.concurrent.Future</code> which has async methods only, <code>CompletionStage</code> has <em>async</em> and <em>non-async</em> methods.</p>
<p>The <code>scala-java8-compat</code> library returns its own implementation of <code>CompletionStage</code> which delegates all <em>non-async</em> methods to their <em>async</em> counterparts. The implementation extends standard Java <code>CompletableFuture</code>. Java 8 <code>CompletableFuture</code> creates a new instance of <code>CompletableFuture</code> for any new stage, which means <code>scala-java8-compat</code> implementation is not used after the first mapping method.</p></div><div class="callout note group-java"><div class="callout-title">Note</div>
<p>After adding any additional computation stage to <code>CompletionStage</code> returned by <code>scala-java8-compat</code> (e.g. <code>CompletionStage</code> instances returned by Akka) it falls back to standard behavior of Java <code>CompletableFuture</code>.</p></div><div class="group-java">
<p>Actions supplied for dependent completions of <em>non-async</em> methods may be performed by the thread that completes the current <code>CompletableFuture</code>, or by any other caller of a completion method.</p>
<p>All <em>async</em> methods without an explicit Executor are performed using the <code>ForkJoinPool.commonPool()</code> executor.</p></div><div class="group-java">
<h3><a href="#non-async-methods" name="non-async-methods" class="anchor"><span class="anchor-link"></span></a>Non-async methods</h3>
<p>When non-async methods are applied on a not yet completed <code>CompletionStage</code>, they are completed by the thread which completes initial <code>CompletionStage</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L739-L774" target="_blank" title="Go to snippet source"></a><code class="language-java">final ExecutionContext ec = system.dispatcher();
final CountDownLatch countDownLatch = new CountDownLatch(1);

Future&lt;String&gt; scalaFuture =
    Futures.future(
        () -&gt; {
          assertThat(
              Thread.currentThread().getName(),
              containsString(&quot;akka.actor.default-dispatcher&quot;));
          countDownLatch.await(); // do not complete yet
          return &quot;hello&quot;;
        },
        ec);

CompletionStage&lt;String&gt; fromScalaFuture =
    FutureConverters.toJava(scalaFuture)
        .thenApply(
            s -&gt; { // 1
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            })
        .thenApply(
            s -&gt; { // 2
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            })
        .thenApply(
            s -&gt; { // 3
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            });

countDownLatch.countDown(); // complete scalaFuture</code></pre>
<p>In this example Scala <code>Future</code> is converted to <code>CompletionStage</code> just like Akka does. The completion is delayed: we are calling <code>thenApply</code> multiple times on a not yet complete <code>CompletionStage</code>, then complete the <code>Future</code>.</p>
<p>First <code>thenApply</code> is actually performed on <code>scala-java8-compat</code> instance and computational stage (lambda) execution is delegated to default Java <code>thenApplyAsync</code> which is executed on <code>ForkJoinPool.commonPool()</code>.</p>
<p>Second and third <code>thenApply</code> methods are executed on Java 8 <code>CompletableFuture</code> instance which executes computational stages on the thread which completed the first stage. It is never executed on a thread of Scala <code>Future</code> because default <code>thenApply</code> breaks the chain and executes on <code>ForkJoinPool.commonPool()</code>.</p>
<p>In the next example <code>thenApply</code> methods are executed on an already completed <code>Future</code>/<code>CompletionStage</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L785-L818" target="_blank" title="Go to snippet source"></a><code class="language-java">Future&lt;String&gt; scalaFuture =
    Futures.future(
        () -&gt; {
          assertThat(
              Thread.currentThread().getName(),
              containsString(&quot;akka.actor.default-dispatcher&quot;));
          return &quot;hello&quot;;
        },
        ec);

CompletionStage&lt;String&gt; completedStage =
    FutureConverters.toJava(scalaFuture)
        .thenApply(
            s -&gt; { // 1
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            });

completedStage.toCompletableFuture().get(2, SECONDS); // complete current CompletionStage
final String currentThread = Thread.currentThread().getName();

CompletionStage&lt;String&gt; stage2 =
    completedStage
        .thenApply(
            s -&gt; { // 2
              assertThat(Thread.currentThread().getName(), is(currentThread));
              return s;
            })
        .thenApply(
            s -&gt; { // 3
              assertThat(Thread.currentThread().getName(), is(currentThread));
              return s;
            });</code></pre>
<p>First <code>thenApply</code> is still executed on <code>ForkJoinPool.commonPool()</code> (because it is actually <code>thenApplyAsync</code> which is always executed on global Java pool).</p>
<p>Then we wait for stages to complete so second and third <code>thenApply</code> are executed on completed <code>CompletionStage</code>, and stages are executed on the current thread - the thread which called second and third <code>thenApply</code>.</p></div><div class="group-java">
<h3><a href="#async-methods" name="async-methods" class="anchor"><span class="anchor-link"></span></a>Async methods</h3>
<p>As mentioned above, default <em>async</em> methods are always executed on <code>ForkJoinPool.commonPool()</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L839-L858" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletionStage&lt;String&gt; fromScalaFuture =
    FutureConverters.toJava(scalaFuture)
        .thenApplyAsync(
            s -&gt; { // 1
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            })
        .thenApplyAsync(
            s -&gt; { // 2
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            })
        .thenApplyAsync(
            s -&gt; { // 3
              assertThat(
                  Thread.currentThread().getName(), containsString(&quot;ForkJoinPool.commonPool&quot;));
              return s;
            });</code></pre>
<p><code>CompletionStage</code> also has <em>async</em> methods which take <code>Executor</code> as a second parameter, just like <code>Future</code>:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/future/FutureDocTest.java#L879-L906" target="_blank" title="Go to snippet source"></a><code class="language-java">final Executor ex = system.dispatcher();

CompletionStage&lt;String&gt; fromScalaFuture =
    FutureConverters.toJava(scalaFuture)
        .thenApplyAsync(
            s -&gt; {
              assertThat(
                  Thread.currentThread().getName(),
                  containsString(&quot;akka.actor.default-dispatcher&quot;));
              return s;
            },
            ex)
        .thenApplyAsync(
            s -&gt; {
              assertThat(
                  Thread.currentThread().getName(),
                  containsString(&quot;akka.actor.default-dispatcher&quot;));
              return s;
            },
            ex)
        .thenApplyAsync(
            s -&gt; {
              assertThat(
                  Thread.currentThread().getName(),
                  containsString(&quot;akka.actor.default-dispatcher&quot;));
              return s;
            },
            ex);</code></pre>
<p>This example is behaving like <code>Future</code>: every stage is executed on an explicitly specified <code>Executor</code>.</p></div><div class="callout note group-java"><div class="callout-title">Note</div>
<p>When in doubt, async methods with explicit executor should be used. Always async methods with a dedicated executor/dispatcher for long-running or blocking computations, such as IO operations.</p></div><div class="group-java">
<p>See also:</p>
<ul>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">CompletionStage</a></li>
  <li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a></li>
  <li><a href="https://github.com/scala/scala-java8-compat">scala-java8-compat</a></li>
</ul></div>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="index-futures.html"><i class="icon-prev"></i> <span class="link-prev">Futures and Agents</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="agents.html">Agents <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/futures.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
