<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Cluster Client &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/cluster-client.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a>
  <ul>
    <li><a href="common/cluster.html" class="page">Cluster Specification</a></li>
    <li><a href="cluster-usage.html" class="page">Cluster Usage</a></li>
    <li><a href="cluster-routing.html" class="page">Cluster Aware Routers</a></li>
    <li><a href="cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="cluster-client.html#cluster-client" class="active page">Cluster Client</a>
    <ul>
      <li><a href="cluster-client.html#dependency" class="header">Dependency</a></li>
      <li><a href="cluster-client.html#introduction" class="header">Introduction</a></li>
      <li><a href="cluster-client.html#an-example" class="header">An Example</a></li>
      <li><a href="cluster-client.html#clusterclientreceptionist-extension" class="header">ClusterClientReceptionist Extension</a></li>
      <li><a href="cluster-client.html#events" class="header">Events</a></li>
      <li><a href="cluster-client.html#configuration" class="header">Configuration</a></li>
      <li><a href="cluster-client.html#failure-handling" class="header">Failure handling</a></li>
      <li><a href="cluster-client.html#when-the-cluster-cannot-be-reached-at-all" class="header">When the cluster cannot be reached at all</a></li>
    </ul></li>
    <li><a href="cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="cluster-metrics.html" class="page">Cluster Metrics Extension</a></li>
    <li><a href="distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="cluster-dc.html" class="page">Cluster across multiple data centers</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a>
  <ul>
    <li><a href="common/cluster.html" class="page">Cluster Specification</a></li>
    <li><a href="cluster-usage.html" class="page">Cluster Usage</a></li>
    <li><a href="cluster-routing.html" class="page">Cluster Aware Routers</a></li>
    <li><a href="cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="distributed-pub-sub.html" class="page">Distributed Publish Subscribe in Cluster</a></li>
    <li><a href="cluster-client.html#cluster-client" class="active page">Cluster Client</a>
    <ul>
      <li><a href="cluster-client.html#dependency" class="header">Dependency</a></li>
      <li><a href="cluster-client.html#introduction" class="header">Introduction</a></li>
      <li><a href="cluster-client.html#an-example" class="header">An Example</a></li>
      <li><a href="cluster-client.html#clusterclientreceptionist-extension" class="header">ClusterClientReceptionist Extension</a></li>
      <li><a href="cluster-client.html#events" class="header">Events</a></li>
      <li><a href="cluster-client.html#configuration" class="header">Configuration</a></li>
      <li><a href="cluster-client.html#failure-handling" class="header">Failure handling</a></li>
      <li><a href="cluster-client.html#when-the-cluster-cannot-be-reached-at-all" class="header">When the cluster cannot be reached at all</a></li>
    </ul></li>
    <li><a href="cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="cluster-metrics.html" class="page">Cluster Metrics Extension</a></li>
    <li><a href="distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="cluster-dc.html" class="page">Cluster across multiple data centers</a></li>
    <li><a href="multi-jvm-testing.html" class="page">Multi JVM Testing</a></li>
    <li><a href="multi-node-testing.html" class="page">Multi Node Testing</a></li>
  </ul></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#cluster-client" name="cluster-client" class="anchor"><span class="anchor-link"></span></a>Cluster Client</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Cluster Client, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-cluster-tools" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-cluster-tools_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-cluster-tools_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>An actor system that is not part of the cluster can communicate with actors somewhere in the cluster via the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span>, the client can run in an <code>ActorSystem</code> that is part of another cluster. It only needs to know the location of one (or more) nodes to use as initial contact points. It will establish a connection to a <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span> somewhere in the cluster. It will monitor the connection to the receptionist and establish a new connection if the link goes down. When looking for a new receptionist it uses fresh contact points retrieved from previous establishment, or periodically refreshed contacts, i.e. not necessarily the initial contact points.</p><div class="callout note "><div class="callout-title">Note</div>
<p><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> should not be used when sending messages to actors that run within the same cluster. Similar functionality as the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> is provided in a more efficient way by <a href="distributed-pub-sub.html">Distributed Publish Subscribe in Cluster</a> for actors that belong to the same cluster.</p></div>
<p>Also, note it&rsquo;s necessary to change <code>akka.actor.provider</code> from <code>local</code> to <code>remote</code> or <code>cluster</code> when using the cluster client.</p>
<p>The receptionist is supposed to be started on all nodes, or all nodes with specified role, in the cluster. The receptionist can be started with the <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span> extension or as an ordinary actor.</p>
<p>You can send messages via the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> to any actor in the cluster that is registered in the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/pubsub/DistributedPubSubMediator.html">DistributedPubSubMediator</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/pubsub/DistributedPubSubMediator.html">DistributedPubSubMediator</a></span> used by the <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterReceptionist.html">ClusterReceptionist</a></span>. The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> provides methods for registration of actors that should be reachable from the client. Messages are wrapped in <code>ClusterClient.Send</code>, <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient$.html"><code>ClusterClient.SendToAll</code></a></span><span class="group-java"><code>ClusterClient.SendToAll</code></span> or <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient$.html"><code>ClusterClient.Publish</code></a></span><span class="group-java"><code>ClusterClient.Publish</code></span>.</p>
<p>Both the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> and the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> emit events that can be subscribed to. The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> sends out notifications in relation to having received a list of contact points from the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span>. One use of this list might be for the client to record its contact points. A client that is restarted could then use this information to supersede any previously configured contact points.</p>
<p>The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> sends out notifications in relation to having received a contact from a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span>. This notification enables the server containing the receptionist to become aware of what clients are connected.</p>
<ol>
  <li>
    <p><strong>ClusterClient.Send</strong></p>
    <p>The message will be delivered to one recipient with a matching path, if any such exists. If several entries match the path the message will be delivered to one random destination. The sender of the message can specify that local affinity is preferred, i.e. the message is sent to an actor in the same local actor system as the used receptionist actor, if any such exists, otherwise random to any other matching entry.</p>
  </li>
  <li>
    <p><strong>ClusterClient.SendToAll</strong></p>
    <p>The message will be delivered to all recipients with a matching path.</p>
  </li>
  <li>
    <p><strong>ClusterClient.Publish</strong></p>
    <p>The message will be delivered to all recipients Actors that have been registered as subscribers to the named topic.</p>
  </li>
</ol>
<p>Response messages from the destination actor are tunneled via the receptionist to avoid inbound connections from other cluster nodes to the client:</p>
<ul>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/actor/Actor.html"><code>sender()</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/actor/Actor.html"><code>getSender()</code></a></span>, as seen by the destination actor, is not the client itself,  but the receptionist</li>
  <li><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/actor/Actor.html"><code>sender()</code></a></span> <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/actor/Actor.html"><code>getSender()</code></a></span> of the response messages, sent back from the destination and seen by the client,  is <code>deadLetters</code></li>
</ul>
<p>since the client should normally send subsequent messages via the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span>. It is possible to pass the original sender inside the reply messages if the client is supposed to communicate directly to the actor in the cluster.</p>
<p>While establishing a connection to a receptionist the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> will buffer messages and send them when the connection is established. If the buffer is full the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> will drop old messages when new messages are sent via the client. The size of the buffer is configurable and it can be disabled by using a buffer size of 0.</p>
<p>It&rsquo;s worth noting that messages can always be lost because of the distributed nature of these actors. As always, additional logic should be implemented in the destination (acknowledgement) and in the client (retry) actors to ensure at-least-once message delivery.</p>
<h2><a href="#an-example" name="an-example" class="anchor"><span class="anchor-link"></span></a>An Example</h2>
<p>On the cluster nodes first start the receptionist. Note, it is recommended to load the extension when the actor system is started by defining it in the <code>akka.extensions</code> configuration property:</p>
<pre><code>akka.extensions = [&quot;akka.cluster.client.ClusterClientReceptionist&quot;]
</code></pre>
<p>Next, register the actors that should be available for the client.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/multi-jvm/scala/akka/cluster/client/ClusterClientSpec.scala#L239-L247" target="_blank" title="Go to snippet source"></a><code class="language-scala">runOn(host1) {
  val serviceA = system.actorOf(Props[Service], &quot;serviceA&quot;)
  ClusterClientReceptionist(system).registerService(serviceA)
}

runOn(host2, host3) {
  val serviceB = system.actorOf(Props[Service], &quot;serviceB&quot;)
  ClusterClientReceptionist(system).registerService(serviceB)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/test/java/akka/cluster/client/ClusterClientTest.java#L43-L47" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorRef serviceA = system.actorOf(Props.create(Service.class), &quot;serviceA&quot;);
ClusterClientReceptionist.get(system).registerService(serviceA);

ActorRef serviceB = system.actorOf(Props.create(Service.class), &quot;serviceB&quot;);
ClusterClientReceptionist.get(system).registerService(serviceB);</code></pre></dd>
</dl>
<p>On the client you create the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> actor and use it as a gateway for sending messages to the actors identified by their path (without address information) somewhere in the cluster.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/multi-jvm/scala/akka/cluster/client/ClusterClientSpec.scala#L256-L261" target="_blank" title="Go to snippet source"></a><code class="language-scala">runOn(client) {
  val c = system.actorOf(ClusterClient.props(
    ClusterClientSettings(system).withInitialContacts(initialContacts)), &quot;client&quot;)
  c ! ClusterClient.Send(&quot;/user/serviceA&quot;, &quot;hello&quot;, localAffinity = true)
  c ! ClusterClient.SendToAll(&quot;/user/serviceB&quot;, &quot;hi&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/test/java/akka/cluster/client/ClusterClientTest.java#L51-L57" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorRef c =
    system.actorOf(
        ClusterClient.props(
            ClusterClientSettings.create(system).withInitialContacts(initialContacts())),
        &quot;client&quot;);
c.tell(new ClusterClient.Send(&quot;/user/serviceA&quot;, &quot;hello&quot;, true), ActorRef.noSender());
c.tell(new ClusterClient.SendToAll(&quot;/user/serviceB&quot;, &quot;hi&quot;), ActorRef.noSender());</code></pre></dd>
</dl>
<p>The <code>initialContacts</code> parameter is a <span class="group-scala"><code>Set[ActorPath]</code></span><span class="group-java"><code>Set&lt;ActorPath&gt;</code></span>, which can be created like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/multi-jvm/scala/akka/cluster/client/ClusterClientSpec.scala#L271-L275" target="_blank" title="Go to snippet source"></a><code class="language-scala">val initialContacts = Set(
  ActorPath.fromString(&quot;akka.tcp://OtherSys@host1:2552/system/receptionist&quot;),
  ActorPath.fromString(&quot;akka.tcp://OtherSys@host2:2552/system/receptionist&quot;))
val settings = ClusterClientSettings(system)
  .withInitialContacts(initialContacts)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/test/java/akka/cluster/client/ClusterClientTest.java#L32-L37" target="_blank" title="Go to snippet source"></a><code class="language-java">Set&lt;ActorPath&gt; initialContacts() {
  return new HashSet&lt;ActorPath&gt;(
      Arrays.asList(
          ActorPaths.fromString(&quot;akka.tcp://OtherSys@host1:2552/system/receptionist&quot;),
          ActorPaths.fromString(&quot;akka.tcp://OtherSys@host2:2552/system/receptionist&quot;)));
}</code></pre></dd>
</dl>
<p>You will probably define the address information of the initial contact points in configuration or system property. See also <a href="#cluster-client-config">Configuration</a>.</p>
<p>A more comprehensive sample is available in the tutorial named <span class="group-scala"><a href="https://github.com/typesafehub/activator-akka-distributed-workers">Distributed workers with Akka and Scala</a>.</span> <span class="group-java"><a href="https://github.com/typesafehub/activator-akka-distributed-workers-java">Distributed workers with Akka and Java</a>.</span></p>
<h2><a href="#clusterclientreceptionist-extension" name="clusterclientreceptionist-extension" class="anchor"><span class="anchor-link"></span></a>ClusterClientReceptionist Extension</h2>
<p>In the example above the receptionist is started and accessed with the <code>akka.cluster.client.ClusterClientReceptionist</code> extension. That is convenient and perfectly fine in most cases, but it can be good to know that it is possible to start the <code>akka.cluster.client.ClusterReceptionist</code> actor as an ordinary actor and you can have several different receptionists at the same time, serving different types of clients.</p>
<p>Note that the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> uses the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/pubsub/DistributedPubSub.html">DistributedPubSub</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/pubsub/DistributedPubSub.html">DistributedPubSub</a></span> extension, which is described in <a href="distributed-pub-sub.html">Distributed Publish Subscribe in Cluster</a>.</p>
<p>It is recommended to load the extension when the actor system is started by defining it in the <code>akka.extensions</code> configuration property:</p>
<pre><code>akka.extensions = [&quot;akka.cluster.client.ClusterClientReceptionist&quot;]
</code></pre>
<h2><a href="#events" name="events" class="anchor"><span class="anchor-link"></span></a>Events</h2>
<p>As mentioned earlier, both the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> and <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> emit events that can be subscribed to. The following code snippet declares an actor that will receive notifications on contact points (addresses to the available receptionists), as they become available. The code illustrates subscribing to the events and receiving the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient.html">ClusterClient</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient.html">ClusterClient</a></span> initial state.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/multi-jvm/scala/akka/cluster/client/ClusterClientSpec.scala#L69-L87" target="_blank" title="Go to snippet source"></a><code class="language-scala">class ClientListener(targetClient: ActorRef) extends Actor {
  override def preStart(): Unit =
    targetClient ! SubscribeContactPoints

  def receive: Receive =
    receiveWithContactPoints(Set.empty)

  def receiveWithContactPoints(contactPoints: Set[ActorPath]): Receive = {
    case ContactPoints(cps) ⇒
      context.become(receiveWithContactPoints(cps))
    // Now do something with the up-to-date &quot;cps&quot;
    case ContactPointAdded(cp) ⇒
      context.become(receiveWithContactPoints(contactPoints + cp))
    // Now do something with an up-to-date &quot;contactPoints + cp&quot;
    case ContactPointRemoved(cp) ⇒
      context.become(receiveWithContactPoints(contactPoints - cp))
    // Now do something with an up-to-date &quot;contactPoints - cp&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/test/java/akka/cluster/client/ClusterClientTest.java#L71-L107" target="_blank" title="Go to snippet source"></a><code class="language-java">public static class ClientListener extends AbstractActor {
  private final ActorRef targetClient;
  private final Set&lt;ActorPath&gt; contactPoints = new HashSet&lt;&gt;();

  public ClientListener(ActorRef targetClient) {
    this.targetClient = targetClient;
  }

  @Override
  public void preStart() {
    targetClient.tell(SubscribeContactPoints.getInstance(), sender());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ContactPoints.class,
            msg -&gt; {
              contactPoints.addAll(msg.getContactPoints());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .match(
            ContactPointAdded.class,
            msg -&gt; {
              contactPoints.add(msg.contactPoint());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .match(
            ContactPointRemoved.class,
            msg -&gt; {
              contactPoints.remove(msg.contactPoint());
              // Now do something with an up-to-date &quot;contactPoints&quot;
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Similarly we can have an actor that behaves in a similar fashion for learning what cluster clients are connected to a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/multi-jvm/scala/akka/cluster/client/ClusterClientSpec.scala#L108-L126" target="_blank" title="Go to snippet source"></a><code class="language-scala">class ReceptionistListener(targetReceptionist: ActorRef) extends Actor {
  override def preStart(): Unit =
    targetReceptionist ! SubscribeClusterClients

  def receive: Receive =
    receiveWithClusterClients(Set.empty)

  def receiveWithClusterClients(clusterClients: Set[ActorRef]): Receive = {
    case ClusterClients(cs) ⇒
      context.become(receiveWithClusterClients(cs))
    // Now do something with the up-to-date &quot;c&quot;
    case ClusterClientUp(c) ⇒
      context.become(receiveWithClusterClients(clusterClients + c))
    // Now do something with an up-to-date &quot;clusterClients + c&quot;
    case ClusterClientUnreachable(c) ⇒
      context.become(receiveWithClusterClients(clusterClients - c))
    // Now do something with an up-to-date &quot;clusterClients - c&quot;
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/test/java/akka/cluster/client/ClusterClientTest.java#L111-L147" target="_blank" title="Go to snippet source"></a><code class="language-java">public static class ReceptionistListener extends AbstractActor {
  private final ActorRef targetReceptionist;
  private final Set&lt;ActorRef&gt; clusterClients = new HashSet&lt;&gt;();

  public ReceptionistListener(ActorRef targetReceptionist) {
    this.targetReceptionist = targetReceptionist;
  }

  @Override
  public void preStart() {
    targetReceptionist.tell(SubscribeClusterClients.getInstance(), sender());
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            ClusterClients.class,
            msg -&gt; {
              clusterClients.addAll(msg.getClusterClients());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .match(
            ClusterClientUp.class,
            msg -&gt; {
              clusterClients.add(msg.clusterClient());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .match(
            ClusterClientUnreachable.class,
            msg -&gt; {
              clusterClients.remove(msg.clusterClient());
              // Now do something with an up-to-date &quot;clusterClients&quot;
            })
        .build();
  }
}</code></pre></dd>
</dl>
<a id="cluster-client-config"></a>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>The <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientReceptionist.html">ClusterClientReceptionist</a></span> extension (or <span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterReceptionistSettings.html">ClusterReceptionistSettings</a></span><span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterReceptionistSettings.html">ClusterReceptionistSettings</a></span>) can be configured with the following properties:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/main/resources/reference.conf#L61-L96" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Settings for the ClusterClientReceptionist extension
akka.cluster.client.receptionist {
  # Actor name of the ClusterReceptionist actor, /system/receptionist
  name = receptionist

  # Start the receptionist on members tagged with this role.
  # All members are used if undefined or empty.
  role = &quot;&quot;

  # The receptionist will send this number of contact points to the client
  number-of-contacts = 3

  # The actor that tunnel response messages to the client will be stopped
  # after this time of inactivity.
  response-tunnel-receive-timeout = 30s
  
  # The id of the dispatcher to use for ClusterReceptionist actors. 
  # If not specified default dispatcher is used.
  # If specified you need to define the settings of the actual dispatcher.
  use-dispatcher = &quot;&quot;

  # How often failure detection heartbeat messages should be received for
  # each ClusterClient
  heartbeat-interval = 2s

  # Number of potentially lost/delayed heartbeats that will be
  # accepted before considering it to be an anomaly.
  # The ClusterReceptionist is using the akka.remote.DeadlineFailureDetector, which
  # will trigger if there are no heartbeats within the duration
  # heartbeat-interval + acceptable-heartbeat-pause, i.e. 15 seconds with
  # the default settings.
  acceptable-heartbeat-pause = 13s

  # Failure detection checking interval for checking all ClusterClients
  failure-detection-interval = 2s
}</code></pre>
<p>The following configuration properties are read by the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span> when created with a <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/actor/ActorSystem.html"><code>ActorSystem</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/actor/ActorSystem.html"><code>ActorSystem</code></a></span> parameter. It is also possible to amend the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span> or create it from another config section with the same layout as below. <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClientSettings.html">ClusterClientSettings</a></span> is a parameter to the <span class="group-scala"><a href="https://doc.akka.io/api/akka/2.5/akka/cluster/client/ClusterClient$.html"><code>ClusterClient.props</code></a></span><span class="group-java"><a href="https://doc.akka.io/japi/akka/2.5/?akka/cluster/client/ClusterClient$.html"><code>ClusterClient.props</code></a></span> factory method, i.e. each client can be configured with different settings if needed.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-cluster-tools/src/main/resources/reference.conf#L100-L144" target="_blank" title="Go to snippet source"></a><code class="language-conf"># Settings for the ClusterClient
akka.cluster.client {
  # Actor paths of the ClusterReceptionist actors on the servers (cluster nodes)
  # that the client will try to contact initially. It is mandatory to specify
  # at least one initial contact. 
  # Comma separated full actor paths defined by a string on the form of
  # &quot;akka.tcp://system@hostname:port/system/receptionist&quot;
  initial-contacts = []
  
  # Interval at which the client retries to establish contact with one of 
  # ClusterReceptionist on the servers (cluster nodes)
  establishing-get-contacts-interval = 3s
  
  # Interval at which the client will ask the ClusterReceptionist for
  # new contact points to be used for next reconnect.
  refresh-contacts-interval = 60s
  
  # How often failure detection heartbeat messages should be sent
  heartbeat-interval = 2s
  
  # Number of potentially lost/delayed heartbeats that will be
  # accepted before considering it to be an anomaly.
  # The ClusterClient is using the akka.remote.DeadlineFailureDetector, which
  # will trigger if there are no heartbeats within the duration 
  # heartbeat-interval + acceptable-heartbeat-pause, i.e. 15 seconds with
  # the default settings.
  acceptable-heartbeat-pause = 13s
  
  # If connection to the receptionist is not established the client will buffer
  # this number of messages and deliver them the connection is established.
  # When the buffer is full old messages will be dropped when new messages are sent
  # via the client. Use 0 to disable buffering, i.e. messages will be dropped
  # immediately if the location of the singleton is unknown.
  # Maximum allowed buffer size is 10000.
  buffer-size = 1000

  # If connection to the receiptionist is lost and the client has not been
  # able to acquire a new connection for this long the client will stop itself.
  # This duration makes it possible to watch the cluster client and react on a more permanent
  # loss of connection with the cluster, for example by accessing some kind of
  # service registry for an updated set of initial contacts to start a new cluster client with.
  # If this is not wanted it can be set to &quot;off&quot; to disable the timeout and retry
  # forever.
  reconnect-timeout = off
}</code></pre>
<h2><a href="#failure-handling" name="failure-handling" class="anchor"><span class="anchor-link"></span></a>Failure handling</h2>
<p>When the cluster client is started it must be provided with a list of initial contacts which are cluster nodes where receptionists are running. It will then repeatedly (with an interval configurable by <code>establishing-get-contacts-interval</code>) try to contact those until it gets in contact with one of them. While running, the list of contacts are continuously updated with data from the receptionists (again, with an interval configurable with <code>refresh-contacts-interval</code>), so that if there are more receptionists in the cluster than the initial contacts provided to the client the client will learn about them.</p>
<p>While the client is running it will detect failures in its connection to the receptionist by heartbeats if more than a configurable amount of heartbeats are missed the client will try to reconnect to its known set of contacts to find a receptionist it can access.</p>
<h2><a href="#when-the-cluster-cannot-be-reached-at-all" name="when-the-cluster-cannot-be-reached-at-all" class="anchor"><span class="anchor-link"></span></a>When the cluster cannot be reached at all</h2>
<p>It is possible to make the cluster client stop entirely if it cannot find a receptionist it can talk to within a configurable interval. This is configured with the <code>reconnect-timeout</code>, which defaults to <code>off</code>. This can be useful when initial contacts are provided from some kind of service registry, cluster node addresses are entirely dynamic and the entire cluster might shut down or crash, be restarted on new addresses. Since the client will be stopped in that case a monitoring actor can watch it and upon <code>Terminate</code> a new set of initial contacts can be fetched and a new cluster client started.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="distributed-pub-sub.html"><i class="icon-prev"></i> <span class="link-prev">Distributed Publish Subscribe in Cluster</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="cluster-sharding.html">Cluster Sharding <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/cluster-client.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
