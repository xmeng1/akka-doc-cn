<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Camel &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/camel.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a>
  <ul>
    <li><a href="remoting.html" class="page">Remoting</a></li>
    <li><a href="remoting-artery.html" class="page">Remoting (codename Artery)</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="io.html" class="page">I/O</a></li>
    <li><a href="io-tcp.html" class="page">Using TCP</a></li>
    <li><a href="io-udp.html" class="page">Using UDP</a></li>
    <li><a href="io-dns.html" class="page">DNS Extension</a></li>
    <li><a href="camel.html#camel" class="active page">Camel</a>
    <ul>
      <li><a href="camel.html#dependency" class="header">Dependency</a></li>
      <li><a href="camel.html#introduction" class="header">Introduction</a></li>
      <li><a href="camel.html#introduction" class="header">Introduction</a></li>
      <li><a href="camel.html#consumer-actors" class="header">Consumer Actors</a></li>
      <li><a href="camel.html#producer-actors" class="header">Producer Actors</a></li>
      <li><a href="camel.html#asynchronous-routing" class="header">Asynchronous routing</a></li>
      <li><a href="camel.html#custom-camel-routes" class="header">Custom Camel routes</a></li>
      <li><a href="camel.html#examples" class="header">Examples</a></li>
      <li><a href="camel.html#configuration" class="header">Configuration</a></li>
      <li><a href="camel.html#additional-resources" class="header">Additional Resources</a></li>
    </ul></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a>
  <ul>
    <li><a href="remoting.html" class="page">Remoting</a></li>
    <li><a href="remoting-artery.html" class="page">Remoting (codename Artery)</a></li>
    <li><a href="serialization.html" class="page">Serialization</a></li>
    <li><a href="io.html" class="page">I/O</a></li>
    <li><a href="io-tcp.html" class="page">Using TCP</a></li>
    <li><a href="io-udp.html" class="page">Using UDP</a></li>
    <li><a href="io-dns.html" class="page">DNS Extension</a></li>
    <li><a href="camel.html#camel" class="active page">Camel</a>
    <ul>
      <li><a href="camel.html#dependency" class="header">Dependency</a></li>
      <li><a href="camel.html#introduction" class="header">Introduction</a></li>
      <li><a href="camel.html#introduction" class="header">Introduction</a></li>
      <li><a href="camel.html#consumer-actors" class="header">Consumer Actors</a></li>
      <li><a href="camel.html#producer-actors" class="header">Producer Actors</a></li>
      <li><a href="camel.html#asynchronous-routing" class="header">Asynchronous routing</a></li>
      <li><a href="camel.html#custom-camel-routes" class="header">Custom Camel routes</a></li>
      <li><a href="camel.html#examples" class="header">Examples</a></li>
      <li><a href="camel.html#configuration" class="header">Configuration</a></li>
      <li><a href="camel.html#additional-resources" class="header">Additional Resources</a></li>
    </ul></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#camel" name="camel" class="anchor"><span class="anchor-link"></span></a>Camel</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Camel, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-camel" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-camel_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-camel_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<p>Camel depends on <code>jaxb-api</code> and <code>javax.activation</code> that were removed from the JDK. If running on a version of the JDK 9 or above also add the following dependencies:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "javax.xml.bind" % "jaxb-api" % "2.3.0"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
  &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
  &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'javax.xml.bind', name: 'jaxb-api', version: '2.3.0'
}</code></pre></dd></dl><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.sun.activation" % "javax.activation" % "1.2.0"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.sun.activation&lt;/groupId&gt;
  &lt;artifactId&gt;javax.activation&lt;/artifactId&gt;
  &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.sun.activation', name: 'javax.activation', version: '1.2.0'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2><div class="callout warning "><div class="callout-title">Warning</div>
<p>Akka Camel is deprecated in favour of <a href="https://github.com/akka/alpakka">Alpakka</a> , the Akka Streams based collection of integrations to various endpoints (including Camel).</p></div>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>The akka-camel module allows Untyped Actors to receive and send messages over a great variety of protocols and APIs. In addition to the native Scala and Java actor API, actors can now exchange messages with other systems over large number of protocols and APIs such as HTTP, SOAP, TCP, FTP, SMTP or JMS, to mention a few. At the moment, approximately 80 protocols and APIs are supported.</p>
<h3><a href="#apache-camel" name="apache-camel" class="anchor"><span class="anchor-link"></span></a>Apache Camel</h3>
<p>The akka-camel module is based on <a href="http://camel.apache.org/">Apache Camel</a>, a powerful and light-weight integration framework for the JVM. For an introduction to Apache Camel you may want to read this <a href="http://architects.dzone.com/articles/apache-camel-integration">Apache Camel article</a>. Camel comes with a large number of <a href="http://camel.apache.org/components.html">components</a> that provide bindings to different protocols and APIs. The <a href="http://code.google.com/p/camel-extra/">camel-extra</a> project provides further components.</p>
<h3><a href="#consumer" name="consumer" class="anchor"><span class="anchor-link"></span></a>Consumer</h3>
<p>Here&rsquo;s an example of using Camel&rsquo;s integration components in Akka.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L18-L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }

class MyEndpoint extends Consumer {
  def endpointUri = &quot;mina2:tcp://localhost:6200?textline=true&quot;

  def receive = {
    case msg: CamelMessage ⇒ { /* ... */ }
    case _                 ⇒ { /* ... */ }
  }
}

// start and expose actor via tcp
import akka.actor.{ ActorSystem, Props }

val system = ActorSystem(&quot;some-system&quot;)
val mina = system.actorOf(Props[MyEndpoint])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/MyEndpoint.java#L8-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;

public class MyEndpoint extends UntypedConsumerActor {
  private String uri;

  public String getEndpointUri() {
    return uri;
  }

  public void onReceive(Object message) throws Exception {
    if (message instanceof CamelMessage) {
      /* ... */
    } else unhandled(message);
  }

  // Extra constructor to change the default uri,
  // for instance to &quot;jetty:http://localhost:8877/example&quot;
  public MyEndpoint(String uri) {
    this.uri = uri;
  }

  public MyEndpoint() {
    this.uri = &quot;mina2:tcp://localhost:6200?textline=true&quot;;
  }
}</code></pre></dd>
</dl>
<p>The above example exposes an actor over a TCP endpoint via Apache Camel&rsquo;s <a href="http://camel.apache.org/mina2.html">Mina component</a>. The actor implements the <span class="group-scala"><code>endpointUri</code></span><span class="group-java"><code>getEndpointUri</code></span> method to define an endpoint from which it can receive messages. After starting the actor, TCP clients can immediately send messages to and receive responses from that actor. If the message exchange should go over HTTP (via Camel&rsquo;s Jetty component), the actor&rsquo;s <span class="group-scala"><code>endpointUri</code></span><span class="group-java"><code>getEndpointUri</code></span> method should return a different URI, for instance <code>jetty:http://localhost:8877/example</code>.</p><div class="group-scala">
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L38-L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }

class MyEndpoint extends Consumer {
  def endpointUri = &quot;jetty:http://localhost:8877/example&quot;

  def receive = {
    case msg: CamelMessage ⇒ { /* ... */ }
    case _                 ⇒ { /* ... */ }
  }
}</code></pre></div><div class="group-java">
<p>In the above case an extra constructor is added that can set the endpoint URI, which would result in the <code>getEndpointUri</code> returning the URI that was set using this constructor.</p></div>
<h3><a href="#producer" name="producer" class="anchor"><span class="anchor-link"></span></a>Producer</h3>
<p>Actors can also trigger message exchanges with external systems i.e. produce to Camel endpoints.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L8-L12" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Props, ActorSystem }
import akka.camel.CamelExtension

import language.postfixOps
import akka.util.Timeout
import akka.actor.Actor
import akka.camel.{ Producer, Oneway }
import akka.actor.{ ActorSystem, Props }

class Orders extends Actor with Producer with Oneway {
  def endpointUri = &quot;jms:queue:Orders&quot;
}

val sys = ActorSystem(&quot;some-system&quot;)
val orders = sys.actorOf(Props[Orders])

orders ! &lt;order amount=&quot;100&quot; currency=&quot;PLN&quot; itemId=&quot;12345&quot;/&gt;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Orders.java#L7-L13" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.javaapi.UntypedProducerActor;

public class Orders extends UntypedProducerActor {
  public String getEndpointUri() {
    return &quot;jms:queue:Orders&quot;;
  }
}</code></pre></dd>
</dl>
<p>In the above example, any message sent to this actor will be sent to the JMS queue <span class="group-scala"><code>orders</code></span><span class="group-java"><code>Orders</code></span>. Producer actors may choose from the same set of Camel components as Consumer actors do.</p><div class="group-java">
<p>Below an example of how to send a message to the <code>Orders</code> producer.</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ProducerTestBase.java#L22-L25" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Props props = Props.create(Orders.class);
ActorRef producer = system.actorOf(props, &quot;jmsproducer&quot;);
producer.tell(&quot;&lt;order amount=\&quot;100\&quot; currency=\&quot;PLN\&quot; itemId=\&quot;12345\&quot;/&gt;&quot;, ActorRef.noSender());</code></pre></div>
<h3><a href="#camelmessage" name="camelmessage" class="anchor"><span class="anchor-link"></span></a>CamelMessage</h3>
<p>The number of Camel components is constantly increasing. The akka-camel module can support these in a plug-and-play manner. Just add them to your application&rsquo;s classpath, define a component-specific endpoint URI and use it to exchange messages over the component-specific protocols or APIs. This is possible because Camel components bind protocol-specific message formats to a Camel-specific <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Message.java">normalized message format</a>. The normalized message format hides protocol-specific details from Akka and makes it therefore very easy to support a large number of protocols through a uniform Camel component interface. The akka-camel module further converts mutable Camel messages into immutable representations which are used by Consumer and Producer actors for pattern matching, transformation, serialization or storage. In the above example of the Orders Producer, the XML message is put in the body of a newly created Camel Message with an empty set of headers. You can also create a CamelMessage yourself with the appropriate body and headers as you see fit.</p>
<h3><a href="#camelextension" name="camelextension" class="anchor"><span class="anchor-link"></span></a>CamelExtension</h3>
<p>The akka-camel module is implemented as an Akka Extension, the <code>CamelExtension</code> object. Extensions will only be loaded once per <code>ActorSystem</code>, which will be managed by Akka. The <code>CamelExtension</code> object provides access to the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> <span class="group-scala">trait</span><span class="group-java">interface</span>. The <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> <span class="group-scala">trait</span><span class="group-java">interface</span> in turn provides access to two important Apache Camel objects, the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> and the <code>ProducerTemplate</code>. Below you can see how you can get access to these Apache Camel objects.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L68-L72" target="_blank" title="Go to snippet source"></a><code class="language-scala">val system = ActorSystem(&quot;some-system&quot;)
val camel = CamelExtension(system)
val camelContext = camel.context
val producerTemplate = camel.template
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/CamelExtensionTest.java#L20-L23" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Camel camel = CamelExtension.get(system);
CamelContext camelContext = camel.context();
ProducerTemplate producerTemplate = camel.template();</code></pre></dd>
</dl>
<p>One <code>CamelExtension</code> is only loaded once for every one <code>ActorSystem</code>, which makes it safe to call the <code>CamelExtension</code> at any point in your code to get to the Apache Camel objects associated with it. There is one <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> and one <code>ProducerTemplate</code> for every one <code>ActorSystem</code> that uses a <code>CamelExtension</code>. By Default, a new <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> is created when the <code>CamelExtension</code> starts. If you want to inject your own context instead, you can <span class="group-scala">extend</span><span class="group-java">implement</span> the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/ContextProvider.scala">ContextProvider</a> <span class="group-scala">trait</span><span class="group-java">interface</span> and add the FQCN of your implementation in the config, as the value of the &ldquo;akka.camel.context-provider&rdquo;. This interface define a single method <code>getContext()</code> used to load the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a>.</p>
<p>Below an example on how to add the ActiveMQ component to the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a>, which is required when you would like to use the ActiveMQ component.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L77-L82" target="_blank" title="Go to snippet source"></a><code class="language-scala">// import org.apache.activemq.camel.component.ActiveMQComponent
val system = ActorSystem(&quot;some-system&quot;)
val camel = CamelExtension(system)
val camelContext = camel.context
// camelContext.addComponent(&quot;activemq&quot;, ActiveMQComponent.activeMQComponent(
//   &quot;vm://localhost?broker.persistent=false&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/CamelExtensionTest.java#L30-L34" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Camel camel = CamelExtension.get(system);
CamelContext camelContext = camel.context();
// camelContext.addComponent(&quot;activemq&quot;, ActiveMQComponent.activeMQComponent(
//   &quot;vm://localhost?broker.persistent=false&quot;));</code></pre></dd>
</dl>
<p>The <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> joins the lifecycle of the <code>ActorSystem</code> and <code>CamelExtension</code> it is associated with; the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> is started when the <code>CamelExtension</code> is created, and it is shut down when the associated <code>ActorSystem</code> is shut down. The same is true for the <code>ProducerTemplate</code>.</p>
<p>The <code>CamelExtension</code> is used by both <code>Producer</code> and <code>Consumer</code> actors to interact with Apache Camel internally. You can access the <code>CamelExtension</code> inside a <code>Producer</code> or a <code>Consumer</code> using the <code>camel</code> <span class="group-scala">definition</span><span class="group-java">method</span>, or get straight at the <code>CamelContext</code> using the <span class="group-scala"><code>camelContext</code> definition</span><span class="group-java"><code>getCamelContext</code> method or to the <code>ProducerTemplate</code> using the <code>getProducerTemplate</code> method</span>. Actors are created and started asynchronously. When a <code>Consumer</code> actor is created, the <code>Consumer</code> is published at its Camel endpoint (more precisely, the route is added to the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/CamelContext.java">CamelContext</a> from the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Endpoint.java">Endpoint</a> to the actor). When a <code>Producer</code> actor is created, a <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java">SendProcessor</a> and <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Endpoint.java">Endpoint</a> are created so that the Producer can send messages to it. Publication is done asynchronously; setting up an endpoint may still be in progress after you have requested the actor to be created. Some Camel components can take a while to startup, and in some cases you might want to know when the endpoints are activated and ready to be used. The <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Camel.scala">Camel</a> <span class="group-scala">trait</span><span class="group-java">interface</span> allows you to find out when the endpoint is activated or deactivated.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L87-L104" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }
import scala.concurrent.duration._

class MyEndpoint extends Consumer {
  def endpointUri = &quot;mina2:tcp://localhost:6200?textline=true&quot;

  def receive = {
    case msg: CamelMessage ⇒ { /* ... */ }
    case _                 ⇒ { /* ... */ }
  }
}
val system = ActorSystem(&quot;some-system&quot;)
val camel = CamelExtension(system)
val actorRef = system.actorOf(Props[MyEndpoint])
// get a future reference to the activation of the endpoint of the Consumer Actor
val activationFuture = camel.activationFutureFor(actorRef)(
  timeout = 10 seconds,
  executor = system.dispatcher)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ActivationTestBase.java#L7-L38" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.camel.Camel;
import akka.camel.CamelExtension;
import akka.camel.javaapi.UntypedConsumerActor;
import akka.testkit.javadsl.TestKit;
import akka.util.Timeout;
import jdocs.AbstractJavaTest;
import scala.concurrent.Future;
import scala.concurrent.duration.Duration;
import static java.util.concurrent.TimeUnit.SECONDS;

// ..
ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Props props = Props.create(MyConsumer.class);
ActorRef producer = system.actorOf(props, &quot;myproducer&quot;);
Camel camel = CamelExtension.get(system);
// get a future reference to the activation of the endpoint of the Consumer Actor
Timeout timeout = new Timeout(Duration.create(10, SECONDS));
Future&lt;ActorRef&gt; activationFuture =
    camel.activationFutureFor(producer, timeout, system.dispatcher());</code></pre></dd>
</dl>
<p>The above code shows that you can get a <code>Future</code> to the activation of the route from the endpoint to the actor, or you can wait in a blocking fashion on the activation of the route. An <code>ActivationTimeoutException</code> is thrown if the endpoint could not be activated within the specified timeout. Deactivation works in a similar fashion:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Introduction.scala#L107-L111" target="_blank" title="Go to snippet source"></a><code class="language-scala">system.stop(actorRef)
// get a future reference to the deactivation of the endpoint of the Consumer Actor
val deactivationFuture = camel.deactivationFutureFor(actorRef)(
  timeout = 10 seconds,
  executor = system.dispatcher)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ActivationTestBase.java#L41-L45" target="_blank" title="Go to snippet source"></a><code class="language-java">// ..
system.stop(producer);
// get a future reference to the deactivation of the endpoint of the Consumer Actor
Future&lt;ActorRef&gt; deactivationFuture =
    camel.deactivationFutureFor(producer, timeout, system.dispatcher());</code></pre></dd>
</dl>
<p>Deactivation of a Consumer or a Producer actor happens when the actor is terminated. For a Consumer, the route to the actor is stopped. For a Producer, the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java">SendProcessor</a> is stopped. A <code>DeActivationTimeoutException</code> is thrown if the associated camel objects could not be deactivated within the specified timeout.</p>
<h2><a href="#consumer-actors" name="consumer-actors" class="anchor"><span class="anchor-link"></span></a>Consumer Actors</h2>
<p>For objects to receive messages, they must <span class="group-scala">mixin the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Consumer.scala">Consumer</a> trait</span><span class="group-java">inherit from the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedConsumer.scala">UntypedConsumerActor</a> class</span>. For example, the following actor class (Consumer1) implements the <span class="group-scala"><code>endpointUri</code></span><span class="group-java"><code>getEndpointUri</code></span> method, which is declared in the <span class="group-scala"><code>Consumer</code> trait</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedConsumer.scala">UntypedConsumerActor</a> class</span>, in order to receive messages from the <code>file:data/input/actor</code> Camel endpoint.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Consumers.scala#L12-L20" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }

class Consumer1 extends Consumer {
  def endpointUri = &quot;file:data/input/actor&quot;

  def receive = {
    case msg: CamelMessage ⇒ println(&quot;received %s&quot; format msg.bodyAs[String])
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Consumer1.java#L7-L26" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;
import akka.event.Logging;
import akka.event.LoggingAdapter;

public class Consumer1 extends UntypedConsumerActor {
  LoggingAdapter log = Logging.getLogger(getContext().system(), this);

  public String getEndpointUri() {
    return &quot;file:data/input/actor&quot;;
  }

  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      String body = camelMessage.getBodyAs(String.class, getCamelContext());
      log.info(&quot;Received message: {}&quot;, body);
    } else unhandled(message);
  }
}</code></pre></dd>
</dl>
<p>Whenever a file is put into the data/input/actor directory, its content is picked up by the Camel <a href="http://camel.apache.org/file2.html">file component</a> and sent as message to the actor. Messages consumed by actors from Camel endpoints are of type <a href="#camelmessage">CamelMessage</a>. These are immutable representations of Camel messages.</p>
<p>Here&rsquo;s another example that sets the endpointUri to <code>jetty:http://localhost:8877/camel/default</code>. It causes Camel&rsquo;s Jetty component to start an embedded <a href="http://www.eclipse.org/jetty/">Jetty</a> server, accepting HTTP connections from localhost on port 8877.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Consumers.scala#L25-L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }

class Consumer2 extends Consumer {
  def endpointUri = &quot;jetty:http://localhost:8877/camel/default&quot;

  def receive = {
    case msg: CamelMessage ⇒ sender() ! (&quot;Hello %s&quot; format msg.bodyAs[String])
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Consumer2.java#L7-L22" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;

public class Consumer2 extends UntypedConsumerActor {
  public String getEndpointUri() {
    return &quot;jetty:http://localhost:8877/camel/default&quot;;
  }

  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      String body = camelMessage.getBodyAs(String.class, getCamelContext());
      getSender().tell(String.format(&quot;Received message: %s&quot;, body), getSelf());
    } else unhandled(message);
  }
}</code></pre></dd>
</dl>
<p>After starting the actor, clients can send messages to that actor by POSTing to <code>http://localhost:8877/camel/default</code>. The actor sends a response by using the sender <span class="group-scala"><code>!</code></span><span class="group-java"><code>getSender().tell</code></span> method. For returning a message body and headers to the HTTP client the response type should be <a href="#camelmessage">CamelMessage</a>. For any other response type, a new CamelMessage object is created by akka-camel with the actor response as message body.</p>
<a id="camel-acknowledgements"></a>
<h3><a href="#delivery-acknowledgements" name="delivery-acknowledgements" class="anchor"><span class="anchor-link"></span></a>Delivery acknowledgements</h3>
<p>With in-out message exchanges, clients usually know that a message exchange is done when they receive a reply from a consumer actor. The reply message can be a CamelMessage (or any object which is then internally converted to a CamelMessage) on success, and a Failure message on failure.</p>
<p>With in-only message exchanges, by default, an exchange is done when a message is added to the consumer actor&rsquo;s mailbox. Any failure or exception that occurs during processing of that message by the consumer actor cannot be reported back to the endpoint in this case. To allow consumer actors to positively or negatively acknowledge the receipt of a message from an in-only message exchange, they need to override the <code>autoAck</code> method to return false. In this case, consumer actors must reply either with a special akka.camel.Ack message (positive acknowledgement) or a akka.actor.Status.Failure (negative acknowledgement).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Consumers.scala#L38-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }
import akka.camel.Ack
import akka.actor.Status.Failure

class Consumer3 extends Consumer {
  override def autoAck = false

  def endpointUri = &quot;jms:queue:test&quot;

  def receive = {
    case msg: CamelMessage ⇒
      sender() ! Ack
      // on success
      // ..
      val someException = new Exception(&quot;e1&quot;)
      // on failure
      sender() ! Failure(someException)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Consumer3.java#L7-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.Status;
import akka.camel.Ack;
import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;

public class Consumer3 extends UntypedConsumerActor {

  @Override
  public boolean autoAck() {
    return false;
  }

  public String getEndpointUri() {
    return &quot;jms:queue:test&quot;;
  }

  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      getSender().tell(Ack.getInstance(), getSelf());
      // on success
      // ..
      Exception someException = new Exception(&quot;e1&quot;);
      // on failure
      getSender().tell(new Status.Failure(someException), getSelf());
    } else unhandled(message);
  }
}</code></pre></dd>
</dl>
<a id="camel-timeout"></a>
<h3><a href="#consumer-timeout" name="consumer-timeout" class="anchor"><span class="anchor-link"></span></a>Consumer timeout</h3>
<p>Camel Exchanges (and their corresponding endpoints) that support two-way communications need to wait for a response from an actor before returning it to the initiating client. For some endpoint types, timeout values can be defined in an endpoint-specific way which is described in the documentation of the individual Camel components. Another option is to configure timeouts on the level of consumer actors.</p>
<p>Two-way communications between a Camel endpoint and an actor are initiated by sending the request message to the actor with the <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-actor/src/main/scala/akka/pattern/AskSupport.scala">ask</a></span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-actor/src/main/scala/akka/pattern/Patterns.scala">ask</a></span> pattern and the actor replies to the endpoint when the response is ready. The ask request to the actor can timeout, which will result in the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Exchange.java">Exchange</a> failing with a TimeoutException set on the failure of the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/Exchange.java">Exchange</a>. The timeout on the consumer actor can be overridden with the <code>replyTimeout</code>, as shown below.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Consumers.scala#L61-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ CamelMessage, Consumer }
import scala.concurrent.duration._

class Consumer4 extends Consumer {
  def endpointUri = &quot;jetty:http://localhost:8877/camel/default&quot;
  override def replyTimeout = 500 millis
  def receive = {
    case msg: CamelMessage ⇒ sender() ! (&quot;Hello %s&quot; format msg.bodyAs[String])
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Consumer4.java#L7-L33" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;
import scala.concurrent.duration.Duration;
import scala.concurrent.duration.FiniteDuration;

import java.util.concurrent.TimeUnit;

public class Consumer4 extends UntypedConsumerActor {
  private static final FiniteDuration timeout = Duration.create(500, TimeUnit.MILLISECONDS);

  @Override
  public FiniteDuration replyTimeout() {
    return timeout;
  }

  public String getEndpointUri() {
    return &quot;jetty:http://localhost:8877/camel/default&quot;;
  }

  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      String body = camelMessage.getBodyAs(String.class, getCamelContext());
      getSender().tell(String.format(&quot;Hello %s&quot;, body), getSelf());
    } else unhandled(message);
  }
}</code></pre></dd>
</dl>
<h2><a href="#producer-actors" name="producer-actors" class="anchor"><span class="anchor-link"></span></a>Producer Actors</h2>
<p>For sending messages to Camel endpoints, actors need to <span class="group-scala">mixin the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> trait</span> <span class="group-java">inherit from the <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a> class</span> and implement the <code>getEndpointUri</code> method.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L13-L20" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
import akka.actor.{ Props, ActorSystem }
import akka.camel.{ Producer, CamelMessage }
import akka.util.Timeout

class Producer1 extends Actor with Producer {
  def endpointUri = &quot;http://localhost:8080/news&quot;
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Producer1.java#L7-L13" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.javaapi.UntypedProducerActor;

public class Producer1 extends UntypedProducerActor {
  public String getEndpointUri() {
    return &quot;http://localhost:8080/news&quot;;
  }
}</code></pre></dd>
</dl>
<p>Producer1 inherits a default implementation of the <span class="group-scala"><code>receive</code></span><span class="group-java"><code>onReceive</code></span> method from the <span class="group-scala">Producer trait</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a></span> class. To customize a producer actor&rsquo;s default behavior you must override the <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformResponse</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a>.onTransformResponse</span> and <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformOutgoingMessage methods</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a>.onTransformOutgoingMessage methods</span>. This is explained later in more detail. Producer Actors cannot override the <span class="group-scala">default <a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.receive</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a>.onReceive</span> method.</p>
<p>Any message sent to a <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala"><code>Producer</code></a></span><span class="group-java">Producer</span> actor will be sent to the associated Camel endpoint, in the above example to <code>http://localhost:8080/news</code>. The <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala"><code>Producer</code></a></span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala"><code>UntypedProducerActor</code></a></span> always sends messages asynchronously. Response messages (if supported by the configured endpoint) will, by default, be returned to the original sender. The following example uses the ask pattern to send a message to a Producer actor and waits for a response.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L23-L29" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.pattern.ask
import scala.concurrent.duration._
implicit val timeout = Timeout(10 seconds)

val system = ActorSystem(&quot;some-system&quot;)
val producer = system.actorOf(Props[Producer1])
val future = producer.ask(&quot;some request&quot;).mapTo[CamelMessage]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ProducerTestBase.java#L33-L37" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Props props = Props.create(FirstProducer.class);
ActorRef producer = system.actorOf(props, &quot;myproducer&quot;);
CompletionStage&lt;Object&gt; future =
    Patterns.ask(producer, &quot;some request&quot;, Duration.ofMillis(1000L));</code></pre></dd>
</dl>
<p>The future contains the response <code>CamelMessage</code>, or an <code>AkkaCamelException</code> when an error occurred, which contains the headers of the response.</p>
<a id="camel-custom-processing"></a>
<h3><a href="#custom-processing" name="custom-processing" class="anchor"><span class="anchor-link"></span></a>Custom Processing</h3>
<p>Instead of replying to the initial sender, producer actors can implement custom response processing by overriding the <span class="group-scala"><code>routeResponse</code></span><span class="group-java"><code>onRouteResponse</code></span> method. In the following example, the response message is forwarded to a target actor instead of being replied to the original sender.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L34-L56" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Actor, ActorRef }
import akka.camel.{ Producer, CamelMessage }
import akka.actor.{ Props, ActorSystem }

class ResponseReceiver extends Actor {
  def receive = {
    case msg: CamelMessage ⇒
    // do something with the forwarded response
  }
}

class Forwarder(uri: String, target: ActorRef) extends Actor with Producer {
  def endpointUri = uri

  override def routeResponse(msg: Any): Unit = { target forward msg }
}
val system = ActorSystem(&quot;some-system&quot;)
val receiver = system.actorOf(Props[ResponseReceiver])
val forwardResponse = system.actorOf(
  Props(classOf[Forwarder], this, &quot;http://localhost:8080/news/akka&quot;, receiver))
// the Forwarder sends out a request to the web page and forwards the response to
// the ResponseReceiver
forwardResponse ! &quot;some request&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ResponseReceiver.java#L7-L16" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.UntypedAbstractActor;
import akka.camel.CamelMessage;

public class ResponseReceiver extends UntypedAbstractActor {
  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      // do something with the forwarded response
    }
  }
}</code></pre>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Forwarder.java#L7-L27" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorRef;
import akka.camel.javaapi.UntypedProducerActor;

public class Forwarder extends UntypedProducerActor {
  private String uri;
  private ActorRef target;

  public Forwarder(String uri, ActorRef target) {
    this.uri = uri;
    this.target = target;
  }

  public String getEndpointUri() {
    return uri;
  }

  @Override
  public void onRouteResponse(Object message) {
    target.forward(message, getContext());
  }
}</code></pre>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/OnRouteResponseTestBase.java#L14-L21" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Props receiverProps = Props.create(ResponseReceiver.class);
final ActorRef receiver = system.actorOf(receiverProps, &quot;responseReceiver&quot;);
ActorRef forwardResponse =
    system.actorOf(Props.create(Forwarder.class, &quot;http://localhost:8080/news/akka&quot;, receiver));
// the Forwarder sends out a request to the web page and forwards the response to
// the ResponseReceiver
forwardResponse.tell(&quot;some request&quot;, ActorRef.noSender());</code></pre></dd>
</dl>
<p>Before producing messages to endpoints, producer actors can pre-process them by overriding the <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a>.transformOutgoingMessage</span> <span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a>.onTransformOutgoingMessag</span> method.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L61-L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
import akka.camel.{ Producer, CamelMessage }

class Transformer(uri: String) extends Actor with Producer {
  def endpointUri = uri

  def upperCase(msg: CamelMessage) = msg.mapBody {
    body: String ⇒ body.toUpperCase
  }

  override def transformOutgoingMessage(msg: Any) = msg match {
    case msg: CamelMessage ⇒ upperCase(msg)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Transformer.java#L7-L41" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedProducerActor;
import akka.dispatch.Mapper;

public class Transformer extends UntypedProducerActor {
  private String uri;

  public Transformer(String uri) {
    this.uri = uri;
  }

  public String getEndpointUri() {
    return uri;
  }

  private CamelMessage upperCase(CamelMessage msg) {
    return msg.mapBody(
        new Mapper&lt;String, String&gt;() {
          @Override
          public String apply(String body) {
            return body.toUpperCase();
          }
        });
  }

  @Override
  public Object onTransformOutgoingMessage(Object message) {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      return upperCase(camelMessage);
    } else {
      return message;
    }
  }
}</code></pre></dd>
</dl>
<h3><a href="#producer-configuration-options" name="producer-configuration-options" class="anchor"><span class="anchor-link"></span></a>Producer configuration options</h3>
<p>The interaction of producer actors with Camel endpoints can be configured to be one-way or two-way (by initiating in-only or in-out message exchanges, respectively). By default, the producer initiates an in-out message exchange with the endpoint. For initiating an in-only exchange, producer actors have to override the <span class="group-scala"><code>oneway</code></span><span class="group-java"><code>isOneway</code></span> method to return true.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L79-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Actor, Props, ActorSystem }
import akka.camel.Producer

class OnewaySender(uri: String) extends Actor with Producer {
  def endpointUri = uri
  override def oneway: Boolean = true
}

val system = ActorSystem(&quot;some-system&quot;)
val producer = system.actorOf(Props(classOf[OnewaySender], this, &quot;activemq:FOO.BAR&quot;))
producer ! &quot;Some message&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/OnewaySender.java#L7-L24" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.camel.javaapi.UntypedProducerActor;

public class OnewaySender extends UntypedProducerActor {
  private String uri;

  public OnewaySender(String uri) {
    this.uri = uri;
  }

  public String getEndpointUri() {
    return uri;
  }

  @Override
  public boolean isOneway() {
    return true;
  }
}</code></pre></dd>
</dl>
<h3><a href="#message-correlation" name="message-correlation" class="anchor"><span class="anchor-link"></span></a>Message correlation</h3>
<p>To correlate request with response messages, applications can set the <code>Message.MessageExchangeId</code> message header.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L95-L105" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.{ Producer, CamelMessage }
import akka.actor.Actor
import akka.actor.{ Props, ActorSystem }

class Producer2 extends Actor with Producer {
  def endpointUri = &quot;activemq:FOO.BAR&quot;
}
val system = ActorSystem(&quot;some-system&quot;)
val producer = system.actorOf(Props[Producer2])

producer ! CamelMessage(&quot;bar&quot;, Map(CamelMessage.MessageExchangeId -&gt; &quot;123&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ProducerTestBase.java#L45-L52" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
Props props = Props.create(Orders.class);
ActorRef producer = system.actorOf(props, &quot;jmsproducer&quot;);
Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
headers.put(CamelMessage.MessageExchangeId(), &quot;123&quot;);
producer.tell(
    new CamelMessage(&quot;&lt;order amount=\&quot;100\&quot; currency=\&quot;PLN\&quot; &quot; + &quot;itemId=\&quot;12345\&quot;/&gt;&quot;, headers),
    ActorRef.noSender());</code></pre></dd>
</dl>
<h3><a href="#producertemplate" name="producertemplate" class="anchor"><span class="anchor-link"></span></a>ProducerTemplate</h3>
<p>The <span class="group-scala"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/Producer.scala">Producer</a> trait</span><span class="group-java"><a href="http://github.com/akka/akka/tree/master/akka-camel/src/main/scala/akka/camel/javaapi/UntypedProducerActor.scala">UntypedProducerActor</a> class</span> is a very convenient way for actors to produce messages to Camel endpoints. Actors may also use a Camel <code>ProducerTemplate</code> for producing messages to endpoints.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L110-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
class MyActor extends Actor {
  def receive = {
    case msg ⇒
      val template = CamelExtension(context.system).template
      template.sendBody(&quot;direct:news&quot;, msg)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/MyActor.java#L7-L18" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.UntypedAbstractActor;
import akka.camel.Camel;
import akka.camel.CamelExtension;
import org.apache.camel.ProducerTemplate;

public class MyActor extends UntypedAbstractActor {
  public void onReceive(Object message) {
    Camel camel = CamelExtension.get(getContext().getSystem());
    ProducerTemplate template = camel.template();
    template.sendBody(&quot;direct:news&quot;, message);
  }
}</code></pre></dd>
</dl>
<p>For initiating a two-way message exchange, one of the <code>ProducerTemplate.request*</code> methods must be used.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/Producers.scala#L122-L129" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Actor
class MyActor extends Actor {
  def receive = {
    case msg ⇒
      val template = CamelExtension(context.system).template
      sender() ! template.requestBody(&quot;direct:news&quot;, msg)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/RequestBodyActor.java#L7-L24" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractActor;
import akka.camel.Camel;
import akka.camel.CamelExtension;
import org.apache.camel.ProducerTemplate;

public class RequestBodyActor extends AbstractActor {
  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .matchAny(
            message -&gt; {
              Camel camel = CamelExtension.get(getContext().getSystem());
              ProducerTemplate template = camel.template();
              getSender().tell(template.requestBody(&quot;direct:news&quot;, message), getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl>
<a id="camel-asynchronous-routing"></a>
<h2><a href="#asynchronous-routing" name="asynchronous-routing" class="anchor"><span class="anchor-link"></span></a>Asynchronous routing</h2>
<p>In-out message exchanges between endpoints and actors are designed to be asynchronous. This is the case for both, consumer and producer actors.</p>
<ul>
  <li>A consumer endpoint sends request messages to its consumer actor using the <span class="group-scala"><code>!</code> (tell) operator </span><span class="group-java"><code>tell</code> method</span> and the actor returns responses with <span class="group-scala"><code>sender !</code></span><span class="group-java"><code>getSender().tell</code></span> once they are ready.</li>
  <li>A producer actor sends request messages to its endpoint using Camel&rsquo;s asynchronous routing engine. Asynchronous responses are wrapped and added to the producer actor&rsquo;s mailbox for later processing. By default, response messages are returned to the initial sender but this can be overridden by Producer implementations (see also description of the <span class="group-scala"><code>routeResponse</code></span><span class="group-java"><code>onRouteResponse</code></span> method in <a href="#camel-custom-processing">Custom Processing</a>).</li>
</ul>
<p>However, asynchronous two-way message exchanges, without allocating a thread for the full duration of exchange, cannot be generically supported by Camel&rsquo;s asynchronous routing engine alone. This must be supported by the individual Camel components (from which endpoints are created) as well. They must be able to suspend any work started for request processing (thereby freeing threads to do other work) and resume processing when the response is ready. This is currently the case for a <a href="http://camel.apache.org/asynchronous-routing-engine.html">subset of components</a> such as the Jetty component. All other Camel components can still be used, but they will cause allocation of a thread for the duration of an in-out message exchange. There&rsquo;s also <a href="#camel-examples">Examples</a> that implements both, an asynchronous consumer and an asynchronous producer, with the jetty component.</p>
<p>If the used Camel component is blocking it might be necessary to use a separate <a href="dispatchers.html">dispatcher</a> for the producer. The Camel processor is invoked by a child actor of the producer and the dispatcher can be defined in the deployment section of the configuration. For example, if your producer actor has path <code>/user/integration/output</code> the dispatcher of the child actor can be defined with:</p>
<pre><code>akka.actor.deployment {
  /integration/output/* {
    dispatcher = my-dispatcher
  }
}
</code></pre>
<h2><a href="#custom-camel-routes" name="custom-camel-routes" class="anchor"><span class="anchor-link"></span></a>Custom Camel routes</h2>
<p>In all the examples so far, routes to consumer actors have been automatically constructed by akka-camel, when the actor was started. Although the default route construction templates, used by akka-camel internally, are sufficient for most use cases, some applications may require more specialized routes to actors. The akka-camel module provides two mechanisms for customizing routes to actors, which will be explained in this section. These are:</p>
<ul>
  <li>Usage of <a href="#camel-components">Akka Camel components</a> to access actors. Any Camel route can use these components to access Akka actors.</li>
  <li><a href="#camel-intercepting-route-construction">Intercepting route construction</a> to actors. This option gives you the ability to change routes that have already been added to Camel. Consumer actors have a hook into the route definition process which can be used to change the route.</li>
</ul>
<a id="camel-components"></a>
<h3><a href="#akka-camel-components" name="akka-camel-components" class="anchor"><span class="anchor-link"></span></a>Akka Camel components</h3>
<p>Akka actors can be accessed from Camel routes using the actor Camel component. This component can be used to access any Akka actor (not only consumer actors) from Camel routes, as described in the following sections.</p>
<a id="access-to-actors"></a>
<h3><a href="#access-to-actors" name="access-to-actors" class="anchor"><span class="anchor-link"></span></a>Access to actors</h3>
<p>To access actors from custom Camel routes, the actor Camel component should be used. It fully supports Camel&rsquo;s <a href="http://camel.apache.org/asynchronous-routing-engine.html">asynchronous routing engine</a>.</p>
<p>This component accepts the following endpoint URI format:</p>
<ul>
  <li><code>[&lt;actor-path&gt;]?&lt;options&gt;</code></li>
</ul>
<p>where <code>&lt;actor-path&gt;</code> is the <code>ActorPath</code> to the actor. The <code>&lt;options&gt;</code> are name-value pairs separated by <code>&amp;</code> (i.e. <code>name1=value1&amp;name2=value2&amp;...</code>).</p>
<h4><a href="#uri-options" name="uri-options" class="anchor"><span class="anchor-link"></span></a>URI options</h4>
<p>The following URI options are supported:</p>
<table>
  <thead>
    <tr>
      <th>Name </th>
      <th>Type </th>
      <th>Default </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>replyTimeout </td>
      <td>Duration </td>
      <td>false </td>
      <td>The reply timeout, specified in the same way that you use the duration in akka, for instance <code>10 seconds</code> except that in the url it is handy to use a + between the amount and the unit, like for example <code>200+millis</code> See also <a href="#camel-timeout">Consumer timeout</a>.</td>
    </tr>
    <tr>
      <td>autoAck </td>
      <td>Boolean </td>
      <td>true </td>
      <td>If set to true, in-only message exchanges are auto-acknowledged when the message is added to the actor&rsquo;s mailbox. If set to false, actors must acknowledge the receipt of the message. See also <a href="#camel-acknowledgements">Delivery acknowledgements</a>. </td>
    </tr>
  </tbody>
</table>
<p>Here&rsquo;s an actor endpoint URI example containing an actor path:</p>
<pre><code>akka://some-system/user/myconsumer?autoAck=false&amp;replyTimeout=100+millis
</code></pre>
<p>In the following example, a custom route to an actor is created, using the actor&rsquo;s path. </p>
<p>The Akka camel package contains an implicit <code>toActorRouteDefinition</code> that allows for a route to reference an <code>ActorRef</code> directly as shown in the below example, The route starts from a <a href="http://www.eclipse.org/jetty/">Jetty</a> endpoint and ends at the target actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/CustomRoute.scala#L15-L37" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ Props, ActorSystem, Actor, ActorRef }
import akka.camel.{ CamelMessage, CamelExtension }
import org.apache.camel.builder.RouteBuilder
import akka.camel._
class Responder extends Actor {
  def receive = {
    case msg: CamelMessage ⇒
      sender() ! (msg.mapBody {
        body: String ⇒ &quot;received %s&quot; format body
      })
  }
}

class CustomRouteBuilder(system: ActorSystem, responder: ActorRef)
  extends RouteBuilder {
  def configure: Unit = {
    from(&quot;jetty:http://localhost:8877/camel/custom&quot;).to(responder)
  }
}
val system = ActorSystem(&quot;some-system&quot;)
val camel = CamelExtension(system)
val responder = system.actorOf(Props[Responder], name = &quot;TestResponder&quot;)
camel.context.addRoutes(new CustomRouteBuilder(system, responder))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/Responder.java#L7-L29" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.UntypedAbstractActor;
import akka.camel.CamelMessage;
import akka.dispatch.Mapper;

public class Responder extends UntypedAbstractActor {

  public void onReceive(Object message) {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      getSender().tell(createResponse(camelMessage), getSelf());
    } else unhandled(message);
  }

  private CamelMessage createResponse(CamelMessage msg) {
    return msg.mapBody(
        new Mapper&lt;String, String&gt;() {
          @Override
          public String apply(String body) {
            return String.format(&quot;received %s&quot;, body);
          }
        });
  }
}</code></pre>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/CustomRouteBuilder.java#L7-L21" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.ActorRef;
import akka.camel.internal.component.CamelPath;
import org.apache.camel.builder.RouteBuilder;

public class CustomRouteBuilder extends RouteBuilder {
  private String uri;

  public CustomRouteBuilder(ActorRef responder) {
    uri = CamelPath.toUri(responder);
  }

  public void configure() throws Exception {
    from(&quot;jetty:http://localhost:8877/camel/custom&quot;).to(uri);
  }
}</code></pre>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/CustomRouteTestBase.java#L17-L21" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;some-system&quot;);
try {
  Camel camel = CamelExtension.get(system);
  ActorRef responder = system.actorOf(Props.create(Responder.class), &quot;TestResponder&quot;);
  camel.context().addRoutes(new CustomRouteBuilder(responder));</code></pre></dd>
</dl>
<p><span class="group-java">The <code>CamelPath.toCamelUri</code> converts the <code>ActorRef</code> to the Camel actor component URI format which points to the actor endpoint as described above.</span> When a message is received on the jetty endpoint, it is routed to the <code>Responder</code> actor, which in return replies back to the client of the HTTP request.</p>
<a id="camel-intercepting-route-construction"></a>
<h3><a href="#intercepting-route-construction" name="intercepting-route-construction" class="anchor"><span class="anchor-link"></span></a>Intercepting route construction</h3>
<p>The previous section, <a href="#camel-components-2">camel components</a>, explained how to setup a route to an actor manually. It was the application&rsquo;s responsibility to define the route and add it to the current CamelContext. This section explains a more convenient way to define custom routes: akka-camel is still setting up the routes to consumer actors (and adds these routes to the current CamelContext) but applications can define extensions to these routes. Extensions can be defined with Camel&rsquo;s <a href="http://camel.apache.org/dsl.html">Java DSL</a> or <a href="http://camel.apache.org/scala-dsl.html">Scala DSL</a>. For example, an extension could be a custom error handler that redelivers messages from an endpoint to an actor&rsquo;s bounded mailbox when the mailbox was full.</p>
<p>The following examples demonstrate how to extend a route to a consumer actor for handling exceptions thrown by that actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/camel/CustomRoute.scala#L43-L58" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.camel.Consumer

import org.apache.camel.builder.Builder
import org.apache.camel.model.RouteDefinition

class ErrorThrowingConsumer(override val endpointUri: String) extends Consumer {
  def receive = {
    case msg: CamelMessage ⇒ throw new Exception(&quot;error: %s&quot; format msg.body)
  }
  override def onRouteDefinition = (rd) ⇒ rd.onException(classOf[Exception]).
    handled(true).transform(Builder.exceptionMessage).end

  final override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
    sender() ! Failure(reason)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/camel/ErrorThrowingConsumer.java#L7-L56" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.Status;
import akka.camel.CamelMessage;
import akka.camel.javaapi.UntypedConsumerActor;
import akka.dispatch.Mapper;
import org.apache.camel.builder.Builder;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.model.RouteDefinition;
import scala.Option;

public class ErrorThrowingConsumer extends UntypedConsumerActor {
  private String uri;

  private static Mapper&lt;RouteDefinition, ProcessorDefinition&lt;?&gt;&gt; mapper =
      new Mapper&lt;RouteDefinition, ProcessorDefinition&lt;?&gt;&gt;() {
        public ProcessorDefinition&lt;?&gt; apply(RouteDefinition rd) {
          // Catch any exception and handle it by returning the exception message
          // as response
          return rd.onException(Exception.class)
              .handled(true)
              .transform(Builder.exceptionMessage())
              .end();
        }
      };

  public ErrorThrowingConsumer(String uri) {
    this.uri = uri;
  }

  public String getEndpointUri() {
    return uri;
  }

  public void onReceive(Object message) throws Exception {
    if (message instanceof CamelMessage) {
      CamelMessage camelMessage = (CamelMessage) message;
      String body = camelMessage.getBodyAs(String.class, getCamelContext());
      throw new Exception(String.format(&quot;error: %s&quot;, body));
    } else unhandled(message);
  }

  @Override
  public Mapper&lt;RouteDefinition, ProcessorDefinition&lt;?&gt;&gt; getRouteDefinitionHandler() {
    return mapper;
  }

  @Override
  public void preRestart(Throwable reason, Option&lt;Object&gt; message) {
    getSender().tell(new Status.Failure(reason), getSelf());
  }
}</code></pre></dd>
</dl>
<p>The above ErrorThrowingConsumer sends the Failure back to the sender in preRestart because the Exception that is thrown in the actor would otherwise just crash the actor, by default the actor would be restarted, and the response would never reach the client of the Consumer.</p>
<p>The akka-camel module creates a RouteDefinition instance by calling from(endpointUri) on a Camel RouteBuilder (where endpointUri is the endpoint URI of the consumer actor) and passes that instance as argument to the route definition handler *). The route definition handler then extends the route and returns a ProcessorDefinition (in the above example, the ProcessorDefinition returned by the end method. See the <a href="https://svn.apache.org/repos/asf/camel/tags/camel-2.8.0/camel-core/src/main/java/org/apache/camel/model/">org.apache.camel.model</a> package for details). After executing the route definition handler, akka-camel finally calls a to(targetActorUri) on the returned ProcessorDefinition to complete the route to the consumer actor (where targetActorUri is the actor component URI as described in <a href="#access-to-actors">Access to actors</a>). If the actor cannot be found, a <code>ActorNotRegisteredException</code> is thrown.</p>
<p>*) Before passing the RouteDefinition instance to the route definition handler, akka-camel may make some further modifications to it.</p>
<a id="camel-examples"></a>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2>
<p>The sample named <span class="group-scala"><a href="https://example.lightbend.com/v1/download/akka-samples-camel-scala">Akka Camel Samples with Scala</a>(<a href="https://developer.lightbend.com/start/?group=akka&project=akka-sample-camel-scala">source code</a>)</span><span class="group-java"><a href="https://example.lightbend.com/v1/download/akka-samples-camel-java">Akka Camel Samples with Java</a>(<a href="https://developer.lightbend.com/start/?group=akka&project=akka-sample-camel-java">source code</a>)</span> contains 3 samples:</p>
<ul>
  <li>Asynchronous routing and transformation - This example demonstrates how to implement consumer and producer actors that support <a href="#camel-asynchronous-routing">Asynchronous routing</a> with their Camel endpoints.</li>
  <li>Custom Camel route - Demonstrates the combined usage of a <code>Producer</code> and a <code>Consumer</code> actor as well as the inclusion of a custom Camel route.</li>
  <li>Quartz Scheduler Example - Showing how simple is to implement a cron-style scheduler by using the Camel Quartz component</li>
</ul>
<h2><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h2>
<p>There are several configuration properties for the Camel module, please refer to the <a href="general/configuration.html#config-akka-camel">reference configuration</a>.</p>
<h2><a href="#additional-resources" name="additional-resources" class="anchor"><span class="anchor-link"></span></a>Additional Resources</h2>
<p>For an introduction to akka-camel 2, see also the Peter Gabryanczyk&rsquo;s talk <a href="http://skillsmatter.com/podcast/scala/akka-2-x">Migrating akka-camel module to Akka 2.x</a>.</p>
<p>For an introduction to akka-camel 1, see also the <a href="http://www.manning.com/ibsen/appEsample.pdf">Appendix E - Akka and Camel</a> (pdf) of the book <a href="http://www.manning.com/ibsen/">Camel in Action</a>.</p>
<p>Other, more advanced external articles (for version 1) are:</p>
<ul>
  <li><a href="http://krasserm.blogspot.com/2011/02/akka-consumer-actors-new-features-and.html">Akka Consumer Actors: New Features and Best Practices</a></li>
  <li><a href="http://krasserm.blogspot.com/2011/02/akka-producer-actor-new-features-and.html">Akka Producer Actors: New Features and Best Practices</a></li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="io-dns.html"><i class="icon-prev"></i> <span class="link-prev">DNS Extension</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="discovery/index.html">Discovery <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/camel.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
