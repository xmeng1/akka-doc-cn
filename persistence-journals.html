<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Persistence - Building a storage backend &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/persistence-journals.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html#persistence-building-a-storage-backend" class="active page">Persistence - Building a storage backend</a>
    <ul>
      <li><a href="persistence-journals.html#journal-plugin-api" class="header">Journal plugin API</a></li>
      <li><a href="persistence-journals.html#snapshot-store-plugin-api" class="header">Snapshot store plugin API</a></li>
      <li><a href="persistence-journals.html#plugin-tck" class="header">Plugin TCK</a></li>
      <li><a href="persistence-journals.html#corrupt-event-logs" class="header">Corrupt event logs</a></li>
    </ul></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html" class="page">FSM</a></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html#persistence-building-a-storage-backend" class="active page">Persistence - Building a storage backend</a>
    <ul>
      <li><a href="persistence-journals.html#journal-plugin-api" class="header">Journal plugin API</a></li>
      <li><a href="persistence-journals.html#snapshot-store-plugin-api" class="header">Snapshot store plugin API</a></li>
      <li><a href="persistence-journals.html#plugin-tck" class="header">Plugin TCK</a></li>
      <li><a href="persistence-journals.html#corrupt-event-logs" class="header">Corrupt event logs</a></li>
    </ul></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#persistence-building-a-storage-backend" name="persistence-building-a-storage-backend" class="anchor"><span class="anchor-link"></span></a>Persistence - Building a storage backend</h1>
<p>Storage backends for journals and snapshot stores are pluggable in the Akka persistence extension. A directory of persistence journal and snapshot store plugins is available at the Akka Community Projects page, see <a href="http://akka.io/community/">Community plugins</a> This documentation described how to build a new storage backend.</p>
<a id="journal-plugin-api"></a>
<h3><a href="#journal-plugin-api" name="journal-plugin-api" class="anchor"><span class="anchor-link"></span></a>Journal plugin API</h3>
<p>A journal plugin extends <code>AsyncWriteJournal</code>.</p>
<p><code>AsyncWriteJournal</code> is an actor and the methods to be implemented are:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/scala/akka/persistence/journal/AsyncWriteJournal.scala#L172-L257" target="_blank" title="Go to snippet source"></a><code class="language-scala">/**
 * Plugin API: asynchronously writes a batch (`Seq`) of persistent messages to the
 * journal.
 *
 * The batch is only for performance reasons, i.e. all messages don&#39;t have to be written
 * atomically. Higher throughput can typically be achieved by using batch inserts of many
 * records compared to inserting records one-by-one, but this aspect depends on the
 * underlying data store and a journal implementation can implement it as efficient as
 * possible. Journals should aim to persist events in-order for a given `persistenceId`
 * as otherwise in case of a failure, the persistent state may be end up being inconsistent.
 *
 * Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to
 * the event that was passed to the `persist` method of the `PersistentActor`, or it
 * contains several `PersistentRepr` that corresponds to the events that were passed
 * to the `persistAll` method of the `PersistentActor`. All `PersistentRepr` of the
 * `AtomicWrite` must be written to the data store atomically, i.e. all or none must
 * be stored. If the journal (data store) cannot support atomic writes of multiple
 * events it should reject such writes with a `Try` `Failure` with an
 * `UnsupportedOperationException` describing the issue. This limitation should
 * also be documented by the journal plugin.
 *
 * If there are failures when storing any of the messages in the batch the returned
 * `Future` must be completed with failure. The `Future` must only be completed with
 * success when all messages in the batch have been confirmed to be stored successfully,
 * i.e. they will be readable, and visible, in a subsequent replay. If there is
 * uncertainty about if the messages were stored or not the `Future` must be completed
 * with failure.
 *
 * Data store connection problems must be signaled by completing the `Future` with
 * failure.
 *
 * The journal can also signal that it rejects individual messages (`AtomicWrite`) by
 * the returned `immutable.Seq[Try[Unit]]`. It is possible but not mandatory to reduce
 * number of allocations by returning `Future.successful(Nil)` for the happy path,
 * i.e. when no messages are rejected. Otherwise the returned `Seq` must have as many elements
 * as the input `messages` `Seq`. Each `Try` element signals if the corresponding
 * `AtomicWrite` is rejected or not, with an exception describing the problem. Rejecting
 * a message means it was not stored, i.e. it must not be included in a later replay.
 * Rejecting a message is typically done before attempting to store it, e.g. because of
 * serialization error.
 *
 * Data store connection problems must not be signaled as rejections.
 *
 * It is possible but not mandatory to reduce number of allocations by returning
 * `Future.successful(Nil)` for the happy path, i.e. when no messages are rejected.
 *
 * Calls to this method are serialized by the enclosing journal actor. If you spawn
 * work in asynchronous tasks it is alright that they complete the futures in any order,
 * but the actual writes for a specific persistenceId should be serialized to avoid
 * issues such as events of a later write are visible to consumers (query side, or replay)
 * before the events of an earlier write are visible.
 * A PersistentActor will not send a new WriteMessages request before the previous one
 * has been completed.
 *
 * Please note that the `sender` field of the contained PersistentRepr objects has been
 * nulled out (i.e. set to `ActorRef.noSender`) in order to not use space in the journal
 * for a sender reference that will likely be obsolete during replay.
 *
 * Please also note that requests for the highest sequence number may be made concurrently
 * to this call executing for the same `persistenceId`, in particular it is possible that
 * a restarting actor tries to recover before its outstanding writes have completed. In
 * the latter case it is highly desirable to defer reading the highest sequence number
 * until all outstanding writes have completed, otherwise the PersistentActor may reuse
 * sequence numbers.
 *
 * This call is protected with a circuit-breaker.
 */
def asyncWriteMessages(messages: immutable.Seq[AtomicWrite]): Future[immutable.Seq[Try[Unit]]]

/**
 * Plugin API: asynchronously deletes all persistent messages up to `toSequenceNr`
 * (inclusive).
 *
 * This call is protected with a circuit-breaker.
 * Message deletion doesn&#39;t affect the highest sequence number of messages, journal must maintain the highest sequence number and never decrease it.
 */
def asyncDeleteMessagesTo(persistenceId: String, toSequenceNr: Long): Future[Unit]

/**
 * Plugin API
 *
 * Allows plugin implementers to use `f pipeTo self` and
 * handle additional messages for implementing advanced features
 *
 */
def receivePluginInternal: Actor.Receive = Actor.emptyBehavior</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/java/akka/persistence/journal/japi/AsyncWritePlugin.java#L15-L76" target="_blank" title="Go to snippet source"></a><code class="language-java">/**
 * Java API, Plugin API: asynchronously writes a batch (`Iterable`) of persistent messages to the
 * journal.
 *
 * &lt;p&gt;The batch is only for performance reasons, i.e. all messages don&#39;t have to be written
 * atomically. Higher throughput can typically be achieved by using batch inserts of many records
 * compared to inserting records one-by-one, but this aspect depends on the underlying data store
 * and a journal implementation can implement it as efficient as possible. Journals should aim to
 * persist events in-order for a given `persistenceId` as otherwise in case of a failure, the
 * persistent state may be end up being inconsistent.
 *
 * &lt;p&gt;Each `AtomicWrite` message contains the single `PersistentRepr` that corresponds to the
 * event that was passed to the `persist` method of the `PersistentActor`, or it contains several
 * `PersistentRepr` that corresponds to the events that were passed to the `persistAll` method of
 * the `PersistentActor`. All `PersistentRepr` of the `AtomicWrite` must be written to the data
 * store atomically, i.e. all or none must be stored. If the journal (data store) cannot support
 * atomic writes of multiple events it should reject such writes with an `Optional` with an
 * `UnsupportedOperationException` describing the issue. This limitation should also be documented
 * by the journal plugin.
 *
 * &lt;p&gt;If there are failures when storing any of the messages in the batch the returned `Future`
 * must be completed with failure. The `Future` must only be completed with success when all
 * messages in the batch have been confirmed to be stored successfully, i.e. they will be
 * readable, and visible, in a subsequent replay. If there is uncertainty about if the messages
 * were stored or not the `Future` must be completed with failure.
 *
 * &lt;p&gt;Data store connection problems must be signaled by completing the `Future` with failure.
 *
 * &lt;p&gt;The journal can also signal that it rejects individual messages (`AtomicWrite`) by the
 * returned `Iterable&amp;lt;Optional&amp;lt;Exception&amp;gt;&amp;gt;`. The returned `Iterable` must have as many
 * elements as the input `messages` `Iterable`. Each `Optional` element signals if the
 * corresponding `AtomicWrite` is rejected or not, with an exception describing the problem.
 * Rejecting a message means it was not stored, i.e. it must not be included in a later replay.
 * Rejecting a message is typically done before attempting to store it, e.g. because of
 * serialization error.
 *
 * &lt;p&gt;Data store connection problems must not be signaled as rejections.
 *
 * &lt;p&gt;Note that it is possible to reduce number of allocations by caching some result `Iterable`
 * for the happy path, i.e. when no messages are rejected.
 *
 * &lt;p&gt;Calls to this method are serialized by the enclosing journal actor. If you spawn work in
 * asynchronous tasks it is alright that they complete the futures in any order, but the actual
 * writes for a specific persistenceId should be serialized to avoid issues such as events of a
 * later write are visible to consumers (query side, or replay) before the events of an earlier
 * write are visible. This can also be done with consistent hashing if it is too fine grained to
 * do it on the persistenceId level. Normally a `PersistentActor` will only have one outstanding
 * write request to the journal but it may emit several write requests when `persistAsync` is used
 * and the max batch size is reached.
 *
 * &lt;p&gt;This call is protected with a circuit-breaker.
 */
Future&lt;Iterable&lt;Optional&lt;Exception&gt;&gt;&gt; doAsyncWriteMessages(Iterable&lt;AtomicWrite&gt; messages);

/**
 * Java API, Plugin API: synchronously deletes all persistent messages up to `toSequenceNr`.
 *
 * &lt;p&gt;This call is protected with a circuit-breaker.
 *
 * @see AsyncRecoveryPlugin
 */
Future&lt;Void&gt; doAsyncDeleteMessagesTo(String persistenceId, long toSequenceNr);</code></pre></dd>
</dl>
<p>If the storage backend API only supports synchronous, blocking writes, the methods should be implemented as:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L154-L158" target="_blank" title="Go to snippet source"></a><code class="language-scala">def asyncWriteMessages(messages: immutable.Seq[AtomicWrite]): Future[immutable.Seq[Try[Unit]]] =
  Future.fromTry(Try {
    // blocking call here
    ???
  })</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L95-L106" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public Future&lt;Iterable&lt;Optional&lt;Exception&gt;&gt;&gt; doAsyncWriteMessages(
    Iterable&lt;AtomicWrite&gt; messages) {
  try {
    Iterable&lt;Optional&lt;Exception&gt;&gt; result = new ArrayList&lt;Optional&lt;Exception&gt;&gt;();
    // blocking call here...
    // result.add(..)
    return Futures.successful(result);
  } catch (Exception e) {
    return Futures.failed(e);
  }
}</code></pre></dd>
</dl>
<p>A journal plugin must also implement the methods defined in <code>AsyncRecovery</code> for replays and sequence number recovery:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/scala/akka/persistence/journal/AsyncRecovery.scala#L16-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">/**
 * Plugin API: asynchronously replays persistent messages. Implementations replay
 * a message by calling `replayCallback`. The returned future must be completed
 * when all messages (matching the sequence number bounds) have been replayed.
 * The future must be completed with a failure if any of the persistent messages
 * could not be replayed.
 *
 * The `replayCallback` must also be called with messages that have been marked
 * as deleted. In this case a replayed message&#39;s `deleted` method must return
 * `true`.
 *
 * The `toSequenceNr` is the lowest of what was returned by [[#asyncReadHighestSequenceNr]]
 * and what the user specified as recovery [[akka.persistence.Recovery]] parameter.
 * This does imply that this call is always preceded by reading the highest sequence
 * number for the given `persistenceId`.
 *
 * This call is NOT protected with a circuit-breaker because it may take long time
 * to replay all events. The plugin implementation itself must protect against
 * an unresponsive backend store and make sure that the returned Future is
 * completed with success or failure within reasonable time. It is not allowed
 * to ignore completing the future.
 *
 * @param persistenceId persistent actor id.
 * @param fromSequenceNr sequence number where replay should start (inclusive).
 * @param toSequenceNr sequence number where replay should end (inclusive).
 * @param max maximum number of messages to be replayed.
 * @param recoveryCallback called to replay a single message. Can be called from any
 *                       thread.
 *
 * @see [[AsyncWriteJournal]]
 */
def asyncReplayMessages(persistenceId: String, fromSequenceNr: Long, toSequenceNr: Long,
                        max: Long)(recoveryCallback: PersistentRepr ⇒ Unit): Future[Unit]

/**
 * Plugin API: asynchronously reads the highest stored sequence number for the
 * given `persistenceId`. The persistent actor will use the highest sequence
 * number after recovery as the starting point when persisting new events.
 * This sequence number is also used as `toSequenceNr` in subsequent call
 * to [[#asyncReplayMessages]] unless the user has specified a lower `toSequenceNr`.
 * Journal must maintain the highest sequence number and never decrease it.
 *
 * This call is protected with a circuit-breaker.
 *
 * Please also note that requests for the highest sequence number may be made concurrently
 * to writes executing for the same `persistenceId`, in particular it is possible that
 * a restarting actor tries to recover before its outstanding writes have completed.
 *
 * @param persistenceId persistent actor id.
 * @param fromSequenceNr hint where to start searching for the highest sequence
 *                       number. When a persistent actor is recovering this
 *                       `fromSequenceNr` will be the sequence number of the used
 *                       snapshot or `0L` if no snapshot is used.
 */
def asyncReadHighestSequenceNr(persistenceId: String, fromSequenceNr: Long): Future[Long]</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/java/akka/persistence/journal/japi/AsyncRecoveryPlugin.java#L15-L51" target="_blank" title="Go to snippet source"></a><code class="language-java">/**
 * Java API, Plugin API: asynchronously replays persistent messages. Implementations replay a
 * message by calling `replayCallback`. The returned future must be completed when all messages
 * (matching the sequence number bounds) have been replayed. The future must be completed with a
 * failure if any of the persistent messages could not be replayed.
 *
 * &lt;p&gt;The `replayCallback` must also be called with messages that have been marked as deleted. In
 * this case a replayed message&#39;s `deleted` method must return `true`.
 *
 * &lt;p&gt;The `toSequenceNr` is the lowest of what was returned by {@link
 * #doAsyncReadHighestSequenceNr} and what the user specified as recovery {@link
 * akka.persistence.Recovery} parameter.
 *
 * @param persistenceId id of the persistent actor.
 * @param fromSequenceNr sequence number where replay should start (inclusive).
 * @param toSequenceNr sequence number where replay should end (inclusive).
 * @param max maximum number of messages to be replayed.
 * @param replayCallback called to replay a single message. Can be called from any thread.
 */
Future&lt;Void&gt; doAsyncReplayMessages(
    String persistenceId,
    long fromSequenceNr,
    long toSequenceNr,
    long max,
    Consumer&lt;PersistentRepr&gt; replayCallback);

/**
 * Java API, Plugin API: asynchronously reads the highest stored sequence number for the given
 * `persistenceId`. The persistent actor will use the highest sequence number after recovery as
 * the starting point when persisting new events. This sequence number is also used as
 * `toSequenceNr` in subsequent call to [[#asyncReplayMessages]] unless the user has specified a
 * lower `toSequenceNr`.
 *
 * @param persistenceId id of the persistent actor.
 * @param fromSequenceNr hint where to start searching for the highest sequence number.
 */
Future&lt;Long&gt; doAsyncReadHighestSequenceNr(String persistenceId, long fromSequenceNr);</code></pre></dd>
</dl>
<p>A journal plugin can be activated with the following minimal configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L70-L79" target="_blank" title="Go to snippet source"></a><code class="language-scala"># Path to the journal plugin to be used
akka.persistence.journal.plugin = &quot;my-journal&quot;

# My custom journal plugin
my-journal {
  # Class name of the plugin.
  class = &quot;docs.persistence.MyJournal&quot;
  # Dispatcher for the plugin actor.
  plugin-dispatcher = &quot;akka.actor.default-dispatcher&quot;
}</code></pre>
<p>The journal plugin instance is an actor so the methods corresponding to requests from persistent actors are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other actors to achieve parallelism.</p>
<p>The journal plugin class must have a constructor with one of these signatures:</p>
<ul>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter and a <code>String</code> parameter for the config path</li>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter</li>
  <li>constructor without parameters</li>
</ul>
<p>The plugin section of the actor system&rsquo;s config will be passed in the config constructor parameter. The config path of the plugin is passed in the <code>String</code> parameter.</p>
<p>The <code>plugin-dispatcher</code> is the dispatcher used for the plugin actor. If not specified, it defaults to <code>akka.persistence.dispatchers.default-plugin-dispatcher</code>.</p>
<p>Don&rsquo;t run journal tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
<h3><a href="#snapshot-store-plugin-api" name="snapshot-store-plugin-api" class="anchor"><span class="anchor-link"></span></a>Snapshot store plugin API</h3>
<p>A snapshot store plugin must extend the <code>SnapshotStore</code> actor and implement the following methods:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/scala/akka/persistence/snapshot/SnapshotStore.scala#L98-L149" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>/**
 * Plugin API: asynchronously loads a snapshot.
 *
 * If the future `Option` is `None` then all events will be replayed,
 * i.e. there was no snapshot. If snapshot could not be loaded the `Future`
 * should be completed with failure. That is important because events may
 * have been deleted and just replaying the events might not result in a valid
 * state.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for loading.
 */
def loadAsync(persistenceId: String, criteria: SnapshotSelectionCriteria): Future[Option[SelectedSnapshot]]

/**
 * Plugin API: asynchronously saves a snapshot.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param metadata snapshot metadata.
 * @param snapshot snapshot.
 */
def saveAsync(metadata: SnapshotMetadata, snapshot: Any): Future[Unit]

/**
 * Plugin API: deletes the snapshot identified by `metadata`.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param metadata snapshot metadata.
 */
def deleteAsync(metadata: SnapshotMetadata): Future[Unit]

/**
 * Plugin API: deletes all snapshots matching `criteria`.
 *
 * This call is protected with a circuit-breaker.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for deleting.
 */
def deleteAsync(persistenceId: String, criteria: SnapshotSelectionCriteria): Future[Unit]

/**
 * Plugin API
 * Allows plugin implementers to use `f pipeTo self` and
 * handle additional messages for implementing advanced features
 */
def receivePluginInternal: Actor.Receive = Actor.emptyBehavior</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-persistence/src/main/java/akka/persistence/snapshot/japi/SnapshotStorePlugin.java#L16-L46" target="_blank" title="Go to snippet source"></a><code class="language-java">/**
 * Java API, Plugin API: asynchronously loads a snapshot.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for loading.
 */
Future&lt;Optional&lt;SelectedSnapshot&gt;&gt; doLoadAsync(
    String persistenceId, SnapshotSelectionCriteria criteria);

/**
 * Java API, Plugin API: asynchronously saves a snapshot.
 *
 * @param metadata snapshot metadata.
 * @param snapshot snapshot.
 */
Future&lt;Void&gt; doSaveAsync(SnapshotMetadata metadata, Object snapshot);

/**
 * Java API, Plugin API: deletes the snapshot identified by `metadata`.
 *
 * @param metadata snapshot metadata.
 */
Future&lt;Void&gt; doDeleteAsync(SnapshotMetadata metadata);

/**
 * Java API, Plugin API: deletes all snapshots matching `criteria`.
 *
 * @param persistenceId id of the persistent actor.
 * @param criteria selection criteria for deleting.
 */
Future&lt;Void&gt; doDeleteAsync(String persistenceId, SnapshotSelectionCriteria criteria);</code></pre></dd>
</dl>
<p>A snapshot store plugin can be activated with the following minimal configuration:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L83-L92" target="_blank" title="Go to snippet source"></a><code class="language-scala"># Path to the snapshot store plugin to be used
akka.persistence.snapshot-store.plugin = &quot;my-snapshot-store&quot;

# My custom snapshot store plugin
my-snapshot-store {
  # Class name of the plugin.
  class = &quot;docs.persistence.MySnapshotStore&quot;
  # Dispatcher for the plugin actor.
  plugin-dispatcher = &quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;
}</code></pre>
<p>The snapshot store instance is an actor so the methods corresponding to requests from persistent actors are executed sequentially. It may delegate to asynchronous libraries, spawn futures, or delegate to other actors to achive parallelism.</p>
<p>The snapshot store plugin class must have a constructor with one of these signatures:</p>
<ul>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter and a <code>String</code> parameter for the config path</li>
  <li>constructor with one <code>com.typesafe.config.Config</code> parameter</li>
  <li>constructor without parameters</li>
</ul>
<p>The plugin section of the actor system&rsquo;s config will be passed in the config constructor parameter. The config path of the plugin is passed in the <code>String</code> parameter.</p>
<p>The <code>plugin-dispatcher</code> is the dispatcher used for the plugin actor. If not specified, it defaults to <code>akka.persistence.dispatchers.default-plugin-dispatcher</code>.</p>
<p>Don&rsquo;t run snapshot store tasks/futures on the system default dispatcher, since that might starve other tasks.</p>
<h3><a href="#plugin-tck" name="plugin-tck" class="anchor"><span class="anchor-link"></span></a>Plugin TCK</h3>
<p>In order to help developers build correct and high quality storage plugins, we provide a Technology Compatibility Kit (<a href="http://en.wikipedia.org/wiki/Technology_Compatibility_Kit">TCK</a> for short).</p>
<p>The TCK is usable from Java as well as Scala projects. To test your implementation (independently of language) you need to include the akka-persistence-tck dependency:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-persistence-tck" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-persistence-tck_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-persistence-tck_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<p>To include the Journal TCK tests in your test suite simply extend the provided <span class="group-scala"><code>JournalSpec</code></span><span class="group-java"><code>JavaJournalSpec</code></span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L190-L199" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyJournalSpec extends JournalSpec(
  config = ConfigFactory.parseString(
    &quot;&quot;&quot;akka.persistence.journal.plugin = &quot;my.journal.plugin&quot;&quot;&quot;&quot;)) {

  override def supportsRejectingNonSerializableObjects: CapabilityFlag =
    false // or CapabilityFlag.off

  override def supportsSerialization: CapabilityFlag =
    true // or CapabilityFlag.on
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L133-L146" target="_blank" title="Go to snippet source"></a><code class="language-java">class MyJournalSpecTest extends JavaJournalSpec {

  public MyJournalSpecTest() {
    super(
        ConfigFactory.parseString(
            &quot;persistence.journal.plugin = &quot;
                + &quot;\&quot;akka.persistence.journal.leveldb-shared\&quot;&quot;));
  }

  @Override
  public CapabilityFlag supportsRejectingNonSerializableObjects() {
    return CapabilityFlag.off();
  }
}</code></pre></dd>
</dl>
<p>Please note that some of the tests are optional, and by overriding the <code>supports...</code> methods you give the TCK the needed information about which tests to run. You can implement these methods using <span class="group-scala">boolean values or</span> the provided <code>CapabilityFlag.on</code> / <code>CapabilityFlag.off</code> values.</p>
<p>We also provide a simple benchmarking class <span class="group-scala"><code>JournalPerfSpec</code></span><span class="group-java"><code>JavaJournalPerfSpec</code></span> which includes all the tests that <span class="group-scala"><code>JournalSpec</code></span><span class="group-java"><code>JavaJournalSpec</code></span> has, and also performs some longer operations on the Journal while printing its performance stats. While it is NOT aimed to provide a proper benchmarking environment it can be used to get a rough feel about your journal&rsquo;s performance in the most typical scenarios.</p>
<p>In order to include the <code>SnapshotStore</code> TCK tests in your test suite extend the <code>SnapshotStoreSpec</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L206-L214" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MySnapshotStoreSpec extends SnapshotStoreSpec(
  config = ConfigFactory.parseString(
    &quot;&quot;&quot;
    akka.persistence.snapshot-store.plugin = &quot;my.snapshot-store.plugin&quot;
    &quot;&quot;&quot;)) {

  override def supportsSerialization: CapabilityFlag =
    true // or CapabilityFlag.on
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L153-L161" target="_blank" title="Go to snippet source"></a><code class="language-java">class MySnapshotStoreTest extends JavaSnapshotStoreSpec {

  public MySnapshotStoreTest() {
    super(
        ConfigFactory.parseString(
            &quot;akka.persistence.snapshot-store.plugin = &quot;
                + &quot;\&quot;akka.persistence.snapshot-store.local\&quot;&quot;));
  }
}</code></pre></dd>
</dl>
<p>In case your plugin requires some setting up (starting a mock database, removing temporary files etc.) you can override the <code>beforeAll</code> and <code>afterAll</code> methods to hook into the tests lifecycle:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/persistence/PersistencePluginDocSpec.scala#L224-L247" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyJournalSpec extends JournalSpec(
  config = ConfigFactory.parseString(
    &quot;&quot;&quot;
    akka.persistence.journal.plugin = &quot;my.journal.plugin&quot;
    &quot;&quot;&quot;)) {

  override def supportsRejectingNonSerializableObjects: CapabilityFlag =
    true // or CapabilityFlag.on

  val storageLocations = List(
    new File(system.settings.config.getString(&quot;akka.persistence.journal.leveldb.dir&quot;)),
    new File(config.getString(&quot;akka.persistence.snapshot-store.local.dir&quot;)))

  override def beforeAll(): Unit = {
    super.beforeAll()
    storageLocations foreach FileUtils.deleteRecursively
  }

  override def afterAll(): Unit = {
    storageLocations foreach FileUtils.deleteRecursively
    super.afterAll()
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/persistence/LambdaPersistencePluginDocTest.java#L168-L205" target="_blank" title="Go to snippet source"></a><code class="language-java">class MyJournalSpecTest extends JavaJournalSpec {

  List&lt;File&gt; storageLocations = new ArrayList&lt;File&gt;();

  public MyJournalSpecTest() {
    super(
        ConfigFactory.parseString(
            &quot;persistence.journal.plugin = &quot;
                + &quot;\&quot;akka.persistence.journal.leveldb-shared\&quot;&quot;));

    Config config = system().settings().config();
    storageLocations.add(
        new File(config.getString(&quot;akka.persistence.journal.leveldb.dir&quot;)));
    storageLocations.add(
        new File(config.getString(&quot;akka.persistence.snapshot-store.local.dir&quot;)));
  }

  @Override
  public CapabilityFlag supportsRejectingNonSerializableObjects() {
    return CapabilityFlag.on();
  }

  @Override
  public void beforeAll() {
    for (File storageLocation : storageLocations) {
      FileUtils.deleteRecursively(storageLocation);
    }
    super.beforeAll();
  }

  @Override
  public void afterAll() {
    super.afterAll();
    for (File storageLocation : storageLocations) {
      FileUtils.deleteRecursively(storageLocation);
    }
  }
}</code></pre></dd>
</dl>
<p>We <em>highly recommend</em> including these specifications in your test suite, as they cover a broad range of cases you might have otherwise forgotten to test for when writing a plugin from scratch.</p>
<h3><a href="#corrupt-event-logs" name="corrupt-event-logs" class="anchor"><span class="anchor-link"></span></a>Corrupt event logs</h3>
<p>If a journal can&rsquo;t prevent users from running persistent actors with the same <code>persistenceId</code> concurrently it is likely that an event log will be corrupted by having events with the same sequence number.</p>
<p>It is recommended that journals should still delivery these events during recovery so that a <code>replay-filter</code> can be used to decide what to do about it in a journal agnostic way.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="persistence-fsm.html"><i class="icon-prev"></i> <span class="link-prev">Persistent FSM</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="testing.html">Testing Actor Systems <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/persistence-journals.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
