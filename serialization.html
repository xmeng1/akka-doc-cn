<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Serialization &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/serialization.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a>
  <ul>
    <li><a href="remoting.html" class="page">Remoting</a></li>
    <li><a href="remoting-artery.html" class="page">Remoting (codename Artery)</a></li>
    <li><a href="serialization.html#serialization" class="active page">Serialization</a>
    <ul>
      <li><a href="serialization.html#dependency" class="header">Dependency</a></li>
      <li><a href="serialization.html#introduction" class="header">Introduction</a></li>
      <li><a href="serialization.html#usage" class="header">Usage</a></li>
      <li><a href="serialization.html#customization" class="header">Customization</a></li>
      <li><a href="serialization.html#disabling-the-java-serializer" class="header">Disabling the Java Serializer</a></li>
      <li><a href="serialization.html#serialization-compatibility" class="header">Serialization compatibility</a></li>
      <li><a href="serialization.html#rolling-upgrades" class="header">Rolling upgrades</a></li>
      <li><a href="serialization.html#external-akka-serializers" class="header">External Akka Serializers</a></li>
    </ul></li>
    <li><a href="io.html" class="page">I/O</a></li>
    <li><a href="io-tcp.html" class="page">Using TCP</a></li>
    <li><a href="io-udp.html" class="page">Using UDP</a></li>
    <li><a href="io-dns.html" class="page">DNS Extension</a></li>
    <li><a href="camel.html" class="page">Camel</a></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a>
  <ul>
    <li><a href="remoting.html" class="page">Remoting</a></li>
    <li><a href="remoting-artery.html" class="page">Remoting (codename Artery)</a></li>
    <li><a href="serialization.html#serialization" class="active page">Serialization</a>
    <ul>
      <li><a href="serialization.html#dependency" class="header">Dependency</a></li>
      <li><a href="serialization.html#introduction" class="header">Introduction</a></li>
      <li><a href="serialization.html#usage" class="header">Usage</a></li>
      <li><a href="serialization.html#customization" class="header">Customization</a></li>
      <li><a href="serialization.html#disabling-the-java-serializer" class="header">Disabling the Java Serializer</a></li>
      <li><a href="serialization.html#serialization-compatibility" class="header">Serialization compatibility</a></li>
      <li><a href="serialization.html#rolling-upgrades" class="header">Rolling upgrades</a></li>
      <li><a href="serialization.html#external-akka-serializers" class="header">External Akka Serializers</a></li>
    </ul></li>
    <li><a href="io.html" class="page">I/O</a></li>
    <li><a href="io-tcp.html" class="page">Using TCP</a></li>
    <li><a href="io-udp.html" class="page">Using UDP</a></li>
    <li><a href="io-dns.html" class="page">DNS Extension</a></li>
    <li><a href="camel.html" class="page">Camel</a></li>
  </ul></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#serialization" name="serialization" class="anchor"><span class="anchor-link"></span></a>Serialization</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Serialization, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>The messages that Akka actors send to each other are JVM objects (e.g. instances of Scala case classes). Message passing between actors that live on the same JVM is straightforward. It is done via reference passing. However, messages that have to escape the JVM to reach an actor running on a different host have to undergo some form of serialization (i.e. the objects have to be converted to and from byte arrays).</p>
<p>Akka itself uses Protocol Buffers to serialize internal messages (i.e. cluster gossip messages). However, the serialization mechanism in Akka allows you to write custom serializers and to define which serializer to use for what.</p>
<h2><a href="#usage" name="usage" class="anchor"><span class="anchor-link"></span></a>Usage</h2>
<h3><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h3>
<p>For Akka to know which <code>Serializer</code> to use for what, you need edit your <a href="">Configuration</a>, in the &ldquo;akka.actor.serializers&rdquo;-section you bind names to implementations of the <code>akka.serialization.Serializer</code> you wish to use, like this:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L138-L146" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka {
  actor {
    serializers {
      java = &quot;akka.serialization.JavaSerializer&quot;
      proto = &quot;akka.remote.serialization.ProtobufSerializer&quot;
      myown = &quot;docs.serialization.MyOwnSerializer&quot;
    }
  }
}</code></pre>
<p>After you&rsquo;ve bound names to different implementations of <code>Serializer</code> you need to wire which classes should be serialized using which <code>Serializer</code>, this is done in the &ldquo;akka.actor.serialization-bindings&rdquo;-section:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L156-L172" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka {
  actor {
    serializers {
      java = &quot;akka.serialization.JavaSerializer&quot;
      proto = &quot;akka.remote.serialization.ProtobufSerializer&quot;
      myown = &quot;docs.serialization.MyOwnSerializer&quot;
    }

    serialization-bindings {
      &quot;java.lang.String&quot; = java
      &quot;docs.serialization.Customer&quot; = java
      &quot;com.google.protobuf.Message&quot; = proto
      &quot;docs.serialization.MyOwnSerializable&quot; = myown
      &quot;java.lang.Boolean&quot; = myown
    }
  }
}</code></pre>
<p>You only need to specify the name of an interface or abstract base class of the messages. In case of ambiguity, i.e. the message implements several of the configured classes, the most specific configured class will be used, i.e. the one of which all other candidates are superclasses. If this condition cannot be met, because e.g. <code>java.io.Serializable</code> and <code>MyOwnSerializable</code> both apply and neither is a subtype of the other, a warning will be issued.</p><div class="callout note "><div class="callout-title">Note</div>
<p>If <span class="group-java">you are using Scala for your message protocol and</span> your messages are contained inside of a Scala object, then in order to reference those messages, you will need to use the fully qualified Java class name. For a message named <code>Message</code> contained inside the <span class="group-java">Scala</span> object named <code>Wrapper</code> you would need to reference it as <code>Wrapper$Message</code> instead of <code>Wrapper.Message</code>.</p></div>
<p>Akka provides serializers for <code>java.io.Serializable</code> and <a href="http://code.google.com/p/protobuf/">protobuf</a> <code>com.google.protobuf.GeneratedMessage</code> by default (the latter only if depending on the akka-remote module), so normally you don&rsquo;t need to add configuration for that; since <code>com.google.protobuf.GeneratedMessage</code> implements <code>java.io.Serializable</code>, protobuf messages will always be serialized using the protobuf protocol unless specifically overridden. In order to disable a default serializer, see <a href="remoting.html#disable-java-serializer">Disabling the Java Serializer</a></p>
<h3><a href="#enable-additional-bindings" name="enable-additional-bindings" class="anchor"><span class="anchor-link"></span></a>Enable additional bindings</h3>
<p>A few types in Akka are, for backwards-compatibility reasons, still serialized by using Java serializer by default. You can switch them to using protocol buffers instead by adding the following bindings or set <code>akka.actor.allow-java-serialization=off</code>, which will make them serialized using protocol buffers instead. Refer to <a href="serialization.html#rolling-upgrades">Rolling Upgrades</a> to understand how it is possible to turn and start using these new serializers in your clustered applications.</p>
<p>You can enable them one by one adding by adding their bindings to the misc serializer, like this:</p>
<pre><code>akka.actor.serialization-bindings {
    &quot;akka.Done&quot;                 = akka-misc
    &quot;akka.NotUsed&quot;              = akka-misc
    &quot;akka.actor.Address&quot;        = akka-misc
    &quot;akka.remote.UniqueAddress&quot; = akka-misc
}
</code></pre>
<p>Alternatively, you can disable all Java serialization which then automatically will add the <code>java-serialization-disabled-additional-serialization-bindings</code> bindings to the active bindings.</p>
<h3><a href="#verification" name="verification" class="anchor"><span class="anchor-link"></span></a>Verification</h3>
<p>Normally, messages sent between local actors (i.e. same JVM) do not undergo serialization. For testing, sometimes, it may be desirable to force serialization on all messages (both remote and local). If you want to do this in order to verify that your messages are serializable you can enable the following config option:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L108-L112" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka {
  actor {
    serialize-messages = on
  }
}</code></pre>
<p>If you want to verify that your <code>Props</code> are serializable you can enable the following config option:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L123-L127" target="_blank" title="Go to snippet source"></a><code class="language-scala">akka {
  actor {
    serialize-creators = on
  }
}</code></pre><div class="callout warning "><div class="callout-title">Warning</div>
<p>We recommend having these config options turned on <strong>only</strong> when you&rsquo;re running tests. Turning these options on in production is pointless, as it would negatively impact the performance of local message passing without giving any gain.</p></div>
<h3><a href="#programmatic" name="programmatic" class="anchor"><span class="anchor-link"></span></a>Programmatic</h3>
<p>If you want to programmatically serialize/deserialize using Akka Serialization, here&rsquo;s some examples:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L10-L13" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ ActorRef, ActorSystem }
import akka.serialization._
import com.typesafe.config.ConfigFactory
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L15-L17" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.*;
import akka.serialization.*;
</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L184-L203" target="_blank" title="Go to snippet source"></a><code class="language-scala">val system = ActorSystem(&quot;example&quot;)

// Get the Serialization Extension
val serialization = SerializationExtension(system)

// Have something to serialize
val original = &quot;woohoo&quot;

// Find the Serializer for it
val serializer = serialization.findSerializerFor(original)

// Turn it into bytes
val bytes = serializer.toBinary(original)

// Turn it back into an object
val back = serializer.fromBinary(bytes, manifest = None)

// Voilá!
back should be(original)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L247-L267" target="_blank" title="Go to snippet source"></a><code class="language-java">ActorSystem system = ActorSystem.create(&quot;example&quot;);

// Get the Serialization Extension
Serialization serialization = SerializationExtension.get(system);

// Have something to serialize
String original = &quot;woohoo&quot;;

// Find the Serializer for it
Serializer serializer = serialization.findSerializerFor(original);

// Turn it into bytes
byte[] bytes = serializer.toBinary(original);

// Turn it back into an object,
// the nulls are for the class manifest and for the classloader
String back = (String) serializer.fromBinary(bytes);

// Voilá!
assertEquals(original, back);
</code></pre></dd>
</dl>
<p>For more information, have a look at the <code>ScalaDoc</code> for <code>akka.serialization._</code></p>
<h2><a href="#customization" name="customization" class="anchor"><span class="anchor-link"></span></a>Customization</h2>
<p>The first code snippet on this page contains a configuration file that references a custom serializer <code>docs.serialization.MyOwnSerializer</code>. How would we go about creating such a custom serializer?</p>
<h3><a href="#creating-new-serializers" name="creating-new-serializers" class="anchor"><span class="anchor-link"></span></a>Creating new Serializers</h3>
<p>A custom <code>Serializer</code> has to inherit from <span class="group-scala"><code>akka.serialization.Serializer</code></span><span class="group-java"><code>akka.serialization.JSerializer</code></span> and can be defined like the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L10-L13" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ ActorRef, ActorSystem }
import akka.serialization._
import com.typesafe.config.ConfigFactory
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L15-L17" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.*;
import akka.serialization.*;
</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L21-L54" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyOwnSerializer extends Serializer {

  // If you need logging here, introduce a constructor that takes an ExtendedActorSystem.
  // class MyOwnSerializer(actorSystem: ExtendedActorSystem) extends Serializer
  // Get a logger using:
  // private val logger = Logging(actorSystem, this)

  // This is whether &quot;fromBinary&quot; requires a &quot;clazz&quot; or not
  def includeManifest: Boolean = true

  // Pick a unique identifier for your Serializer,
  // you&#39;ve got a couple of billions to choose from,
  // 0 - 40 is reserved by Akka itself
  def identifier = 1234567

  // &quot;toBinary&quot; serializes the given object to an Array of Bytes
  def toBinary(obj: AnyRef): Array[Byte] = {
    // Put the code that serializes the object here
    //#...
    Array[Byte]()
    //#...
  }

  // &quot;fromBinary&quot; deserializes the given array,
  // using the type hint (if any, see &quot;includeManifest&quot; above)
  def fromBinary(
    bytes: Array[Byte],
    clazz: Option[Class[_]]): AnyRef = {
    // Put your code that deserializes here
    //#...
    null
    //#...
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L23-L62" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyOwnSerializer extends JSerializer {

  // If you need logging here, introduce a constructor that takes an ExtendedActorSystem.
  // public MyOwnSerializer(ExtendedActorSystem actorSystem)
  // Get a logger using:
  // private final LoggingAdapter logger = Logging.getLogger(actorSystem, this);

  // This is whether &quot;fromBinary&quot; requires a &quot;clazz&quot; or not
  @Override
  public boolean includeManifest() {
    return false;
  }

  // Pick a unique identifier for your Serializer,
  // you&#39;ve got a couple of billions to choose from,
  // 0 - 40 is reserved by Akka itself
  @Override
  public int identifier() {
    return 1234567;
  }

  // &quot;toBinary&quot; serializes the given object to an Array of Bytes
  @Override
  public byte[] toBinary(Object obj) {
    // Put the code that serializes the object here
    // #...
    return new byte[0];
    // #...
  }

  // &quot;fromBinary&quot; deserializes the given array,
  // using the type hint (if any, see &quot;includeManifest&quot; above)
  @Override
  public Object fromBinaryJava(byte[] bytes, Class&lt;?&gt; clazz) {
    // Put your code that deserializes here
    // #...
    return null;
    // #...
  }
}</code></pre></dd>
</dl>
<p>The manifest is a type hint so that the same serializer can be used for different classes. The manifest parameter in <span class="group-scala"><code>fromBinary</code></span><span class="group-java"><code>fromBinaryJava</code></span> is the class of the object that was serialized. In <code>fromBinary</code> you can match on the class and deserialize the bytes to different objects.</p>
<p>Then you only need to fill in the blanks, bind it to a name in your <a href="">Configuration</a> and then list which classes that should be serialized using it.</p>
<a id="string-manifest-serializer"></a>
<h3><a href="#serializer-with-string-manifest" name="serializer-with-string-manifest" class="anchor"><span class="anchor-link"></span></a>Serializer with String Manifest</h3>
<p>The <code>Serializer</code> illustrated above supports a class based manifest (type hint). For serialization of data that need to evolve over time the <code>SerializerWithStringManifest</code> is recommended instead of <code>Serializer</code> because the manifest (type hint) is a <code>String</code> instead of a <code>Class</code>. That means that the class can be moved/removed and the serializer can still deserialize old data by matching on the <code>String</code>. This is especially useful for <a href="persistence.html">Persistence</a>.</p>
<p>The manifest string can also encode a version number that can be used in <code>fromBinary</code> to deserialize in different ways to migrate old data to new domain objects.</p>
<p>If the data was originally serialized with <code>Serializer</code> and in a later version of the system you change to <code>SerializerWithStringManifest</code> the manifest string will be the full class name if you used <code>includeManifest=true</code>, otherwise it will be the empty string.</p>
<p>This is how a <code>SerializerWithStringManifest</code> looks like:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L58-L97" target="_blank" title="Go to snippet source"></a><code class="language-scala">class MyOwnSerializer2 extends SerializerWithStringManifest {

  val CustomerManifest = &quot;customer&quot;
  val UserManifest = &quot;user&quot;
  val UTF_8 = StandardCharsets.UTF_8.name()

  // Pick a unique identifier for your Serializer,
  // you&#39;ve got a couple of billions to choose from,
  // 0 - 40 is reserved by Akka itself
  def identifier = 1234567

  // The manifest (type hint) that will be provided in the fromBinary method
  // Use `&quot;&quot;` if manifest is not needed.
  def manifest(obj: AnyRef): String =
    obj match {
      case _: Customer ⇒ CustomerManifest
      case _: User     ⇒ UserManifest
    }

  // &quot;toBinary&quot; serializes the given object to an Array of Bytes
  def toBinary(obj: AnyRef): Array[Byte] = {
    // Put the real code that serializes the object here
    obj match {
      case Customer(name) ⇒ name.getBytes(UTF_8)
      case User(name)     ⇒ name.getBytes(UTF_8)
    }
  }

  // &quot;fromBinary&quot; deserializes the given array,
  // using the type hint
  def fromBinary(bytes: Array[Byte], manifest: String): AnyRef = {
    // Put the real code that deserializes here
    manifest match {
      case CustomerManifest ⇒
        Customer(new String(bytes, UTF_8))
      case UserManifest ⇒
        User(new String(bytes, UTF_8))
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L83-L130" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyOwnSerializer2 extends SerializerWithStringManifest {

  private static final String CUSTOMER_MANIFEST = &quot;customer&quot;;
  private static final String USER_MANIFEST = &quot;user&quot;;
  private static final String UTF_8 = StandardCharsets.UTF_8.name();

  // Pick a unique identifier for your Serializer,
  // you&#39;ve got a couple of billions to choose from,
  // 0 - 40 is reserved by Akka itself
  @Override
  public int identifier() {
    return 1234567;
  }

  @Override
  public String manifest(Object obj) {
    if (obj instanceof Customer) return CUSTOMER_MANIFEST;
    else if (obj instanceof User) return USER_MANIFEST;
    else throw new IllegalArgumentException(&quot;Unknown type: &quot; + obj);
  }

  // &quot;toBinary&quot; serializes the given object to an Array of Bytes
  @Override
  public byte[] toBinary(Object obj) {
    // Put the real code that serializes the object here
    try {
      if (obj instanceof Customer) return ((Customer) obj).name.getBytes(UTF_8);
      else if (obj instanceof User) return ((User) obj).name.getBytes(UTF_8);
      else throw new IllegalArgumentException(&quot;Unknown type: &quot; + obj);
    } catch (UnsupportedEncodingException e) {
      throw new RuntimeException(e.getMessage(), e);
    }
  }

  // &quot;fromBinary&quot; deserializes the given array,
  // using the type hint
  @Override
  public Object fromBinary(byte[] bytes, String manifest) {
    // Put the real code that deserializes here
    try {
      if (manifest.equals(CUSTOMER_MANIFEST)) return new Customer(new String(bytes, UTF_8));
      else if (manifest.equals(USER_MANIFEST)) return new User(new String(bytes, UTF_8));
      else throw new IllegalArgumentException(&quot;Unknown manifest: &quot; + manifest);
    } catch (UnsupportedEncodingException e) {
      throw new RuntimeException(e.getMessage(), e);
    }
  }
}</code></pre></dd>
</dl>
<p>You must also bind it to a name in your <a href="">Configuration</a> and then list which classes that should be serialized using it.</p>
<p>It&rsquo;s recommended to throw <code>java.io.NotSerializableException</code> in <code>fromBinary</code> if the manifest is unknown. This makes it possible to introduce new message types and send them to nodes that don&rsquo;t know about them. This is typically needed when performing rolling upgrades, i.e. running a cluster with mixed versions for while. <code>NotSerializableException</code> is treated as a transient problem in the TCP based remoting layer. The problem will be logged and message is dropped. Other exceptions will tear down the TCP connection because it can be an indication of corrupt bytes from the underlying transport.</p>
<h3><a href="#serializing-actorrefs" name="serializing-actorrefs" class="anchor"><span class="anchor-link"></span></a>Serializing ActorRefs</h3>
<p>All ActorRefs are serializable using JavaSerializer, but in case you are writing your own serializer, you might want to know how to serialize and deserialize them properly. In the general case, the local address to be used depends on the type of remote address which shall be the recipient of the serialized information. Use <code>Serialization.serializedActorPath(actorRef)</code> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L10-L13" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ ActorRef, ActorSystem }
import akka.serialization._
import com.typesafe.config.ConfigFactory
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L15-L17" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.*;
import akka.serialization.*;
</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L213-L222" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Serialize
// (beneath toBinary)
val identifier: String = Serialization.serializedActorPath(theActorRef)

// Then serialize the identifier however you like

// Deserialize
// (beneath fromBinary)
val deserializedActorRef = extendedSystem.provider.resolveActorRef(identifier)
// Then use the ActorRef</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L139-L148" target="_blank" title="Go to snippet source"></a><code class="language-java">// Serialize
// (beneath toBinary)
String identifier = Serialization.serializedActorPath(theActorRef);

// Then just serialize the identifier however you like

// Deserialize
// (beneath fromBinary)
final ActorRef deserializedActorRef = extendedSystem.provider().resolveActorRef(identifier);
// Then just use the ActorRef</code></pre></dd>
</dl>
<p>This assumes that serialization happens in the context of sending a message through the remote transport. There are other uses of serialization, though, e.g. storing actor references outside of an actor application (database, etc.). In this case, it is important to keep in mind that the address part of an actor’s path determines how that actor is communicated with. Storing a local actor path might be the right choice if the retrieval happens in the same logical context, but it is not enough when deserializing it on a different network host: for that it would need to include the system’s remote transport address. An actor system is not limited to having just one remote transport per se, which makes this question a bit more interesting. To find out the appropriate address to use when sending to <code>remoteAddr</code> you can use <code>ActorRefProvider.getExternalAddressFor(remoteAddr)</code> like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L226-L243" target="_blank" title="Go to snippet source"></a><code class="language-scala">object ExternalAddress extends ExtensionId[ExternalAddressExt] with ExtensionIdProvider {
  override def lookup() = ExternalAddress

  override def createExtension(system: ExtendedActorSystem): ExternalAddressExt =
    new ExternalAddressExt(system)

  override def get(system: ActorSystem): ExternalAddressExt = super.get(system)
}

class ExternalAddressExt(system: ExtendedActorSystem) extends Extension {
  def addressFor(remoteAddr: Address): Address =
    system.provider.getExternalAddressFor(remoteAddr) getOrElse
      (throw new UnsupportedOperationException(&quot;cannot send to &quot; + remoteAddr))
}

def serializeTo(ref: ActorRef, remote: Address): String =
  ref.path.toSerializationFormatWithAddress(ExternalAddress(extendedSystem).
    addressFor(remote))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L155-L200" target="_blank" title="Go to snippet source"></a><code class="language-java">static class ExternalAddressExt implements Extension {
  private final ExtendedActorSystem system;

  public ExternalAddressExt(ExtendedActorSystem system) {
    this.system = system;
  }

  public Address getAddressFor(Address remoteAddress) {
    final scala.Option&lt;Address&gt; optAddr = system.provider().getExternalAddressFor(remoteAddress);
    if (optAddr.isDefined()) {
      return optAddr.get();
    } else {
      throw new UnsupportedOperationException(&quot;cannot send to remote address &quot; + remoteAddress);
    }
  }
}

static class ExternalAddress extends AbstractExtensionId&lt;ExternalAddressExt&gt;
    implements ExtensionIdProvider {
  public static final ExternalAddress ID = new ExternalAddress();

  public ExternalAddress lookup() {
    return ID;
  }

  public ExternalAddressExt createExtension(ExtendedActorSystem system) {
    return new ExternalAddressExt(system);
  }
}

static class ExternalAddressExample {
  public String serializeTo(ActorRef ref, Address remote) {
    return ref.path()
        .toSerializationFormatWithAddress(ExternalAddress.ID.get(system).getAddressFor(remote));
  }
}
</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p><code>ActorPath.toSerializationFormatWithAddress</code> differs from <code>toString</code> if the address does not already have <code>host</code> and <code>port</code> components, i.e. it only inserts address information for local addresses.</p>
<p><code>toSerializationFormatWithAddress</code> also adds the unique id of the actor, which will change when the actor is stopped and then created again with the same name. Sending messages to a reference pointing the old actor will not be delivered to the new actor. If you don&rsquo;t want this behavior, e.g. in case of long term storage of the reference, you can use <code>toStringWithAddress</code>, which doesn&rsquo;t include the unique id.</p></div>
<p>This requires that you know at least which type of address will be supported by the system which will deserialize the resulting actor reference; if you have no concrete address handy you can create a dummy one for the right protocol using <span class="group-scala"><code>Address(protocol, &quot;&quot;, &quot;&quot;, 0)</code></span><span class="group-java"><code>new Address(protocol, &quot;&quot;, &quot;&quot;, 0)</code></span> (assuming that the actual transport used is as lenient as Akka’s RemoteActorRefProvider).</p>
<p>There is also a default remote address which is the one used by cluster support (and typical systems have just this one); you can get it like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/serialization/SerializationDocSpec.scala#L251-L266" target="_blank" title="Go to snippet source"></a><code class="language-scala">object ExternalAddress extends ExtensionId[ExternalAddressExt] with ExtensionIdProvider {
  override def lookup() = ExternalAddress

  override def createExtension(system: ExtendedActorSystem): ExternalAddressExt =
    new ExternalAddressExt(system)

  override def get(system: ActorSystem): ExternalAddressExt = super.get(system)
}

class ExternalAddressExt(system: ExtendedActorSystem) extends Extension {
  def addressForAkka: Address = system.provider.getDefaultAddress
}

def serializeAkkaDefault(ref: ActorRef): String =
  ref.path.toSerializationFormatWithAddress(ExternalAddress(theActorSystem).
    addressForAkka)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/serialization/SerializationDocTest.java#L205-L240" target="_blank" title="Go to snippet source"></a><code class="language-java">static class DefaultAddressExt implements Extension {
  private final ExtendedActorSystem system;

  public DefaultAddressExt(ExtendedActorSystem system) {
    this.system = system;
  }

  public Address getAddress() {
    return system.provider().getDefaultAddress();
  }
}

static class DefaultAddress extends AbstractExtensionId&lt;DefaultAddressExt&gt;
    implements ExtensionIdProvider {
  public static final DefaultAddress ID = new DefaultAddress();

  public DefaultAddress lookup() {
    return ID;
  }

  public DefaultAddressExt createExtension(ExtendedActorSystem system) {
    return new DefaultAddressExt(system);
  }
}

  final Address addr = DefaultAddress.ID.get(system).getAddress();</code></pre></dd>
</dl>
<p>Another solution is to encapsulate your serialization code in <code>Serialization.withTransportInformation</code>. It ensures the actorRefs are serialized using systems default address when no other address is available.</p>
<h3><a href="#deep-serialization-of-actors" name="deep-serialization-of-actors" class="anchor"><span class="anchor-link"></span></a>Deep serialization of Actors</h3>
<p>The recommended approach to do deep serialization of internal actor state is to use Akka <a href="persistence.html">Persistence</a>.</p>
<a id="disable-java-serializer"></a>
<h2><a href="#disabling-the-java-serializer" name="disabling-the-java-serializer" class="anchor"><span class="anchor-link"></span></a>Disabling the Java Serializer</h2>
<p>Since the <code>2.4.11</code> release of Akka it is possible to entirely disable the default Java Serialization mechanism. For compatibility reasons, the current (non-Artery) <a href="remoting.html">Remoting</a> still uses Java serialization for some classes, however you can disable it in this remoting implementation as well by following the steps below.</p>
<p>The first step is to enable some additional serializers that replace previous Java serialization of some internal messages. This is recommended also when you can&rsquo;t disable Java serialization completely. Those serializers are enabled with this configuration:</p>
<pre class="prettyprint"><code class="language-ruby">akka.actor {
  # Set this to on to enable serialization-bindings defined in
  # additional-serialization-bindings. Those are by default not included
  # for backwards compatibility reasons. They are enabled by default if
  # akka.remote.artery.enabled=on.
  enable-additional-serialization-bindings = on
}
</code></pre>
<p>The reason these are not enabled by default is wire-level compatibility between any 2.4.x Actor Systems. If you roll out a new cluster, all on the same Akka version that can enable these serializers it is recommended to enable this setting. When using <a href="remoting-artery.html">Remoting (codename Artery)</a> these serializers are enabled by default.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Please note that when enabling the <code>additional-serialization-bindings</code> when using the old remoting, you must do so on all nodes participating in a cluster, otherwise the mis-aligned serialization configurations will cause deserialization errors on the receiving nodes.</p></div>
<p>Java serialization is known to be slow and <a href="https://community.hpe.com/t5/Security-Research/The-perils-of-Java-deserialization/ba-p/6838995">prone to attacks</a> of various kinds - it never was designed for high throughput messaging after all. However, it is very convenient to use, thus it remained the default serialization mechanism that Akka used to serialize user messages as well as some of its internal messages in previous versions. Since the release of Artery, Akka internals do not rely on Java serialization anymore (one exception being <code>java.lang.Throwable</code>).</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>Please note Akka 2.5 by default does not use any Java Serialization for its own internal messages, unlike 2.4 where by default it sill did for a few of the messages. If you want an 2.4.x system to communicate with a 2.5.x series, for example during a rolling deployment you should first enable <code>additional-serialization-bindings</code> on the old systems. You must do so on all nodes participating in a cluster, otherwise the mis-aligned serialization configurations will cause deserialization errors on the receiving nodes. These additional serialization bindings are enabled by default in Akka 2.5.x.</p></div><div class="callout note "><div class="callout-title">Note</div>
<p>When using the new remoting implementation (codename Artery), Akka does not use Java Serialization for any of its internal messages. It is highly encouraged to disable java serialization, so please plan to do so at the earliest possibility you have in your project.</p>
<p>One may think that network bandwidth and latency limit the performance of remote messaging, but serialization is a more typical bottleneck.</p></div>
<p>For user messages, the default serializer, implemented using Java serialization, remains available and enabled. We do however recommend to disable it entirely and utilise a proper serialization library instead in order effectively utilise the improved performance and ability for rolling deployments using Artery. Libraries that we recommend to use include, but are not limited to, <a href="https://github.com/EsotericSoftware/kryo">Kryo</a> by using the <a href="https://github.com/romix/akka-kryo-serialization">akka-kryo-serialization</a> library or <a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> if you want more control over the schema evolution of your messages.</p>
<p>In order to completely disable Java Serialization in your Actor system you need to add the following configuration to your <code>application.conf</code>:</p>
<pre class="prettyprint"><code class="language-ruby">akka.actor.allow-java-serialization = off
</code></pre>
<p>This will completely disable the use of <code>akka.serialization.JavaSerialization</code> by the Akka Serialization extension, instead <code>DisabledJavaSerializer</code> will be inserted which will fail explicitly if attempts to use java serialization are made.</p>
<p>It will also enable the above mentioned <code>enable-additional-serialization-bindings</code>.</p>
<p>The log messages emitted by such serializer SHOULD be treated as potential attacks which the serializer prevented, as they MAY indicate an external operator attempting to send malicious messages intending to use java serialization as attack vector. The attempts are logged with the SECURITY marker.</p>
<p>Please note that this option does not stop you from manually invoking java serialization.</p>
<h2><a href="#serialization-compatibility" name="serialization-compatibility" class="anchor"><span class="anchor-link"></span></a>Serialization compatibility</h2>
<p>It is not safe to mix major Scala versions when using the Java serialization as Scala does not guarantee compatibility and this could lead to very surprising errors.</p>
<p>If using the Akka Protobuf serializers (implicitly with <code>akka.actor.allow-java-serialization = off</code> or explicitly with <code>enable-additional-serialization-bindings = true</code>) for the internal Akka messages those will not require the same major Scala version however you must also ensure the serializers used for your own types does not introduce the same incompatibility as Java serialization does.</p>
<h2><a href="#rolling-upgrades" name="rolling-upgrades" class="anchor"><span class="anchor-link"></span></a>Rolling upgrades</h2>
<p>A serialized remote message (or persistent event) consists of serializer-id, the manifest, and the binary payload. When deserializing it is only looking at the serializer-id to pick which <code>Serializer</code> to use for <code>fromBinary</code>. The message class (the bindings) is not used for deserialization. The manifest is only used within the <code>Serializer</code> to decide how to deserialize the payload, so one <code>Serializer</code> can handle many classes.</p>
<p>That means that it is possible to change serialization for a message by performing two rolling upgrade steps to switch to the new serializer.</p>
<ol>
  <li>
  <p>Add the <code>Serializer</code> class and define it in <code>akka.actor.serializers</code> config section, but not in  <code>akka.actor.serialization-bindings</code>. Perform a rolling upgrade for this change. This means that the  serializer class exists on all nodes and is registered, but it is still not used for serializing any  messages. That is important because during the rolling upgrade the old nodes still don&rsquo;t know about  the new serializer and would not be able to deserialize messages with that format.</p></li>
  <li>
  <p>The second change is to register that the serializer is to be used for certain classes by defining  those in the <code>akka.actor.serialization-bindings</code> config section. Perform a rolling upgrade for this  change. This means that new nodes will use the new serializer when sending messages and old nodes will  be able to deserialize the new format. Old nodes will continue to use the old serializer when sending  messages and new nodes will be able to deserialize the old format.</p></li>
</ol>
<p>As an optional third step the old serializer can be completely removed if it was not used for persistent events. It must still be possible to deserialize the events that were stored with the old serializer.</p>
<h2><a href="#external-akka-serializers" name="external-akka-serializers" class="anchor"><span class="anchor-link"></span></a>External Akka Serializers</h2>
<p><a href="https://github.com/romix/akka-quickser-serialization">Akka-quickser by Roman Levenstein</a></p>
<p><a href="https://github.com/romix/akka-kryo-serialization">Akka-kryo by Roman Levenstein</a></p>
<p><a href="https://github.com/twitter/chill">Twitter Chill Scala extensions for Kryo (based on Akka Version 2.3.x but due to backwards compatibility of the Serializer Interface this extension also works with 2.4.x)</a></p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="remoting-artery.html"><i class="icon-prev"></i> <span class="link-prev">Remoting (codename Artery)</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="io.html">I/O <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/serialization.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
