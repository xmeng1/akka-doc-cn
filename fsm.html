<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>FSM &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/fsm.html"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="css/icons.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>
<link rel="shortcut icon" href="images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<link rel="manifest" href="images/manifest.json">
<meta name="msapplication-TileImage" content="images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html#fsm" class="active page">FSM</a>
    <ul>
      <li><a href="fsm.html#dependency" class="header">Dependency</a></li>
      <li><a href="fsm.html#sample-project" class="header">Sample project</a></li>
      <li><a href="fsm.html#overview" class="header">Overview</a></li>
      <li><a href="fsm.html#a-simple-example" class="header">A Simple Example</a></li>
      <li><a href="fsm.html#reference" class="header">Reference</a></li>
      <li><a href="fsm.html#testing-and-debugging-finite-state-machines" class="header">Testing and Debugging Finite State Machines</a></li>
      <li><a href="fsm.html#examples" class="header">Examples</a></li>
    </ul></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="security/index.html" class="page">Security Announcements</a></li>
  <li><a href="guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="general/index.html" class="page">General Concepts</a></li>
  <li><a href="index-actors.html" class="page">Actors</a>
  <ul>
    <li><a href="index-actors.html#dependency" class="header">Dependency</a></li>
    <li><a href="actors.html" class="page">Actors</a></li>
    <li><a href="fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="mailboxes.html" class="page">Mailboxes</a></li>
    <li><a href="routing.html" class="page">Routing</a></li>
    <li><a href="fsm.html#fsm" class="active page">FSM</a>
    <ul>
      <li><a href="fsm.html#dependency" class="header">Dependency</a></li>
      <li><a href="fsm.html#sample-project" class="header">Sample project</a></li>
      <li><a href="fsm.html#overview" class="header">Overview</a></li>
      <li><a href="fsm.html#a-simple-example" class="header">A Simple Example</a></li>
      <li><a href="fsm.html#reference" class="header">Reference</a></li>
      <li><a href="fsm.html#testing-and-debugging-finite-state-machines" class="header">Testing and Debugging Finite State Machines</a></li>
      <li><a href="fsm.html#examples" class="header">Examples</a></li>
    </ul></li>
    <li><a href="persistence.html" class="page">Persistence</a></li>
    <li><a href="persistence-schema-evolution.html" class="page">Persistence - Schema Evolution</a></li>
    <li><a href="persistence-query.html" class="page">Persistence Query</a></li>
    <li><a href="persistence-query-leveldb.html" class="page">Persistence Query for LevelDB</a></li>
    <li><a href="persistence-fsm.html" class="page">Persistent FSM</a></li>
    <li><a href="persistence-journals.html" class="page">Persistence - Building a storage backend</a></li>
    <li><a href="testing.html" class="page">Testing Actor Systems</a></li>
  </ul></li>
  <li><a href="typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="index-cluster.html" class="page">Clustering</a></li>
  <li><a href="stream/index.html" class="page">Streams</a></li>
  <li><a href="index-network.html" class="page">Networking</a></li>
  <li><a href="discovery/index.html" class="page">Discovery</a></li>
  <li><a href="index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="index-utilities.html" class="page">Utilities</a></li>
  <li><a href="common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="project/index.html" class="page">Project Information</a></li>
  <li><a href="additional/index.html" class="page">Additional Information</a></li>
  <li><a href="chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#fsm" name="fsm" class="anchor"><span class="anchor-link"></span></a>FSM</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Finite State Machine actors, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#sample-project" name="sample-project" class="anchor"><span class="anchor-link"></span></a>Sample project</h2>
<p>You can look at the <span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-samples-fsm-java">FSM example project</a></span> <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-samples-fsm-scala">FSM example project</a></span> to see what this looks like in practice.</p>
<h2><a href="#overview" name="overview" class="anchor"><span class="anchor-link"></span></a>Overview</h2>
<p>The FSM (Finite State Machine) is available as <span class="group-scala">a mixin for the</span> <span class="group-java">an abstract base class that implements an</span> Akka Actor and is best described in the <a href="http://www.erlang.org/documentation/doc-4.8.2/doc/design_principles/fsm.html">Erlang design principles</a></p>
<p>A FSM can be described as a set of relations of the form:</p>
<blockquote>
  <p><strong>State(S) x Event(E) -&gt; Actions (A), State(S&rsquo;)</strong></p>
</blockquote>
<p>These relations are interpreted as meaning:</p>
<blockquote>
  <p><em>If we are in state S and the event E occurs, we should perform the actions A and make a transition to the state S&rsquo;.</em></p>
</blockquote>
<h2><a href="#a-simple-example" name="a-simple-example" class="anchor"><span class="anchor-link"></span></a>A Simple Example</h2>
<p>To demonstrate most of the features of the <span class="group-scala"><code>FSM</code> trait</span><span class="group-java"><code>AbstractFSM</code> class</span>, consider an actor which shall receive and queue messages while they arrive in a burst and send them on after the burst ended or a flush request is received.</p>
<p>First, consider all of the below to use these import statements:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L47-L48" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.{ ActorRef, FSM }
import scala.concurrent.duration._</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L8-L14" target="_blank" title="Go to snippet source"></a><code class="language-java">import akka.actor.AbstractFSM;
import akka.actor.ActorRef;
import akka.japi.pf.UnitMatch;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.time.Duration;</code></pre></dd>
</dl>
<p>The contract of our “Buncher” actor is that it accepts or produces the following messages:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L21-L27" target="_blank" title="Go to snippet source"></a><code class="language-scala">// received events
final case class SetTarget(ref: ActorRef)
final case class Queue(obj: Any)
case object Flush

// sent events
final case class Batch(obj: immutable.Seq[Any])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Events.java#L14-L107" target="_blank" title="Go to snippet source"></a><code class="language-java">static final class SetTarget {
  private final ActorRef ref;

  public SetTarget(ActorRef ref) {
    this.ref = ref;
  }

  public ActorRef getRef() {
    return ref;
  }

  @Override
  public String toString() {
    return &quot;SetTarget{&quot; + &quot;ref=&quot; + ref + &#39;}&#39;;
  }
}

static final class Queue {
  private final Object obj;

  public Queue(Object obj) {
    this.obj = obj;
  }

  public Object getObj() {
    return obj;
  }

  @Override
  public String toString() {
    return &quot;Queue{&quot; + &quot;obj=&quot; + obj + &#39;}&#39;;
  }
}

static final class Batch {
  private final List&lt;Object&gt; list;

  public Batch(List&lt;Object&gt; list) {
    this.list = list;
  }

  public List&lt;Object&gt; getList() {
    return list;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Batch batch = (Batch) o;

    return list.equals(batch.list);
  }

  @Override
  public int hashCode() {
    return list.hashCode();
  }

  @Override
  public String toString() {
    final StringBuilder builder = new StringBuilder();
    builder.append(&quot;Batch{list=&quot;);
    list.stream()
        .forEachOrdered(
            e -&gt; {
              builder.append(e);
              builder.append(&quot;,&quot;);
            });
    int len = builder.length();
    builder.replace(len, len, &quot;}&quot;);
    return builder.toString();
  }
}

static enum Flush {
  Flush
}</code></pre></dd>
</dl>
<p><code>SetTarget</code> is needed for starting it up, setting the destination for the <code>Batches</code> to be passed on; <code>Queue</code> will add to the internal queue while <code>Flush</code> will mark the end of a burst.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L30-L37" target="_blank" title="Go to snippet source"></a><code class="language-scala">// states
sealed trait State
case object Idle extends State
case object Active extends State

sealed trait Data
case object Uninitialized extends Data
final case class Todo(target: ActorRef, queue: immutable.Seq[Any]) extends Data</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L95-L154" target="_blank" title="Go to snippet source"></a><code class="language-java">// states
enum State {
  Idle,
  Active
}

// state data
interface Data {}

enum Uninitialized implements Data {
  Uninitialized
}

final class Todo implements Data {
  private final ActorRef target;
  private final List&lt;Object&gt; queue;

  public Todo(ActorRef target, List&lt;Object&gt; queue) {
    this.target = target;
    this.queue = queue;
  }

  public ActorRef getTarget() {
    return target;
  }

  public List&lt;Object&gt; getQueue() {
    return queue;
  }

  @Override
  public String toString() {
    return &quot;Todo{&quot; + &quot;target=&quot; + target + &quot;, queue=&quot; + queue + &#39;}&#39;;
  }

  public Todo addElement(Object element) {
    List&lt;Object&gt; nQueue = new LinkedList&lt;&gt;(queue);
    nQueue.add(element);
    return new Todo(this.target, nQueue);
  }

  public Todo copy(List&lt;Object&gt; queue) {
    return new Todo(this.target, queue);
  }

  public Todo copy(ActorRef target) {
    return new Todo(target, this.queue);
  }
}</code></pre></dd>
</dl>
<p>The actor can be in two states: no message queued (aka <code>Idle</code>) or some message queued (aka <code>Active</code>). It will stay in the <code>Active</code> state as long as messages keep arriving and no flush is requested. The internal state data of the actor is made up of the target actor reference to send the batches to and the actual queue of messages.</p>
<p>Now let’s take a look at the skeleton for our FSM actor:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L51-L94" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Buncher extends FSM[State, Data] {

  startWith(Idle, Uninitialized)

  when(Idle) {
    case Event(SetTarget(ref), Uninitialized) ⇒
      stay using Todo(ref, Vector.empty)
  }

  onTransition {
    case Active -&gt; Idle ⇒
      stateData match {
        case Todo(ref, queue) ⇒ ref ! Batch(queue)
        case _                ⇒ // nothing to do
      }
  }

  when(Active, stateTimeout = 1 second) {
    case Event(Flush | StateTimeout, t: Todo) ⇒
      goto(Idle) using t.copy(queue = Vector.empty)
  }

  whenUnhandled {
    // common code for both states
    case Event(Queue(obj), t @ Todo(_, v)) ⇒
      goto(Active) using t.copy(queue = v :+ obj)

    case Event(e, s) ⇒
      log.warning(&quot;received unhandled request {} in state {}/{}&quot;, e, stateName, s)
      stay
  }

  initialize()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L24-L157" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Buncher extends AbstractFSM&lt;State, Data&gt; {
  {
    startWith(Idle, Uninitialized);

    when(
        Idle,
        matchEvent(
            SetTarget.class,
            Uninitialized.class,
            (setTarget, uninitialized) -&gt;
                stay().using(new Todo(setTarget.getRef(), new LinkedList&lt;&gt;()))));

    onTransition(
        matchState(
                Active,
                Idle,
                () -&gt; {
                  // reuse this matcher
                  final UnitMatch&lt;Data&gt; m =
                      UnitMatch.create(
                          matchData(
                              Todo.class,
                              todo -&gt;
                                  todo.getTarget().tell(new Batch(todo.getQueue()), getSelf())));
                  m.match(stateData());
                })
            .state(
                Idle,
                Active,
                () -&gt; {
                  /* Do something here */
                }));

    when(
        Active,
        Duration.ofSeconds(1L),
        matchEvent(
            Arrays.asList(Flush.class, StateTimeout()),
            Todo.class,
            (event, todo) -&gt; goTo(Idle).using(todo.copy(new LinkedList&lt;&gt;()))));

    whenUnhandled(
        matchEvent(
                Queue.class,
                Todo.class,
                (queue, todo) -&gt; goTo(Active).using(todo.addElement(queue.getObj())))
            .anyEvent(
                (event, state) -&gt; {
                  log()
                      .warning(
                          &quot;received unhandled request {} in state {}/{}&quot;,
                          event,
                          stateName(),
                          state);
                  return stay();
                }));

    initialize();
  }
}</code></pre></dd>
</dl>
<p>The basic strategy is to declare the actor, <span class="group-scala">mixing in the <code>FSM</code> trait</span><span class="group-java">by inheriting the <code>AbstractFSM</code> class</span> and specifying the possible states and data values as type parameters. Within the body of the actor a DSL is used for declaring the state machine:</p>
<ul>
  <li><code>startWith</code> defines the initial state and initial data</li>
  <li>then there is one <code>when(&lt;state&gt;) { ... }</code> declaration per state to be handled (could potentially be multiple ones, the passed <code>PartialFunction</code> will be concatenated using <code>orElse</code>)</li>
  <li>finally starting it up using <code>initialize</code>, which performs the transition into the initial state and sets up timers (if required).</li>
</ul>
<p>In this case, we start out in the <code>Idle</code> state with <code>Uninitialized</code> data, where only the <code>SetTarget()</code> message is handled; <code>stay</code> prepares to end this event’s processing for not leaving the current state, while the <code>using</code> modifier makes the FSM replace the internal state (which is <code>Uninitialized</code> at this point) with a fresh <code>Todo()</code> object containing the target actor reference. The <code>Active</code> state has a state timeout declared, which means that if no message is received for 1 second, a <code>FSM.StateTimeout</code> message will be generated. This has the same effect as receiving the <code>Flush</code> command in this case, namely to transition back into the <code>Idle</code> state and resetting the internal queue to the empty vector. But how do messages get queued? Since this shall work identically in both states, we make use of the fact that any event which is not handled by the <code>when()</code> block is passed to the <code>whenUnhandled()</code> block:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L81-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala">whenUnhandled {
  // common code for both states
  case Event(Queue(obj), t @ Todo(_, v)) ⇒
    goto(Active) using t.copy(queue = v :+ obj)

  case Event(e, s) ⇒
    log.warning(&quot;received unhandled request {} in state {}/{}&quot;, e, stateName, s)
    stay
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L71-L85" target="_blank" title="Go to snippet source"></a><code class="language-java">whenUnhandled(
    matchEvent(
            Queue.class,
            Todo.class,
            (queue, todo) -&gt; goTo(Active).using(todo.addElement(queue.getObj())))
        .anyEvent(
            (event, state) -&gt; {
              log()
                  .warning(
                      &quot;received unhandled request {} in state {}/{}&quot;,
                      event,
                      stateName(),
                      state);
              return stay();
            }));</code></pre></dd>
</dl>
<p>The first case handled here is adding <code>Queue()</code> requests to the internal queue and going to the <code>Active</code> state (this does the obvious thing of staying in the <code>Active</code> state if already there), but only if the FSM data are not <code>Uninitialized</code> when the <code>Queue()</code> event is received. Otherwise—and in all other non-handled cases—the second case just logs a warning and does not change the internal state.</p>
<p>The only missing piece is where the <code>Batches</code> are actually sent to the target, for which we use the <code>onTransition</code> mechanism: you can declare multiple such blocks and all of them will be tried for matching behavior in case a state transition occurs (i.e. only when the state actually changes).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L64-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">onTransition {
  case Active -&gt; Idle ⇒
    stateData match {
      case Todo(ref, queue) ⇒ ref ! Batch(queue)
      case _                ⇒ // nothing to do
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L40-L59" target="_blank" title="Go to snippet source"></a><code class="language-java">onTransition(
    matchState(
            Active,
            Idle,
            () -&gt; {
              // reuse this matcher
              final UnitMatch&lt;Data&gt; m =
                  UnitMatch.create(
                      matchData(
                          Todo.class,
                          todo -&gt;
                              todo.getTarget().tell(new Batch(todo.getQueue()), getSelf())));
              m.match(stateData());
            })
        .state(
            Idle,
            Active,
            () -&gt; {
              /* Do something here */
            }));</code></pre></dd>
</dl>
<p>The transition callback is a <span class="group-scala">partial function</span><span class="group-java">builder constructed by <code>matchState</code>, followed by zero or multiple <code>state</code></span>, which takes as input a pair of states—the current and the next state. <span class="group-scala">The FSM trait includes a convenience extractor for these in form of an arrow operator, which conveniently reminds you of the direction of the state change which is being matched.</span> During the state change, the old state data is available via <span class="group-scala"><code>stateData</code></span><span class="group-java"><code>stateData()</code></span> as shown, and the new state data would be available as <span class="group-scala"><code>nextStateData</code></span><span class="group-java"><code>nextStateData()</code></span>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Same-state transitions can be implemented (when currently in state <code>S</code>) using <code>goto(S)</code> or <code>stay()</code>. The difference between those being that <code>goto(S)</code> will emit an event <code>S-&gt;S</code> event that can be handled by <code>onTransition</code>, whereas <code>stay()</code> will <em>not</em>.</p></div>
<p>To verify that this buncher actually works, it is quite easy to write a test using the <span class="group-scala"><a href="testing.html">Testing Actor Systems which is conveniently bundled with ScalaTest traits into <code>AkkaSpec</code></a></span><span class="group-java"><a href="testing.html">TestKit</a>, here using JUnit as an example</span>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L13-L231" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.Props
import scala.collection.immutable

object FSMDocSpec {
  // messages and data types
}

class FSMDocSpec extends MyFavoriteTestFrameWorkPlusAkkaTestKit {
  import FSMDocSpec._

  import akka.actor.{ ActorRef, FSM }
  import scala.concurrent.duration._
  class Buncher extends FSM[State, Data] {

    startWith(Idle, Uninitialized)

    when(Idle) {
      case Event(SetTarget(ref), Uninitialized) ⇒
        stay using Todo(ref, Vector.empty)
    }

    onTransition {
      case Active -&gt; Idle ⇒
        stateData match {
          case Todo(ref, queue) ⇒ ref ! Batch(queue)
          case _                ⇒ // nothing to do
        }
    }

    when(Active, stateTimeout = 1 second) {
      case Event(Flush | StateTimeout, t: Todo) ⇒
        goto(Idle) using t.copy(queue = Vector.empty)
    }

    whenUnhandled {
      // common code for both states
      case Event(Queue(obj), t @ Todo(_, v)) ⇒
        goto(Active) using t.copy(queue = v :+ obj)

      case Event(e, s) ⇒
        log.warning(&quot;received unhandled request {} in state {}/{}&quot;, e, stateName, s)
        stay
    }

    initialize()
  }
  object DemoCode {
    trait StateType
    case object SomeState extends StateType
    case object Processing extends StateType
    case object Error extends StateType
    case object Idle extends StateType
    case object Active extends StateType

    class Dummy extends FSM[StateType, Int] {
      class X
      val newData = 42
      object WillDo
      object Tick

      when(SomeState) {
        case Event(msg, _) ⇒
          goto(Processing) using (newData) forMax (5 seconds) replying (WillDo)
      }

      onTransition {
        case Idle -&gt; Active ⇒ setTimer(&quot;timeout&quot;, Tick, 1 second, repeat = true)
        case Active -&gt; _    ⇒ cancelTimer(&quot;timeout&quot;)
        case x -&gt; Idle      ⇒ log.info(&quot;entering Idle from &quot; + x)
      }

      onTransition(handler _)

      def handler(from: StateType, to: StateType): Unit = {
        // handle it here ...
      }

      when(Error) {
        case Event(&quot;stop&quot;, _) ⇒
          // do cleanup ...
          stop()
      }

      when(SomeState)(transform {
        case Event(bytes: ByteString, read) ⇒ stay using (read + bytes.length)
      } using {
        case s @ FSM.State(state, read, timeout, stopReason, replies) if read &gt; 1000 ⇒
          goto(Processing)
      })

      val processingTrigger: PartialFunction[State, State] = {
        case s @ FSM.State(state, read, timeout, stopReason, replies) if read &gt; 1000 ⇒
          goto(Processing)
      }

      when(SomeState)(transform {
        case Event(bytes: ByteString, read) ⇒ stay using (read + bytes.length)
      } using processingTrigger)

      onTermination {
        case StopEvent(FSM.Normal, state, data)         ⇒ // ...
        case StopEvent(FSM.Shutdown, state, data)       ⇒ // ...
        case StopEvent(FSM.Failure(cause), state, data) ⇒ // ...
      }

      whenUnhandled {
        case Event(x: X, data) ⇒
          log.info(&quot;Received unhandled event: &quot; + x)
          stay
        case Event(msg, _) ⇒
          log.warning(&quot;Received unknown event: &quot; + msg)
          goto(Error)
      }

    }

    import akka.actor.LoggingFSM
    class MyFSM extends LoggingFSM[StateType, Data] {
      override def logDepth = 12
      onTermination {
        case StopEvent(FSM.Failure(_), state, data) ⇒
          val lastEvents = getLog.mkString(&quot;\n\t&quot;)
          log.warning(&quot;Failure in state &quot; + state + &quot; with data &quot; + data + &quot;\n&quot; +
            &quot;Events leading up to this point:\n\t&quot; + lastEvents)
      }
      // ...
    }

  }

  &quot;simple finite state machine&quot; must {

    &quot;demonstrate NullFunction&quot; in {
      class A extends FSM[Int, Null] {
        val SomeState = 0
        when(SomeState)(FSM.NullFunction)
      }
    }

    &quot;batch correctly&quot; in {
      val buncher = system.actorOf(Props(classOf[Buncher], this))
      buncher ! SetTarget(testActor)
      buncher ! Queue(42)
      buncher ! Queue(43)
      expectMsg(Batch(immutable.Seq(42, 43)))
      buncher ! Queue(44)
      buncher ! Flush
      buncher ! Queue(45)
      expectMsg(Batch(immutable.Seq(44)))
      expectMsg(Batch(immutable.Seq(45)))
    }

    &quot;not batch if uninitialized&quot; in {
      val buncher = system.actorOf(Props(classOf[Buncher], this))
      buncher ! Queue(42)
      expectNoMsg
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/BuncherTest.java#L23-L79" target="_blank" title="Go to snippet source"></a><code class="language-java">public class BuncherTest extends AbstractJavaTest {

  static ActorSystem system;

  @BeforeClass
  public static void setup() {
    system = ActorSystem.create(&quot;BuncherTest&quot;);
  }

  @AfterClass
  public static void tearDown() {
    TestKit.shutdownActorSystem(system);
    system = null;
  }

  @Test
  public void testBuncherActorBatchesCorrectly() {
    new TestKit(system) {
      {
        final ActorRef buncher = system.actorOf(Props.create(Buncher.class));
        final ActorRef probe = getRef();

        buncher.tell(new SetTarget(probe), probe);
        buncher.tell(new Queue(42), probe);
        buncher.tell(new Queue(43), probe);
        LinkedList&lt;Object&gt; list1 = new LinkedList&lt;&gt;();
        list1.add(42);
        list1.add(43);
        expectMsgEquals(new Batch(list1));
        buncher.tell(new Queue(44), probe);
        buncher.tell(Flush, probe);
        buncher.tell(new Queue(45), probe);
        LinkedList&lt;Object&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(44);
        expectMsgEquals(new Batch(list2));
        LinkedList&lt;Object&gt; list3 = new LinkedList&lt;&gt;();
        list3.add(45);
        expectMsgEquals(new Batch(list3));
        system.stop(buncher);
      }
    };
  }

  @Test
  public void testBuncherActorDoesntBatchUninitialized() {
    new TestKit(system) {
      {
        final ActorRef buncher = system.actorOf(Props.create(Buncher.class));
        final ActorRef probe = getRef();

        buncher.tell(new Queue(42), probe);
        expectNoMessage();
        system.stop(buncher);
      }
    };
  }
}</code></pre></dd>
</dl>
<h2><a href="#reference" name="reference" class="anchor"><span class="anchor-link"></span></a>Reference</h2>
<h3><a href="#the-" name="the-" class="anchor"><span class="anchor-link"></span></a>The <span class="group-scala">FSM Trait and Object</span><span class="group-java">AbstractFSM Class</span></h3>
<p><span class="group-scala"> The <code>FSM</code> trait inherits directly from <code>Actor</code>, when you extend <code>FSM</code> you must be aware that an actor is actually created: </span> <span class="group-java"> The <code>AbstractFSM</code> abstract class is the base class used to implement an FSM. It implements Actor since an Actor is created to drive the FSM. </span></p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L51-L94" target="_blank" title="Go to snippet source"></a><code class="language-scala">class Buncher extends FSM[State, Data] {

  startWith(Idle, Uninitialized)

  when(Idle) {
    case Event(SetTarget(ref), Uninitialized) ⇒
      stay using Todo(ref, Vector.empty)
  }

  onTransition {
    case Active -&gt; Idle ⇒
      stateData match {
        case Todo(ref, queue) ⇒ ref ! Batch(queue)
        case _                ⇒ // nothing to do
      }
  }

  when(Active, stateTimeout = 1 second) {
    case Event(Flush | StateTimeout, t: Todo) ⇒
      goto(Idle) using t.copy(queue = Vector.empty)
  }

  whenUnhandled {
    // common code for both states
    case Event(Queue(obj), t @ Todo(_, v)) ⇒
      goto(Active) using t.copy(queue = v :+ obj)

    case Event(e, s) ⇒
      log.warning(&quot;received unhandled request {} in state {}/{}&quot;, e, stateName, s)
      stay
  }

  initialize()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L24-L157" target="_blank" title="Go to snippet source"></a><code class="language-java">public class Buncher extends AbstractFSM&lt;State, Data&gt; {
  {
    startWith(Idle, Uninitialized);

    when(
        Idle,
        matchEvent(
            SetTarget.class,
            Uninitialized.class,
            (setTarget, uninitialized) -&gt;
                stay().using(new Todo(setTarget.getRef(), new LinkedList&lt;&gt;()))));

    onTransition(
        matchState(
                Active,
                Idle,
                () -&gt; {
                  // reuse this matcher
                  final UnitMatch&lt;Data&gt; m =
                      UnitMatch.create(
                          matchData(
                              Todo.class,
                              todo -&gt;
                                  todo.getTarget().tell(new Batch(todo.getQueue()), getSelf())));
                  m.match(stateData());
                })
            .state(
                Idle,
                Active,
                () -&gt; {
                  /* Do something here */
                }));

    when(
        Active,
        Duration.ofSeconds(1L),
        matchEvent(
            Arrays.asList(Flush.class, StateTimeout()),
            Todo.class,
            (event, todo) -&gt; goTo(Idle).using(todo.copy(new LinkedList&lt;&gt;()))));

    whenUnhandled(
        matchEvent(
                Queue.class,
                Todo.class,
                (queue, todo) -&gt; goTo(Active).using(todo.addElement(queue.getObj())))
            .anyEvent(
                (event, state) -&gt; {
                  log()
                      .warning(
                          &quot;received unhandled request {} in state {}/{}&quot;,
                          event,
                          stateName(),
                          state);
                  return stay();
                }));

    initialize();
  }
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>The <span class="group-scala"><code>FSM</code> trait</span><span class="group-java"><code>AbstractFSM</code> class</span> defines a <code>receive</code> method which handles internal messages and passes everything else through to the FSM logic (according to the current state). When overriding the <code>receive</code> method, keep in mind that e.g. state timeout handling depends on actually passing the messages through the FSM logic.</p></div>
<p>The <span class="group-scala"><code>FSM</code> trait</span><span class="group-java"><code>AbstractFSM</code> class</span> takes two type parameters:</p>
<ol>
  <li>the supertype of all state names, usually <span class="group-scala">a sealed trait with case objects extending it</span><span class="group-java">an enum</span></li>
  <li>the type of the state data which are tracked by the <span class="group-scala"><code>FSM</code></span><span class="group-java"><code>AbstractFSM</code></span> module itself.</li>
</ol><div class="callout note "><div class="callout-title">Note</div>
<p>The state data together with the state name describe the internal state of the state machine; if you stick to this scheme and do not add mutable fields to the FSM class you have the advantage of making all changes of the internal state explicit in a few well-known places.</p></div>
<h3><a href="#defining-states" name="defining-states" class="anchor"><span class="anchor-link"></span></a>Defining States</h3>
<p>A state is defined by one or more invocations of the method</p>
<pre><code>when(&lt;name&gt;[, stateTimeout = &lt;timeout&gt;])(stateFunction)
</code></pre>
<p>The given name must be an object which is type-compatible with the first type parameter given to the <span class="group-scala"><code>FSM</code> trait</span><span class="group-java"><code>AbstractFSM</code> class</span>. This object is used as a hash key, so you must ensure that it properly implements <code>equals</code> and <code>hashCode</code>; in particular it must not be mutable. The easiest fit for these requirements are case objects.</p>
<p>If the <code>stateTimeout</code> parameter is given, then all transitions into this state, including staying, receive this timeout by default. Initiating the transition with an explicit timeout may be used to override this default, see <a href="#initiating-transitions">Initiating Transitions</a> for more information. The state timeout of any state may be changed during action processing with <code>setStateTimeout(state, duration)</code>. This enables runtime configuration e.g. via external message.</p>
<p>The <code>stateFunction</code> argument is a <code>PartialFunction[Event, State]</code>, which is conveniently given using the <span class="group-scala">partial function literal</span><span class="group-java">state function builder</span> syntax as demonstrated below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L57-L77" target="_blank" title="Go to snippet source"></a><code class="language-scala">when(Idle) {
  case Event(SetTarget(ref), Uninitialized) ⇒
    stay using Todo(ref, Vector.empty)
}

when(Active, stateTimeout = 1 second) {
  case Event(Flush | StateTimeout, t: Todo) ⇒
    goto(Idle) using t.copy(queue = Vector.empty)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/Buncher.java#L30-L36" target="_blank" title="Go to snippet source"></a><code class="language-java">when(
    Idle,
    matchEvent(
        SetTarget.class,
        Uninitialized.class,
        (setTarget, uninitialized) -&gt;
            stay().using(new Todo(setTarget.getRef(), new LinkedList&lt;&gt;()))));</code></pre></dd>
</dl><div class="group-scala">
<p>The <code>Event(msg: Any, data: D)</code> case class is parameterized with the data type held by the FSM for convenient pattern matching.</p></div><div class="callout warning "><div class="callout-title">Warning</div>
<p>It is required that you define handlers for each of the possible FSM states, otherwise there will be failures when trying to switch to undeclared states.</p></div>
<p>It is recommended practice to declare the states as <span class="group-scala">objects extending a sealed trait</span><span class="group-java">an enum</span> and then verify that there is a <code>when</code> clause for each of the states. If you want to leave the handling of a state “unhandled” (more below), it still needs to be declared like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L207" target="_blank" title="Go to snippet source"></a><code class="language-scala">when(SomeState)(FSM.NullFunction)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L77" target="_blank" title="Go to snippet source"></a><code class="language-java">when(SomeState, AbstractFSM.NullFunction());</code></pre></dd>
</dl>
<h3><a href="#defining-the-initial-state" name="defining-the-initial-state" class="anchor"><span class="anchor-link"></span></a>Defining the Initial State</h3>
<p>Each FSM needs a starting point, which is declared using</p>
<pre><code>startWith(state, data[, timeout])
</code></pre>
<p>The optionally given timeout argument overrides any specification given for the desired initial state. If you want to cancel a default timeout, use <span class="group-scala"><code>None</code></span><span class="group-java"><code>Duration.Inf</code></span>.</p>
<h3><a href="#unhandled-events" name="unhandled-events" class="anchor"><span class="anchor-link"></span></a>Unhandled Events</h3>
<p>If a state doesn&rsquo;t handle a received event a warning is logged. If you want to do something else in this case you can specify that with <code>whenUnhandled(stateFunction)</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L170-L177" target="_blank" title="Go to snippet source"></a><code class="language-scala">whenUnhandled {
  case Event(x: X, data) ⇒
    log.info(&quot;Received unhandled event: &quot; + x)
    stay
  case Event(msg, _) ⇒
    log.warning(&quot;Received unknown event: &quot; + msg)
    goto(Error)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L122-L134" target="_blank" title="Go to snippet source"></a><code class="language-java">  whenUnhandled(
      matchEvent(
              X.class,
              (x, data) -&gt; {
                log().info(&quot;Received unhandled event: &quot; + x);
                return stay();
              })
          .anyEvent(
              (event, data) -&gt; {
                log().warning(&quot;Received unknown event: &quot; + event);
                return goTo(Error);
              }));
}</code></pre></dd>
</dl>
<p>Within this handler the state of the FSM may be queried using the <code>stateName</code> method.</p>
<p><strong>IMPORTANT</strong>: This handler is not stacked, meaning that each invocation of <code>whenUnhandled</code> replaces the previously installed handler.</p>
<h3><a href="#initiating-transitions" name="initiating-transitions" class="anchor"><span class="anchor-link"></span></a>Initiating Transitions</h3>
<p>The result of any <code>stateFunction</code> must be a definition of the next state unless terminating the FSM, which is described in <a href="#termination-from-inside">Termination from Inside</a>. The state definition can either be the current state, as described by the <code>stay</code> directive, or it is a different state as given by <code>goto(state)</code>. The resulting object allows further qualification by way of the modifiers described in the following:</p>
<ul>
  <li> <code>forMax(duration)</code>  This modifier sets a state timeout on the next state. This means that a timer is started which upon expiry sends a <code>StateTimeout</code> message to the FSM. This timer is canceled upon reception of any other message in the meantime; you can rely on the fact that the <code>StateTimeout</code> message will not be processed after an intervening message.  This modifier can also be used to override any default timeout which is specified for the target state. If you want to cancel the default timeout, use <code>Duration.Inf</code>.</li>
  <li> <code>using(data)</code>  This modifier replaces the old state data with the new data given. If you follow the advice <a href="#fsm-philosophy">above</a>, this is the only place where internal state data are ever modified.</li>
  <li> <code>replying(msg)</code>  This modifier sends a reply to the currently processed message and otherwise does not modify the state transition.</li>
</ul>
<p>All modifiers can be chained to achieve a nice and concise description:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L111-L114" target="_blank" title="Go to snippet source"></a><code class="language-scala">when(SomeState) {
  case Event(msg, _) ⇒
    goto(Processing) using (newData) forMax (5 seconds) replying (WillDo)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L65-L73" target="_blank" title="Go to snippet source"></a><code class="language-java">when(
    SomeState,
    matchAnyEvent(
        (msg, data) -&gt; {
          return goTo(Processing)
              .using(newData)
              .forMax(Duration.ofSeconds(5))
              .replying(WillDo);
        }));</code></pre></dd>
</dl>
<p>The parentheses are not actually needed in all cases, but they visually distinguish between modifiers and their arguments and therefore make the code even more pleasant to read.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Please note that the <code>return</code> statement may not be used in <code>when</code> blocks or similar; this is a Scala restriction. Either refactor your code using <code>if () ... else ...</code> or move it into a method definition.</p></div>
<h3><a href="#monitoring-transitions" name="monitoring-transitions" class="anchor"><span class="anchor-link"></span></a>Monitoring Transitions</h3>
<p>Transitions occur &ldquo;between states&rdquo; conceptually, which means after any actions you have put into the event handling block; this is obvious since the next state is only defined by the value returned by the event handling logic. You do not need to worry about the exact order with respect to setting the internal state variable, as everything within the FSM actor is running single-threaded anyway.</p>
<h4><a href="#internal-monitoring" name="internal-monitoring" class="anchor"><span class="anchor-link"></span></a>Internal Monitoring</h4>
<p>Up to this point, the FSM DSL has been centered on states and events. The dual view is to describe it as a series of transitions. This is enabled by the method</p>
<pre><code>onTransition(handler)
</code></pre>
<p>which associates actions with a transition instead of with a state and event. The handler is a partial function which takes a pair of states as input; no resulting state is needed as it is not possible to modify the transition in progress.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L118-L122" target="_blank" title="Go to snippet source"></a><code class="language-scala">onTransition {
  case Idle -&gt; Active ⇒ setTimer(&quot;timeout&quot;, Tick, 1 second, repeat = true)
  case Active -&gt; _    ⇒ cancelTimer(&quot;timeout&quot;)
  case x -&gt; Idle      ⇒ log.info(&quot;entering Idle from &quot; + x)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L81-L84" target="_blank" title="Go to snippet source"></a><code class="language-java">onTransition(
    matchState(Idle, Active, () -&gt; setTimer(&quot;timeout&quot;, Tick, Duration.ofSeconds(1L), true))
        .state(Active, null, () -&gt; cancelTimer(&quot;timeout&quot;))
        .state(null, Idle, (f, t) -&gt; log().info(&quot;entering Idle from &quot; + f)));</code></pre></dd>
</dl><div class="group-scala">
<p>The convenience extractor <code>-&gt;</code> enables decomposition of the pair of states with a clear visual reminder of the transition&rsquo;s direction. As usual in pattern matches, an underscore may be used for irrelevant parts; alternatively you could bind the unconstrained state to a variable, e.g. for logging as shown in the last case.</p></div>
<p>It is also possible to pass a function object accepting two states to <code>onTransition</code>, in case your transition handling logic is implemented as a method:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L126-L130" target="_blank" title="Go to snippet source"></a><code class="language-scala">onTransition(handler _)

def handler(from: StateType, to: StateType): Unit = {
  // handle it here ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L58-L88" target="_blank" title="Go to snippet source"></a><code class="language-java">public void handler(StateType from, StateType to) {
  // handle transition here
}

  onTransition(this::handler);</code></pre></dd>
</dl>
<p>The handlers registered with this method are stacked, so you can intersperse <code>onTransition</code> blocks with <code>when</code> blocks as suits your design. It should be noted, however, that <em>all handlers will be invoked for each transition</em>, not only the first matching one. This is designed specifically so you can put all transition handling for a certain aspect into one place without having to worry about earlier declarations shadowing later ones; the actions are still executed in declaration order, though.</p><div class="callout note "><div class="callout-title">Note</div>
<p>This kind of internal monitoring may be used to structure your FSM according to transitions, so that for example the cancellation of a timer upon leaving a certain state cannot be forgot when adding new target states.</p></div>
<h4><a href="#external-monitoring" name="external-monitoring" class="anchor"><span class="anchor-link"></span></a>External Monitoring</h4>
<p>External actors may be registered to be notified of state transitions by sending a message <code>SubscribeTransitionCallBack(actorRef)</code>. The named actor will be sent a <code>CurrentState(self, stateName)</code> message immediately and will receive <code>Transition(actorRef, oldState, newState)</code> messages whenever a state change is triggered.</p><div class="group-scala">
<p>Please note that a state change includes the action of performing an <code>goto(S)</code>, while already being state <code>S</code>. In that case the monitoring actor will be notified with an <code>Transition(ref,S,S)</code> message. This may be useful if your <code>FSM</code> should react on all (also same-state) transitions. In case you&rsquo;d rather not emit events for same-state transitions use <code>stay()</code> instead of <code>goto(S)</code>.</p></div>
<p>External monitors may be unregistered by sending <code>UnsubscribeTransitionCallBack(actorRef)</code> to the <code>FSM</code> actor.</p>
<p>Stopping a listener without unregistering will not remove the listener from the subscription list; use <code>UnsubscribeTransitionCallback</code> before stopping the listener.</p><div class="group-scala">
<h3><a href="#transforming-state" name="transforming-state" class="anchor"><span class="anchor-link"></span></a>Transforming State</h3>
<p>The partial functions supplied as argument to the <code>when()</code> blocks can be transformed using Scala’s full supplement of functional programming tools. In order to retain type inference, there is a helper function which may be used in case some common handling logic shall be applied to different clauses:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L142-L147" target="_blank" title="Go to snippet source"></a><code class="language-scala">when(SomeState)(transform {
  case Event(bytes: ByteString, read) ⇒ stay using (read + bytes.length)
} using {
  case s @ FSM.State(state, read, timeout, stopReason, replies) if read &gt; 1000 ⇒
    goto(Processing)
})</code></pre>
<p>It goes without saying that the arguments to this method may also be stored, to be used several times, e.g. when applying the same transformation to several <code>when()</code> blocks:</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L151-L158" target="_blank" title="Go to snippet source"></a><code class="language-scala">val processingTrigger: PartialFunction[State, State] = {
  case s @ FSM.State(state, read, timeout, stopReason, replies) if read &gt; 1000 ⇒
    goto(Processing)
}

when(SomeState)(transform {
  case Event(bytes: ByteString, read) ⇒ stay using (read + bytes.length)
} using processingTrigger)</code></pre></div>
<h3><a href="#timers" name="timers" class="anchor"><span class="anchor-link"></span></a>Timers</h3>
<p>Besides state timeouts, FSM manages timers identified by <code>String</code> names. You may set a timer using</p>
<pre><code>setTimer(name, msg, interval, repeat)
</code></pre>
<p>where <code>msg</code> is the message object which will be sent after the duration <code>interval</code> has elapsed. If <code>repeat</code> is <code>true</code>, then the timer is scheduled at fixed rate given by the <code>interval</code> parameter. Any existing timer with the same name will automatically be canceled before adding the new timer.</p>
<p>Timers may be canceled using</p>
<pre><code>cancelTimer(name)
</code></pre>
<p>which is guaranteed to work immediately, meaning that the scheduled message will not be processed after this call even if the timer already fired and queued it. The status of any timer may be inquired with</p>
<pre><code>isTimerActive(name)
</code></pre>
<p>These named timers complement state timeouts because they are not affected by intervening reception of other messages.</p>
<h3><a href="#termination-from-inside" name="termination-from-inside" class="anchor"><span class="anchor-link"></span></a>Termination from Inside</h3>
<p>The FSM is stopped by specifying the result state as</p>
<pre><code>stop([reason[, data]])
</code></pre>
<p>The reason must be one of <code>Normal</code> (which is the default), <code>Shutdown</code> or <code>Failure(reason)</code>, and the second argument may be given to change the state data which is available during termination handling.</p><div class="callout note "><div class="callout-title">Note</div>
<p>It should be noted that <code>stop</code> does not abort the actions and stop the FSM immediately. The stop action must be returned from the event handler in the same way as a state transition (but note that the <code>return</code> statement may not be used within a <code>when</code> block).</p></div>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L134-L138" target="_blank" title="Go to snippet source"></a><code class="language-scala">when(Error) {
  case Event(&quot;stop&quot;, _) ⇒
    // do cleanup ...
    stop()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L92-L99" target="_blank" title="Go to snippet source"></a><code class="language-java">when(
    Error,
    matchEventEquals(
        &quot;stop&quot;,
        (event, data) -&gt; {
          // do cleanup ...
          return stop();
        }));</code></pre></dd>
</dl>
<p>You can use <code>onTermination(handler)</code> to specify custom code that is executed when the FSM is stopped. The handler is a partial function which takes a <code>StopEvent(reason, stateName, stateData)</code> as argument:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L162-L166" target="_blank" title="Go to snippet source"></a><code class="language-scala">onTermination {
  case StopEvent(FSM.Normal, state, data)         ⇒ // ...
  case StopEvent(FSM.Shutdown, state, data)       ⇒ // ...
  case StopEvent(FSM.Failure(cause), state, data) ⇒ // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L103-L118" target="_blank" title="Go to snippet source"></a><code class="language-java">onTermination(
    matchStop(
            Normal(),
            (state, data) -&gt; {
              /* Do something here */
            })
        .stop(
            Shutdown(),
            (state, data) -&gt; {
              /* Do something here */
            })
        .stop(
            Failure.class,
            (reason, state, data) -&gt; {
              /* Do something here */
            }));</code></pre></dd>
</dl>
<p>As for the <code>whenUnhandled</code> case, this handler is not stacked, so each invocation of <code>onTermination</code> replaces the previously installed handler.</p>
<h3><a href="#termination-from-outside" name="termination-from-outside" class="anchor"><span class="anchor-link"></span></a>Termination from Outside</h3>
<p>When an <code>ActorRef</code> associated to a FSM is stopped using the <code>stop()</code> method, its <code>postStop</code> hook will be executed. The default implementation by the <span class="group-scala"><code>FSM</code> trait</span><span class="group-java"><code>AbstractFSM</code> class</span> is to execute the <code>onTermination</code> handler if that is prepared to handle a <code>StopEvent(Shutdown, ...)</code>.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>In case you override <code>postStop</code> and want to have your <code>onTermination</code> handler called, do not forget to call <code>super.postStop</code>.</p></div>
<h2><a href="#testing-and-debugging-finite-state-machines" name="testing-and-debugging-finite-state-machines" class="anchor"><span class="anchor-link"></span></a>Testing and Debugging Finite State Machines</h2>
<p>During development and for trouble shooting FSMs need care just as any other actor. There are specialized tools available as described in <a href="testing.html#testfsmref">TestFSMRef</a> and in the following.</p>
<h3><a href="#event-tracing" name="event-tracing" class="anchor"><span class="anchor-link"></span></a>Event Tracing</h3>
<p>The setting <code>akka.actor.debug.fsm</code> in <a href="general/configuration.html">configuration</a> enables logging of an event trace by <code>LoggingFSM</code> instances:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L183-L195" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.LoggingFSM
class MyFSM extends LoggingFSM[StateType, Data] {
  override def logDepth = 12
  onTermination {
    case StopEvent(FSM.Failure(_), state, data) ⇒
      val lastEvents = getLog.mkString(&quot;\n\t&quot;)
      log.warning(&quot;Failure in state &quot; + state + &quot; with data &quot; + data + &quot;\n&quot; +
        &quot;Events leading up to this point:\n\t&quot; + lastEvents)
  }
  // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L140-L197" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyFSM extends AbstractLoggingFSM&lt;StateType, Data&gt; {
  @Override
  public int logDepth() {
    return 12;
  }

  {
    onTermination(
        matchStop(
            Failure.class,
            (reason, state, data) -&gt; {
              String lastEvents = getLog().mkString(&quot;\n\t&quot;);
              log()
                  .warning(
                      &quot;Failure in state &quot;
                          + state
                          + &quot; with data &quot;
                          + data
                          + &quot;\n&quot;
                          + &quot;Events leading up to this point:\n\t&quot;
                          + lastEvents);
            }));
    // ...
  }
}</code></pre></dd>
</dl>
<p>This FSM will log at DEBUG level:</p>
<ul>
  <li>all processed events, including <code>StateTimeout</code> and scheduled timer messages</li>
  <li>every setting and cancellation of named timers</li>
  <li>all state transitions</li>
</ul>
<p>Life cycle changes and special messages can be logged as described for <a href="testing.html#actor-logging">Actors</a>.</p>
<h3><a href="#rolling-event-log" name="rolling-event-log" class="anchor"><span class="anchor-link"></span></a>Rolling Event Log</h3>
<p>The <span class="group-scala"><code>LoggingFSM</code> trait</span><span class="group-java"><code>AbstractLoggingFSM</code> class</span> adds one more feature to the FSM: a rolling event log which may be used during debugging (for tracing how the FSM entered a certain failure state) or for other creative uses:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/docs/actor/FSMDocSpec.scala#L183-L195" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.LoggingFSM
class MyFSM extends LoggingFSM[StateType, Data] {
  override def logDepth = 12
  onTermination {
    case StopEvent(FSM.Failure(_), state, data) ⇒
      val lastEvents = getLog.mkString(&quot;\n\t&quot;)
      log.warning(&quot;Failure in state &quot; + state + &quot; with data &quot; + data + &quot;\n&quot; +
        &quot;Events leading up to this point:\n\t&quot; + lastEvents)
  }
  // ...
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/actor/fsm/FSMDocTest.java#L140-L197" target="_blank" title="Go to snippet source"></a><code class="language-java">static class MyFSM extends AbstractLoggingFSM&lt;StateType, Data&gt; {
  @Override
  public int logDepth() {
    return 12;
  }

  {
    onTermination(
        matchStop(
            Failure.class,
            (reason, state, data) -&gt; {
              String lastEvents = getLog().mkString(&quot;\n\t&quot;);
              log()
                  .warning(
                      &quot;Failure in state &quot;
                          + state
                          + &quot; with data &quot;
                          + data
                          + &quot;\n&quot;
                          + &quot;Events leading up to this point:\n\t&quot;
                          + lastEvents);
            }));
    // ...
  }
}</code></pre></dd>
</dl>
<p>The <code>logDepth</code> defaults to zero, which turns off the event log.</p><div class="callout warning "><div class="callout-title">Warning</div>
<p>The log buffer is allocated during actor creation, which is why the configuration is done using a virtual method call. If you want to override with a <code>val</code>, make sure that its initialization happens before the initializer of <code>LoggingFSM</code> runs, and do not change the value returned by <code>logDepth</code> after the buffer has been allocated.</p></div>
<p>The contents of the event log are available using method <code>getLog</code>, which returns an <code>IndexedSeq[LogEntry]</code> where the oldest entry is at index zero.</p>
<h2><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h2>
<p>A bigger FSM example contrasted with Actor&rsquo;s <code>become</code>/<code>unbecome</code> can be downloaded as a ready to run <span class="group-scala"><a href="https://example.lightbend.com/v1/download/akka-samples-fsm-scala">Akka FSM sample</a></span><span class="group-java"><a href="https://example.lightbend.com/v1/download/akka-samples-fsm-java">Akka FSM sample</a></span> together with a tutorial. The source code of this sample can be found in the <span class="group-scala"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-sample-fsm-scala">Akka Samples Repository</a></span><span class="group-java"><a href="https://developer.lightbend.com/start/?group=akka&project=akka-sample-fsm-java">Akka Samples Repository</a></span>.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="routing.html"><i class="icon-prev"></i> <span class="link-prev">Routing</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="persistence.html">Persistence <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/fsm.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="assets/js/scalafiddle.js"></script>


</body>
</html>
