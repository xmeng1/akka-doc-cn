<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 5: Querying Device Groups &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/guide/tutorial_5.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
    <li><a href="../guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="../guide/tutorial_5.html#part-5-querying-device-groups" class="active page">Part 5: Querying Device Groups</a>
    <ul>
      <li><a href="../guide/tutorial_5.html#dependency" class="header">Dependency</a></li>
      <li><a href="../guide/tutorial_5.html#introduction" class="header">Introduction</a></li>
      <li><a href="../guide/tutorial_5.html#dealing-with-possible-scenarios" class="header">Dealing with possible scenarios</a></li>
      <li><a href="../guide/tutorial_5.html#implementing-the-query" class="header">Implementing the query</a></li>
      <li><a href="../guide/tutorial_5.html#adding-query-capability-to-the-group" class="header">Adding query capability to the group</a></li>
      <li><a href="../guide/tutorial_5.html#summary" class="header">Summary</a></li>
      <li><a href="../guide/tutorial_5.html#whats-next-" class="header">What&rsquo;s Next?</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
    <li><a href="../guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
    <li><a href="../guide/tutorial_5.html#part-5-querying-device-groups" class="active page">Part 5: Querying Device Groups</a>
    <ul>
      <li><a href="../guide/tutorial_5.html#dependency" class="header">Dependency</a></li>
      <li><a href="../guide/tutorial_5.html#introduction" class="header">Introduction</a></li>
      <li><a href="../guide/tutorial_5.html#dealing-with-possible-scenarios" class="header">Dealing with possible scenarios</a></li>
      <li><a href="../guide/tutorial_5.html#implementing-the-query" class="header">Implementing the query</a></li>
      <li><a href="../guide/tutorial_5.html#adding-query-capability-to-the-group" class="header">Adding query capability to the group</a></li>
      <li><a href="../guide/tutorial_5.html#summary" class="header">Summary</a></li>
      <li><a href="../guide/tutorial_5.html#whats-next-" class="header">What&rsquo;s Next?</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-5-querying-device-groups" name="part-5-querying-device-groups" class="anchor"><span class="anchor-link"></span></a>Part 5: Querying Device Groups</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>Add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>The conversational patterns that we have seen so far are simple in the sense that they require the actor to keep little or no state. Specifically:</p>
<ul>
  <li>Device actors return a reading, which requires no state change</li>
  <li>Record a temperature, which updates a single field</li>
  <li>Device Group actors maintain group membership by adding or removing entries from a map</li>
</ul>
<p>In this part, we will use a more complex example. Since homeowners will be interested in the temperatures throughout their home, our goal is to be able to query all of the device actors in a group. Let us start by investigating how such a query API should behave.</p>
<h2><a href="#dealing-with-possible-scenarios" name="dealing-with-possible-scenarios" class="anchor"><span class="anchor-link"></span></a>Dealing with possible scenarios</h2>
<p>The very first issue we face is that the membership of a group is dynamic. Each sensor device is represented by an actor that can stop at any time. At the beginning of the query, we can ask all of the existing device actors for the current temperature. However, during the lifecycle of the query:</p>
<ul>
  <li>A device actor might stop and not be able to respond back with a temperature reading.</li>
  <li>A new device actor might start up and not be included in the query because we weren&rsquo;t aware of it.</li>
</ul>
<p>These issues can be addressed in many different ways, but the important point is to settle on the desired behavior. The following works well for our use case:</p>
<ul>
  <li>When a query arrives, the group actor takes a <em>snapshot</em> of the existing device actors and will only ask those actors for the temperature.</li>
  <li>Actors that start up <em>after</em> the query arrives are ignored.</li>
  <li>If an actor in the snapshot stops during the query without answering, we will report the fact that it stopped to the sender of the query message.</li>
</ul>
<p>Apart from device actors coming and going dynamically, some actors might take a long time to answer. For example, they could be stuck in an accidental infinite loop, or fail due to a bug and drop our request. We don&rsquo;t want the query to continue indefinitely, so we will consider it complete in either of the following cases:</p>
<ul>
  <li>All actors in the snapshot have either responded or have confirmed being stopped.</li>
  <li>We reach a pre-defined deadline.</li>
</ul>
<p>Given these decisions, along with the fact that a device in the snapshot might have just started and not yet received a temperature to record, we can define four states for each device actor, with respect to a temperature query:</p>
<ul>
  <li>It has a temperature available: <span class="group-scala"><code>Temperature(value)</code></span> <span class="group-java"><code>Temperature</code></span>.</li>
  <li>It has responded, but has no temperature available yet: <code>TemperatureNotAvailable</code>.</li>
  <li>It has stopped before answering: <code>DeviceNotAvailable</code>.</li>
  <li>It did not respond before the deadline: <code>DeviceTimedOut</code>.</li>
</ul>
<p>Summarizing these in message types we can add the following to <code>DeviceGroup</code>:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroup.scala#L20-L27" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class RequestAllTemperatures(requestId: Long)
final case class RespondAllTemperatures(requestId: Long, temperatures: Map[String, TemperatureReading])

sealed trait TemperatureReading
final case class Temperature(value: Double) extends TemperatureReading
case object TemperatureNotAvailable extends TemperatureReading
case object DeviceNotAvailable extends TemperatureReading
case object DeviceTimedOut extends TemperatureReading</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroup.java#L53-L112" target="_blank" title="Go to snippet source"></a><code class="language-java">public static final class RequestAllTemperatures {
  final long requestId;

  public RequestAllTemperatures(long requestId) {
    this.requestId = requestId;
  }
}

public static final class RespondAllTemperatures {
  final long requestId;
  final Map&lt;String, TemperatureReading&gt; temperatures;

  public RespondAllTemperatures(long requestId, Map&lt;String, TemperatureReading&gt; temperatures) {
    this.requestId = requestId;
    this.temperatures = temperatures;
  }
}

public static interface TemperatureReading {}

public static final class Temperature implements TemperatureReading {
  public final double value;

  public Temperature(double value) {
    this.value = value;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Temperature that = (Temperature) o;

    return Double.compare(that.value, value) == 0;
  }

  @Override
  public int hashCode() {
    long temp = Double.doubleToLongBits(value);
    return (int) (temp ^ (temp &gt;&gt;&gt; 32));
  }

  @Override
  public String toString() {
    return &quot;Temperature{&quot; + &quot;value=&quot; + value + &#39;}&#39;;
  }
}

public enum TemperatureNotAvailable implements TemperatureReading {
  INSTANCE
}

public enum DeviceNotAvailable implements TemperatureReading {
  INSTANCE
}

public enum DeviceTimedOut implements TemperatureReading {
  INSTANCE
}</code></pre></dd>
</dl>
<h2><a href="#implementing-the-query" name="implementing-the-query" class="anchor"><span class="anchor-link"></span></a>Implementing the query</h2>
<p>One approach for implementing the query involves adding code to the group device actor. However, in practice this can be very cumbersome and error prone. Remember that when we start a query, we need to take a snapshot of the devices present and start a timer so that we can enforce the deadline. In the meantime, <em>another query</em> can arrive. For the second query we need to keep track of the exact same information but in isolation from the previous query. This would require us to maintain separate mappings between queries and device actors.</p>
<p>Instead, we will implement a simpler, and superior approach. We will create an actor that represents a <em>single query</em> and that performs the tasks needed to complete the query on behalf of the group actor. So far we have created actors that belonged to classical domain objects, but now, we will create an actor that represents a process or a task rather than an entity. We benefit by keeping our group device actor simple and being able to better test query capability in isolation.</p>
<h3><a href="#defining-the-query-actor" name="defining-the-query-actor" class="anchor"><span class="anchor-link"></span></a>Defining the query actor</h3>
<p>First, we need to design the lifecycle of our query actor. This consists of identifying its initial state, the first action it will take, and the cleanup &#8212; if necessary. The query actor will need the following information:</p>
<ul>
  <li>The snapshot and IDs of active device actors to query.</li>
  <li>The ID of the request that started the query (so that we can include it in the reply).</li>
  <li>The reference of the actor who sent the query. We will send the reply to this actor directly.</li>
  <li>A deadline that indicates how long the query should wait for replies. Making this a parameter will simplify testing.</li>
</ul>
<h4><a href="#scheduling-the-query-timeout" name="scheduling-the-query-timeout" class="anchor"><span class="anchor-link"></span></a>Scheduling the query timeout</h4>
<p>Since we need a way to indicate how long we are willing to wait for responses, it is time to introduce a new Akka feature that we have not used yet, the built-in scheduler facility. Using the scheduler is simple:</p>
<ul>
  <li>We get the scheduler from the <code>ActorSystem</code>, which, in turn, is accessible from the actor&rsquo;s context: <span class="group-scala"><code>context.system.scheduler</code></span><span class="group-java"><code>getContext().getSystem().scheduler()</code></span>. This needs an <span class="group-scala">implicit</span> <code>ExecutionContext</code> which is the thread-pool that will execute the timer task itself. In our case, we use the same dispatcher as the actor by <span class="group-scala">importing <code>import context.dispatcher</code></span> <span class="group-java">passing in <code>getContext().getDispatcher()</code></span>.</li>
  <li>The <span class="group-scala"><code>scheduler.scheduleOnce(time, actorRef, message)</code></span> <span class="group-java"><code>scheduler.scheduleOnce(time, actorRef, message, executor, sender)</code></span> method will schedule the message <code>message</code> into the future by the specified <code>time</code> and send it to the actor <code>actorRef</code>.</li>
</ul>
<p>We need to create a message that represents the query timeout. We create a simple message <code>CollectionTimeout</code> without any parameters for this purpose. The return value from <code>scheduleOnce</code> is a <code>Cancellable</code> which can be used to cancel the timer if the query finishes successfully in time. At the start of the query, we need to ask each of the device actors for the current temperature. To be able to quickly detect devices that stopped before they got the <code>ReadTemperature</code> message we will also watch each of the actors. This way, we get <code>Terminated</code> messages for those that stop during the lifetime of the query, so we don&rsquo;t need to wait until the timeout to mark these as not available.</p>
<p>Putting this together, the outline of our <code>DeviceGroupQuery</code> actor looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuery.scala#L13-L103" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroupQuery {
  case object CollectionTimeout

  def props(
    actorToDeviceId: Map[ActorRef, String],
    requestId:       Long,
    requester:       ActorRef,
    timeout:         FiniteDuration
  ): Props = {
    Props(new DeviceGroupQuery(actorToDeviceId, requestId, requester, timeout))
  }
}

class DeviceGroupQuery(
  actorToDeviceId: Map[ActorRef, String],
  requestId:       Long,
  requester:       ActorRef,
  timeout:         FiniteDuration
) extends Actor with ActorLogging {
  import DeviceGroupQuery._
  import context.dispatcher
  val queryTimeoutTimer = context.system.scheduler.scheduleOnce(timeout, self, CollectionTimeout)

  override def preStart(): Unit = {
    actorToDeviceId.keysIterator.foreach { deviceActor ⇒
      context.watch(deviceActor)
      deviceActor ! Device.ReadTemperature(0)
    }
  }

  override def postStop(): Unit = {
    queryTimeoutTimer.cancel()
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQuery.java#L25-L147" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroupQuery extends AbstractActor {
  public static final class CollectionTimeout {}

  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final Map&lt;ActorRef, String&gt; actorToDeviceId;
  final long requestId;
  final ActorRef requester;

  Cancellable queryTimeoutTimer;

  public DeviceGroupQuery(
      Map&lt;ActorRef, String&gt; actorToDeviceId,
      long requestId,
      ActorRef requester,
      FiniteDuration timeout) {
    this.actorToDeviceId = actorToDeviceId;
    this.requestId = requestId;
    this.requester = requester;

    queryTimeoutTimer =
        getContext()
            .getSystem()
            .scheduler()
            .scheduleOnce(
                timeout,
                getSelf(),
                new CollectionTimeout(),
                getContext().getDispatcher(),
                getSelf());
  }

  public static Props props(
      Map&lt;ActorRef, String&gt; actorToDeviceId,
      long requestId,
      ActorRef requester,
      FiniteDuration timeout) {
    return Props.create(
        DeviceGroupQuery.class,
        () -&gt; new DeviceGroupQuery(actorToDeviceId, requestId, requester, timeout));
  }

  @Override
  public void preStart() {
    for (ActorRef deviceActor : actorToDeviceId.keySet()) {
      getContext().watch(deviceActor);
      deviceActor.tell(new Device.ReadTemperature(0L), getSelf());
    }
  }

  @Override
  public void postStop() {
    queryTimeoutTimer.cancel();
  }

}</code></pre></dd>
</dl>
<h4><a href="#tracking-actor-state" name="tracking-actor-state" class="anchor"><span class="anchor-link"></span></a>Tracking actor state</h4>
<p>The query actor, apart from the pending timer, has one stateful aspect, tracking the set of actors that: have replied, have stopped, or have not replied. One way to track this state is to create a mutable field in the actor <span class="group-scala">(a <code>var</code>)</span>. A different approach takes advantage of the ability to change how an actor responds to messages. A <code>Receive</code> is just a function (or an object, if you like) that can be returned from another function. By default, the <code>receive</code> block defines the behavior of the actor, but it is possible to change it multiple times during the life of the actor. We call <code>context.become(newBehavior)</code> where <code>newBehavior</code> is anything with type <code>Receive</code> <span class="group-scala">(which is a shorthand for <code>PartialFunction[Any, Unit]</code>)</span>. We will leverage this feature to track the state of our actor.</p>
<p>For our use case:</p>
<ol>
  <li>Instead of defining <code>receive</code> directly, we delegate to a <code>waitingForReplies</code> function to create the <code>Receive</code>.</li>
  <li>The <code>waitingForReplies</code> function will keep track of two changing values:</li>
</ol>
<ul>
  <li>a <code>Map</code> of already received replies</li>
  <li>a <code>Set</code> of actors that we still wait on</li>
</ul>
<ol>
  <li>We have three events to act on:</li>
</ol>
<ul>
  <li>We can receive a <code>RespondTemperature</code> message from one of the devices.</li>
  <li>We can receive a <code>Terminated</code> message for a device actor that has been stopped in the meantime.</li>
  <li>We can reach the deadline and receive a <code>CollectionTimeout</code>.</li>
</ul>
<p>In the first two cases, we need to keep track of the replies, which we now delegate to a method <code>receivedResponse</code>, which we will discuss later. In the case of timeout, we need to simply take all the actors that have not yet replied (the members of the set <code>stillWaiting</code>) and put a <code>DeviceTimedOut</code> as the status in the final reply. Then we reply to the submitter of the query with the collected results and stop the query actor.</p>
<p>To accomplish this, add the following to your <code>DeviceGroupQuery</code> source file:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuery.scala#L49-L78" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def receive: Receive =
  waitingForReplies(
    Map.empty,
    actorToDeviceId.keySet
  )

def waitingForReplies(
  repliesSoFar: Map[String, DeviceGroup.TemperatureReading],
  stillWaiting: Set[ActorRef]
): Receive = {
  case Device.RespondTemperature(0, valueOption) ⇒
    val deviceActor = sender()
    val reading = valueOption match {
      case Some(value) ⇒ DeviceGroup.Temperature(value)
      case None        ⇒ DeviceGroup.TemperatureNotAvailable
    }
    receivedResponse(deviceActor, reading, stillWaiting, repliesSoFar)

  case Terminated(deviceActor) ⇒
    receivedResponse(deviceActor, DeviceGroup.DeviceNotAvailable, stillWaiting, repliesSoFar)

  case CollectionTimeout ⇒
    val timedOutReplies =
      stillWaiting.map { deviceActor ⇒
        val deviceId = actorToDeviceId(deviceActor)
        deviceId -&gt; DeviceGroup.DeviceTimedOut
      }
    requester ! DeviceGroup.RespondAllTemperatures(requestId, repliesSoFar ++ timedOutReplies)
    context.stop(self)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQuery.java#L82-L121" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public Receive createReceive() {
  return waitingForReplies(new HashMap&lt;&gt;(), actorToDeviceId.keySet());
}

public Receive waitingForReplies(
    Map&lt;String, DeviceGroup.TemperatureReading&gt; repliesSoFar, Set&lt;ActorRef&gt; stillWaiting) {
  return receiveBuilder()
      .match(
          Device.RespondTemperature.class,
          r -&gt; {
            ActorRef deviceActor = getSender();
            DeviceGroup.TemperatureReading reading =
                r.value
                    .map(v -&gt; (DeviceGroup.TemperatureReading) new DeviceGroup.Temperature(v))
                    .orElse(DeviceGroup.TemperatureNotAvailable.INSTANCE);
            receivedResponse(deviceActor, reading, stillWaiting, repliesSoFar);
          })
      .match(
          Terminated.class,
          t -&gt; {
            receivedResponse(
                t.getActor(),
                DeviceGroup.DeviceNotAvailable.INSTANCE,
                stillWaiting,
                repliesSoFar);
          })
      .match(
          CollectionTimeout.class,
          t -&gt; {
            Map&lt;String, DeviceGroup.TemperatureReading&gt; replies = new HashMap&lt;&gt;(repliesSoFar);
            for (ActorRef deviceActor : stillWaiting) {
              String deviceId = actorToDeviceId.get(deviceActor);
              replies.put(deviceId, DeviceGroup.DeviceTimedOut.INSTANCE);
            }
            requester.tell(new DeviceGroup.RespondAllTemperatures(requestId, replies), getSelf());
            getContext().stop(getSelf());
          })
      .build();
}</code></pre></dd>
</dl>
<p>It is not yet clear how we will &ldquo;mutate&rdquo; the <code>repliesSoFar</code> and <code>stillWaiting</code> data structures. One important thing to note is that the function <code>waitingForReplies</code> <strong>does not handle the messages directly. It returns a <code>Receive</code> function that will handle the messages</strong>. This means that if we call <code>waitingForReplies</code> again, with different parameters, then it returns a brand new <code>Receive</code> that will use those new parameters.</p>
<p>We have seen how we can install the initial <code>Receive</code> by returning it from <code>receive</code>. In order to install a new one, to record a new reply, for example, we need some mechanism. This mechanism is the method <code>context.become(newReceive)</code> which will <em>change</em> the actor&rsquo;s message handling function to the provided <code>newReceive</code> function. You can imagine that before starting, your actor automatically calls <code>context.become(receive)</code>, i.e. installing the <code>Receive</code> function that is returned from <code>receive</code>. This is another important observation: <strong>it is not <code>receive</code> that handles the messages, it returns a <code>Receive</code> function that will actually handle the messages</strong>.</p>
<p>We now have to figure out what to do in <code>receivedResponse</code>. First, we need to record the new result in the map <code>repliesSoFar</code> and remove the actor from <code>stillWaiting</code>. The next step is to check if there are any remaining actors we are waiting for. If there is none, we send the result of the query to the original requester and stop the query actor. Otherwise, we need to update the <code>repliesSoFar</code> and <code>stillWaiting</code> structures and wait for more messages.</p>
<p>In the code before, we treated <code>Terminated</code> as the implicit response <code>DeviceNotAvailable</code>, so <code>receivedResponse</code> does not need to do anything special. However, there is one small task we still need to do. It is possible that we receive a proper response from a device actor, but then it stops during the lifetime of the query. We don&rsquo;t want this second event to overwrite the already received reply. In other words, we don&rsquo;t want to receive <code>Terminated</code> after we recorded the response. This is simple to achieve by calling <code>context.unwatch(ref)</code>. This method also ensures that we don&rsquo;t receive <code>Terminated</code> events that are already in the mailbox of the actor. It is also safe to call this multiple times, only the first call will have any effect, the rest is ignored.</p>
<p>With all this knowledge, we can create the <code>receivedResponse</code> method:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuery.scala#L82-L99" target="_blank" title="Go to snippet source"></a><code class="language-scala">def receivedResponse(
  deviceActor:  ActorRef,
  reading:      DeviceGroup.TemperatureReading,
  stillWaiting: Set[ActorRef],
  repliesSoFar: Map[String, DeviceGroup.TemperatureReading]
): Unit = {
  context.unwatch(deviceActor)
  val deviceId = actorToDeviceId(deviceActor)
  val newStillWaiting = stillWaiting - deviceActor

  val newRepliesSoFar = repliesSoFar + (deviceId -&gt; reading)
  if (newStillWaiting.isEmpty) {
    requester ! DeviceGroup.RespondAllTemperatures(requestId, newRepliesSoFar)
    context.stop(self)
  } else {
    context.become(waitingForReplies(newRepliesSoFar, newStillWaiting))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQuery.java#L125-L144" target="_blank" title="Go to snippet source"></a><code class="language-java">public void receivedResponse(
    ActorRef deviceActor,
    DeviceGroup.TemperatureReading reading,
    Set&lt;ActorRef&gt; stillWaiting,
    Map&lt;String, DeviceGroup.TemperatureReading&gt; repliesSoFar) {
  getContext().unwatch(deviceActor);
  String deviceId = actorToDeviceId.get(deviceActor);

  Set&lt;ActorRef&gt; newStillWaiting = new HashSet&lt;&gt;(stillWaiting);
  newStillWaiting.remove(deviceActor);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; newRepliesSoFar = new HashMap&lt;&gt;(repliesSoFar);
  newRepliesSoFar.put(deviceId, reading);
  if (newStillWaiting.isEmpty()) {
    requester.tell(new DeviceGroup.RespondAllTemperatures(requestId, newRepliesSoFar), getSelf());
    getContext().stop(getSelf());
  } else {
    getContext().become(waitingForReplies(newRepliesSoFar, newStillWaiting));
  }
}</code></pre></dd>
</dl>
<p>It is quite natural to ask at this point, what have we gained by using the <code>context.become()</code> trick instead of making the <code>repliesSoFar</code> and <code>stillWaiting</code> structures mutable fields of the actor (i.e. <code>var</code>s)? In this simple example, not that much. The value of this style of state keeping becomes more evident when you suddenly have <em>more kinds</em> of states. Since each state might have temporary data that is relevant itself, keeping these as fields would pollute the global state of the actor, i.e. it is unclear what fields are used in what state. Using parameterized <code>Receive</code> &ldquo;factory&rdquo; methods we can keep data private that is only relevant to the state. It is still a good exercise to rewrite the query using <span class="group-scala"><code>var</code>s</span> <span class="group-java">mutable fields</span> instead of <code>context.become()</code>. However, it is recommended to get comfortable with the solution we have used here as it helps structuring more complex actor code in a cleaner and more maintainable way.</p>
<p>Our query actor is now done:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuery.scala#L13-L103" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroupQuery {
  case object CollectionTimeout

  def props(
    actorToDeviceId: Map[ActorRef, String],
    requestId:       Long,
    requester:       ActorRef,
    timeout:         FiniteDuration
  ): Props = {
    Props(new DeviceGroupQuery(actorToDeviceId, requestId, requester, timeout))
  }
}

class DeviceGroupQuery(
  actorToDeviceId: Map[ActorRef, String],
  requestId:       Long,
  requester:       ActorRef,
  timeout:         FiniteDuration
) extends Actor with ActorLogging {
  import DeviceGroupQuery._
  import context.dispatcher
  val queryTimeoutTimer = context.system.scheduler.scheduleOnce(timeout, self, CollectionTimeout)

  override def preStart(): Unit = {
    actorToDeviceId.keysIterator.foreach { deviceActor ⇒
      context.watch(deviceActor)
      deviceActor ! Device.ReadTemperature(0)
    }
  }

  override def postStop(): Unit = {
    queryTimeoutTimer.cancel()
  }

  override def receive: Receive =
    waitingForReplies(
      Map.empty,
      actorToDeviceId.keySet
    )

  def waitingForReplies(
    repliesSoFar: Map[String, DeviceGroup.TemperatureReading],
    stillWaiting: Set[ActorRef]
  ): Receive = {
    case Device.RespondTemperature(0, valueOption) ⇒
      val deviceActor = sender()
      val reading = valueOption match {
        case Some(value) ⇒ DeviceGroup.Temperature(value)
        case None        ⇒ DeviceGroup.TemperatureNotAvailable
      }
      receivedResponse(deviceActor, reading, stillWaiting, repliesSoFar)

    case Terminated(deviceActor) ⇒
      receivedResponse(deviceActor, DeviceGroup.DeviceNotAvailable, stillWaiting, repliesSoFar)

    case CollectionTimeout ⇒
      val timedOutReplies =
        stillWaiting.map { deviceActor ⇒
          val deviceId = actorToDeviceId(deviceActor)
          deviceId -&gt; DeviceGroup.DeviceTimedOut
        }
      requester ! DeviceGroup.RespondAllTemperatures(requestId, repliesSoFar ++ timedOutReplies)
      context.stop(self)
  }

  def receivedResponse(
    deviceActor:  ActorRef,
    reading:      DeviceGroup.TemperatureReading,
    stillWaiting: Set[ActorRef],
    repliesSoFar: Map[String, DeviceGroup.TemperatureReading]
  ): Unit = {
    context.unwatch(deviceActor)
    val deviceId = actorToDeviceId(deviceActor)
    val newStillWaiting = stillWaiting - deviceActor

    val newRepliesSoFar = repliesSoFar + (deviceId -&gt; reading)
    if (newStillWaiting.isEmpty) {
      requester ! DeviceGroup.RespondAllTemperatures(requestId, newRepliesSoFar)
      context.stop(self)
    } else {
      context.become(waitingForReplies(newRepliesSoFar, newStillWaiting))
    }
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQuery.java#L25-L147" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroupQuery extends AbstractActor {
  public static final class CollectionTimeout {}

  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final Map&lt;ActorRef, String&gt; actorToDeviceId;
  final long requestId;
  final ActorRef requester;

  Cancellable queryTimeoutTimer;

  public DeviceGroupQuery(
      Map&lt;ActorRef, String&gt; actorToDeviceId,
      long requestId,
      ActorRef requester,
      FiniteDuration timeout) {
    this.actorToDeviceId = actorToDeviceId;
    this.requestId = requestId;
    this.requester = requester;

    queryTimeoutTimer =
        getContext()
            .getSystem()
            .scheduler()
            .scheduleOnce(
                timeout,
                getSelf(),
                new CollectionTimeout(),
                getContext().getDispatcher(),
                getSelf());
  }

  public static Props props(
      Map&lt;ActorRef, String&gt; actorToDeviceId,
      long requestId,
      ActorRef requester,
      FiniteDuration timeout) {
    return Props.create(
        DeviceGroupQuery.class,
        () -&gt; new DeviceGroupQuery(actorToDeviceId, requestId, requester, timeout));
  }

  @Override
  public void preStart() {
    for (ActorRef deviceActor : actorToDeviceId.keySet()) {
      getContext().watch(deviceActor);
      deviceActor.tell(new Device.ReadTemperature(0L), getSelf());
    }
  }

  @Override
  public void postStop() {
    queryTimeoutTimer.cancel();
  }

  @Override
  public Receive createReceive() {
    return waitingForReplies(new HashMap&lt;&gt;(), actorToDeviceId.keySet());
  }

  public Receive waitingForReplies(
      Map&lt;String, DeviceGroup.TemperatureReading&gt; repliesSoFar, Set&lt;ActorRef&gt; stillWaiting) {
    return receiveBuilder()
        .match(
            Device.RespondTemperature.class,
            r -&gt; {
              ActorRef deviceActor = getSender();
              DeviceGroup.TemperatureReading reading =
                  r.value
                      .map(v -&gt; (DeviceGroup.TemperatureReading) new DeviceGroup.Temperature(v))
                      .orElse(DeviceGroup.TemperatureNotAvailable.INSTANCE);
              receivedResponse(deviceActor, reading, stillWaiting, repliesSoFar);
            })
        .match(
            Terminated.class,
            t -&gt; {
              receivedResponse(
                  t.getActor(),
                  DeviceGroup.DeviceNotAvailable.INSTANCE,
                  stillWaiting,
                  repliesSoFar);
            })
        .match(
            CollectionTimeout.class,
            t -&gt; {
              Map&lt;String, DeviceGroup.TemperatureReading&gt; replies = new HashMap&lt;&gt;(repliesSoFar);
              for (ActorRef deviceActor : stillWaiting) {
                String deviceId = actorToDeviceId.get(deviceActor);
                replies.put(deviceId, DeviceGroup.DeviceTimedOut.INSTANCE);
              }
              requester.tell(new DeviceGroup.RespondAllTemperatures(requestId, replies), getSelf());
              getContext().stop(getSelf());
            })
        .build();
  }

  public void receivedResponse(
      ActorRef deviceActor,
      DeviceGroup.TemperatureReading reading,
      Set&lt;ActorRef&gt; stillWaiting,
      Map&lt;String, DeviceGroup.TemperatureReading&gt; repliesSoFar) {
    getContext().unwatch(deviceActor);
    String deviceId = actorToDeviceId.get(deviceActor);

    Set&lt;ActorRef&gt; newStillWaiting = new HashSet&lt;&gt;(stillWaiting);
    newStillWaiting.remove(deviceActor);

    Map&lt;String, DeviceGroup.TemperatureReading&gt; newRepliesSoFar = new HashMap&lt;&gt;(repliesSoFar);
    newRepliesSoFar.put(deviceId, reading);
    if (newStillWaiting.isEmpty()) {
      requester.tell(new DeviceGroup.RespondAllTemperatures(requestId, newRepliesSoFar), getSelf());
      getContext().stop(getSelf());
    } else {
      getContext().become(waitingForReplies(newRepliesSoFar, newStillWaiting));
    }
  }
}</code></pre></dd>
</dl>
<h3><a href="#testing-the-query-actor" name="testing-the-query-actor" class="anchor"><span class="anchor-link"></span></a>Testing the query actor</h3>
<p>Now let&rsquo;s verify the correctness of the query actor implementation. There are various scenarios we need to test individually to make sure everything works as expected. To be able to do this, we need to simulate the device actors somehow to exercise various normal or failure scenarios. Thankfully we took the list of collaborators (actually a <code>Map</code>) as a parameter to the query actor, so we can pass in <span class="group-scala"><code>TestProbe</code></span> <span class="group-java"><code>TestKit</code></span> references. In our first test, we try out the case when there are two devices and both report a temperature:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuerySpec.scala#L17-L43" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return temperature value for working devices&quot; in {
  val requester = TestProbe()

  val device1 = TestProbe()
  val device2 = TestProbe()

  val queryActor = system.actorOf(DeviceGroupQuery.props(
    actorToDeviceId = Map(device1.ref -&gt; &quot;device1&quot;, device2.ref -&gt; &quot;device2&quot;),
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMsg(Device.ReadTemperature(requestId = 0))
  device2.expectMsg(Device.ReadTemperature(requestId = 0))

  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(1.0)), device1.ref)
  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(2.0)), device2.ref)

  requester.expectMsg(DeviceGroup.RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; DeviceGroup.Temperature(1.0),
      &quot;device2&quot; -&gt; DeviceGroup.Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQueryTest.java#L42-L73" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureValueForWorkingDevices() {
  TestKit requester = new TestKit(system);

  TestKit device1 = new TestKit(system);
  TestKit device2 = new TestKit(system);

  Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();
  actorToDeviceId.put(device1.getRef(), &quot;device1&quot;);
  actorToDeviceId.put(device2.getRef(), &quot;device2&quot;);

  ActorRef queryActor =
      system.actorOf(
          DeviceGroupQuery.props(
              actorToDeviceId, 1L, requester.getRef(), new FiniteDuration(3, TimeUnit.SECONDS)));

  assertEquals(0L, device1.expectMsgClass(Device.ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMsgClass(Device.ReadTemperature.class).requestId);

  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(1.0)), device1.getRef());
  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(2.0)), device2.getRef());

  DeviceGroup.RespondAllTemperatures response =
      requester.expectMsgClass(DeviceGroup.RespondAllTemperatures.class);
  assertEquals(1L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new DeviceGroup.Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new DeviceGroup.Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>That was the happy case, but we know that sometimes devices cannot provide a temperature measurement. This scenario is just slightly different from the previous:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuerySpec.scala#L47-L73" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return TemperatureNotAvailable for devices with no readings&quot; in {
  val requester = TestProbe()

  val device1 = TestProbe()
  val device2 = TestProbe()

  val queryActor = system.actorOf(DeviceGroupQuery.props(
    actorToDeviceId = Map(device1.ref -&gt; &quot;device1&quot;, device2.ref -&gt; &quot;device2&quot;),
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMsg(Device.ReadTemperature(requestId = 0))
  device2.expectMsg(Device.ReadTemperature(requestId = 0))

  queryActor.tell(Device.RespondTemperature(requestId = 0, None), device1.ref)
  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(2.0)), device2.ref)

  requester.expectMsg(DeviceGroup.RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; DeviceGroup.TemperatureNotAvailable,
      &quot;device2&quot; -&gt; DeviceGroup.Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQueryTest.java#L77-L108" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureNotAvailableForDevicesWithNoReadings() {
  TestKit requester = new TestKit(system);

  TestKit device1 = new TestKit(system);
  TestKit device2 = new TestKit(system);

  Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();
  actorToDeviceId.put(device1.getRef(), &quot;device1&quot;);
  actorToDeviceId.put(device2.getRef(), &quot;device2&quot;);

  ActorRef queryActor =
      system.actorOf(
          DeviceGroupQuery.props(
              actorToDeviceId, 1L, requester.getRef(), new FiniteDuration(3, TimeUnit.SECONDS)));

  assertEquals(0L, device1.expectMsgClass(Device.ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMsgClass(Device.ReadTemperature.class).requestId);

  queryActor.tell(new Device.RespondTemperature(0L, Optional.empty()), device1.getRef());
  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(2.0)), device2.getRef());

  DeviceGroup.RespondAllTemperatures response =
      requester.expectMsgClass(DeviceGroup.RespondAllTemperatures.class);
  assertEquals(1L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, DeviceGroup.TemperatureNotAvailable.INSTANCE);
  expectedTemperatures.put(&quot;device2&quot;, new DeviceGroup.Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>We also know, that sometimes device actors stop before answering:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuerySpec.scala#L77-L103" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return DeviceNotAvailable if device stops before answering&quot; in {
  val requester = TestProbe()

  val device1 = TestProbe()
  val device2 = TestProbe()

  val queryActor = system.actorOf(DeviceGroupQuery.props(
    actorToDeviceId = Map(device1.ref -&gt; &quot;device1&quot;, device2.ref -&gt; &quot;device2&quot;),
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMsg(Device.ReadTemperature(requestId = 0))
  device2.expectMsg(Device.ReadTemperature(requestId = 0))

  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(1.0)), device1.ref)
  device2.ref ! PoisonPill

  requester.expectMsg(DeviceGroup.RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; DeviceGroup.Temperature(1.0),
      &quot;device2&quot; -&gt; DeviceGroup.DeviceNotAvailable
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQueryTest.java#L112-L143" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnDeviceNotAvailableIfDeviceStopsBeforeAnswering() {
  TestKit requester = new TestKit(system);

  TestKit device1 = new TestKit(system);
  TestKit device2 = new TestKit(system);

  Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();
  actorToDeviceId.put(device1.getRef(), &quot;device1&quot;);
  actorToDeviceId.put(device2.getRef(), &quot;device2&quot;);

  ActorRef queryActor =
      system.actorOf(
          DeviceGroupQuery.props(
              actorToDeviceId, 1L, requester.getRef(), new FiniteDuration(3, TimeUnit.SECONDS)));

  assertEquals(0L, device1.expectMsgClass(Device.ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMsgClass(Device.ReadTemperature.class).requestId);

  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(1.0)), device1.getRef());
  device2.getRef().tell(PoisonPill.getInstance(), ActorRef.noSender());

  DeviceGroup.RespondAllTemperatures response =
      requester.expectMsgClass(DeviceGroup.RespondAllTemperatures.class);
  assertEquals(1L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new DeviceGroup.Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, DeviceGroup.DeviceNotAvailable.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>If you remember, there is another case related to device actors stopping. It is possible that we get a normal reply from a device actor, but then receive a <code>Terminated</code> for the same actor later. In this case, we would like to keep the first reply and not mark the device as <code>DeviceNotAvailable</code>. We should test this, too:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuerySpec.scala#L107-L134" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return temperature reading even if device stops after answering&quot; in {
  val requester = TestProbe()

  val device1 = TestProbe()
  val device2 = TestProbe()

  val queryActor = system.actorOf(DeviceGroupQuery.props(
    actorToDeviceId = Map(device1.ref -&gt; &quot;device1&quot;, device2.ref -&gt; &quot;device2&quot;),
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMsg(Device.ReadTemperature(requestId = 0))
  device2.expectMsg(Device.ReadTemperature(requestId = 0))

  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(1.0)), device1.ref)
  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(2.0)), device2.ref)
  device2.ref ! PoisonPill

  requester.expectMsg(DeviceGroup.RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; DeviceGroup.Temperature(1.0),
      &quot;device2&quot; -&gt; DeviceGroup.Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQueryTest.java#L147-L179" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureReadingEvenIfDeviceStopsAfterAnswering() {
  TestKit requester = new TestKit(system);

  TestKit device1 = new TestKit(system);
  TestKit device2 = new TestKit(system);

  Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();
  actorToDeviceId.put(device1.getRef(), &quot;device1&quot;);
  actorToDeviceId.put(device2.getRef(), &quot;device2&quot;);

  ActorRef queryActor =
      system.actorOf(
          DeviceGroupQuery.props(
              actorToDeviceId, 1L, requester.getRef(), new FiniteDuration(3, TimeUnit.SECONDS)));

  assertEquals(0L, device1.expectMsgClass(Device.ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMsgClass(Device.ReadTemperature.class).requestId);

  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(1.0)), device1.getRef());
  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(2.0)), device2.getRef());
  device2.getRef().tell(PoisonPill.getInstance(), ActorRef.noSender());

  DeviceGroup.RespondAllTemperatures response =
      requester.expectMsgClass(DeviceGroup.RespondAllTemperatures.class);
  assertEquals(1L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new DeviceGroup.Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new DeviceGroup.Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>The final case is when not all devices respond in time. To keep our test relatively fast, we will construct the <code>DeviceGroupQuery</code> actor with a smaller timeout:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupQuerySpec.scala#L138-L163" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return DeviceTimedOut if device does not answer in time&quot; in {
  val requester = TestProbe()

  val device1 = TestProbe()
  val device2 = TestProbe()

  val queryActor = system.actorOf(DeviceGroupQuery.props(
    actorToDeviceId = Map(device1.ref -&gt; &quot;device1&quot;, device2.ref -&gt; &quot;device2&quot;),
    requestId = 1,
    requester = requester.ref,
    timeout = 1.second
  ))

  device1.expectMsg(Device.ReadTemperature(requestId = 0))
  device2.expectMsg(Device.ReadTemperature(requestId = 0))

  queryActor.tell(Device.RespondTemperature(requestId = 0, Some(1.0)), device1.ref)

  requester.expectMsg(DeviceGroup.RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; DeviceGroup.Temperature(1.0),
      &quot;device2&quot; -&gt; DeviceGroup.DeviceTimedOut
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupQueryTest.java#L183-L214" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnDeviceTimedOutIfDeviceDoesNotAnswerInTime() {
  TestKit requester = new TestKit(system);

  TestKit device1 = new TestKit(system);
  TestKit device2 = new TestKit(system);

  Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();
  actorToDeviceId.put(device1.getRef(), &quot;device1&quot;);
  actorToDeviceId.put(device2.getRef(), &quot;device2&quot;);

  ActorRef queryActor =
      system.actorOf(
          DeviceGroupQuery.props(
              actorToDeviceId, 1L, requester.getRef(), new FiniteDuration(1, TimeUnit.SECONDS)));

  assertEquals(0L, device1.expectMsgClass(Device.ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMsgClass(Device.ReadTemperature.class).requestId);

  queryActor.tell(new Device.RespondTemperature(0L, Optional.of(1.0)), device1.getRef());

  DeviceGroup.RespondAllTemperatures response =
      requester.expectMsgClass(
          java.time.Duration.ofSeconds(5), DeviceGroup.RespondAllTemperatures.class);
  assertEquals(1L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new DeviceGroup.Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, DeviceGroup.DeviceTimedOut.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>Our query works as expected now, it is time to include this new functionality in the <code>DeviceGroup</code> actor now.</p>
<h2><a href="#adding-query-capability-to-the-group" name="adding-query-capability-to-the-group" class="anchor"><span class="anchor-link"></span></a>Adding query capability to the group</h2>
<p>Including the query feature in the group actor is fairly simple now. We did all the heavy lifting in the query actor itself, the group actor only needs to create it with the right initial parameters and nothing else.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroup.scala#L32-L83" target="_blank" title="Go to snippet source"></a><code class="language-scala">class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]
  var actorToDeviceId = Map.empty[ActorRef, String]
  var nextCollectionId = 0L

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    // ... other cases omitted

    case RequestAllTemperatures(requestId) ⇒
      context.actorOf(DeviceGroupQuery.props(
        actorToDeviceId = actorToDeviceId,
        requestId = requestId,
        requester = sender(),
        3.seconds
      ))
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroup.java#L21-L196" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  public DeviceGroup(String groupId) {
    this.groupId = groupId;
  }

  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, () -&gt; new DeviceGroup(groupId));
  }

  public static final class RequestDeviceList {
    final long requestId;

    public RequestDeviceList(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReplyDeviceList {
    final long requestId;
    final Set&lt;String&gt; ids;

    public ReplyDeviceList(long requestId, Set&lt;String&gt; ids) {
      this.requestId = requestId;
      this.ids = ids;
    }
  }

  public static final class RequestAllTemperatures {
    final long requestId;

    public RequestAllTemperatures(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class RespondAllTemperatures {
    final long requestId;
    final Map&lt;String, TemperatureReading&gt; temperatures;

    public RespondAllTemperatures(long requestId, Map&lt;String, TemperatureReading&gt; temperatures) {
      this.requestId = requestId;
      this.temperatures = temperatures;
    }
  }

  public static interface TemperatureReading {}

  public static final class Temperature implements TemperatureReading {
    public final double value;

    public Temperature(double value) {
      this.value = value;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      Temperature that = (Temperature) o;

      return Double.compare(that.value, value) == 0;
    }

    @Override
    public int hashCode() {
      long temp = Double.doubleToLongBits(value);
      return (int) (temp ^ (temp &gt;&gt;&gt; 32));
    }

    @Override
    public String toString() {
      return &quot;Temperature{&quot; + &quot;value=&quot; + value + &#39;}&#39;;
    }
  }

  public enum TemperatureNotAvailable implements TemperatureReading {
    INSTANCE
  }

  public enum DeviceNotAvailable implements TemperatureReading {
    INSTANCE
  }

  public enum DeviceTimedOut implements TemperatureReading {
    INSTANCE
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }


  private void onAllTemperatures(RequestAllTemperatures r) {
    // since Java collections are mutable, we want to avoid sharing them between actors (since
    // multiple Actors (threads)
    // modifying the same mutable data-structure is not safe), and perform a defensive copy of the
    // mutable map:
    //
    // Feel free to use your favourite immutable data-structures library with Akka in Java
    // applications!
    Map&lt;ActorRef, String&gt; actorToDeviceIdCopy = new HashMap&lt;&gt;(this.actorToDeviceId);

    getContext()
        .actorOf(
            DeviceGroupQuery.props(
                actorToDeviceIdCopy,
                r.requestId,
                getSender(),
                new FiniteDuration(3, TimeUnit.SECONDS)));
  }

  @Override
  public Receive createReceive() {
        // ... other cases omitted
        .match(RequestAllTemperatures.class, this::onAllTemperatures)
        .build();
  }
}</code></pre></dd>
</dl>
<p>It is probably worth restating what we said at the beginning of the chapter. By keeping the temporary state that is only relevant to the query itself in a separate actor we keep the group actor implementation very simple. It delegates everything to child actors and therefore does not have to keep state that is not relevant to its core business. Also, multiple queries can now run parallel to each other, in fact, as many as needed. In our case querying an individual device actor is a fast operation, but if this were not the case, for example, because the remote sensors need to be contacted over the network, this design would significantly improve throughput.</p>
<p>We close this chapter by testing that everything works together. This test is a variant of the previous ones, now exercising the group query feature:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_5/DeviceGroupSpec.scala#L100-L131" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to collect temperatures from all active devices&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor1 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor2 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device3&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor3 = probe.lastSender

  // Check that the device actors are working
  deviceActor1.tell(Device.RecordTemperature(requestId = 0, 1.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 0))
  deviceActor2.tell(Device.RecordTemperature(requestId = 1, 2.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 1))
  // No temperature for device3

  groupActor.tell(DeviceGroup.RequestAllTemperatures(requestId = 0), probe.ref)
  probe.expectMsg(
    DeviceGroup.RespondAllTemperatures(
      requestId = 0,
      temperatures = Map(
        &quot;device1&quot; -&gt; DeviceGroup.Temperature(1.0),
        &quot;device2&quot; -&gt; DeviceGroup.Temperature(2.0),
        &quot;device3&quot; -&gt; DeviceGroup.TemperatureNotAvailable)))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_5/DeviceGroupTest.java#L136-L171" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testCollectTemperaturesFromAllActiveDevices() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor1 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor2 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device3&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor3 = probe.getLastSender();

  // Check that the device actors are working
  deviceActor1.tell(new Device.RecordTemperature(0L, 1.0), probe.getRef());
  assertEquals(0L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
  deviceActor2.tell(new Device.RecordTemperature(1L, 2.0), probe.getRef());
  assertEquals(1L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
  // No temperature for device 3

  groupActor.tell(new DeviceGroup.RequestAllTemperatures(0L), probe.getRef());
  DeviceGroup.RespondAllTemperatures response =
      probe.expectMsgClass(DeviceGroup.RespondAllTemperatures.class);
  assertEquals(0L, response.requestId);

  Map&lt;String, DeviceGroup.TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new DeviceGroup.Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new DeviceGroup.Temperature(2.0));
  expectedTemperatures.put(&quot;device3&quot;, DeviceGroup.TemperatureNotAvailable.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<h2><a href="#summary" name="summary" class="anchor"><span class="anchor-link"></span></a>Summary</h2>
<p>In the context of the IoT system, this guide introduced the following concepts, among others. You can follow the links to review them if necessary:</p>
<ul>
  <li><a href="tutorial_1.html">The hierarchy of actors and their lifecycle</a></li>
  <li><a href="tutorial_3.html">The importance of designing messages for flexibility</a></li>
  <li><a href="tutorial_4.html#keeping-track-of-the-device-actors-in-the-group">How to watch and stop actors, if necessary</a></li>
</ul>
<h2><a href="#whats-next-" name="whats-next-" class="anchor"><span class="anchor-link"></span></a>What&rsquo;s Next?</h2>
<p>To continue your journey with Akka, we recommend:</p>
<ul>
  <li>Start building your own applications with Akka, make sure you <a href="http://akka.io/get-involved">get involved in our amazing community</a> for help if you get stuck.</li>
  <li>If you’d like some additional background, read the rest of the reference documentation and check out some of the <a href="../additional/books.html">books and videos</a> on Akka.</li>
</ul>
<p>To get from this guide to a complete application you would likely need to provide either an UI or an API. For this we recommend that you look at the following technologies and see what fits you:</p>
<ul>
  <li><a href="https://doc.akka.io/docs/akka-http/current/introduction.html">Akka HTTP</a> is a HTTP server and client library, making it possible to publish and consume HTTP endpoints</li>
  <li><a href="https://www.playframework.com">Play Framework</a> is a full fledged web framework that is built on top of Akka HTTP, it integrates well with Akka and can be used to create a complete modern web UI</li>
  <li><a href="https://www.lagomframework.com">Lagom</a> is an opinionated microservice framework built on top of Akka, encoding many best practices around Akka and Play</li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../guide/tutorial_4.html"><i class="icon-prev"></i> <span class="link-prev">Part 4: Working with Device Groups</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../general/index.html">General Concepts <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/guide/tutorial_5.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
