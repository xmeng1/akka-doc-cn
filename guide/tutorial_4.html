<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 4: Working with Device Groups &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/guide/tutorial_4.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
    <li><a href="../guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../guide/tutorial_4.html#part-4-working-with-device-groups" class="active page">Part 4: Working with Device Groups</a>
    <ul>
      <li><a href="../guide/tutorial_4.html#dependency" class="header">Dependency</a></li>
      <li><a href="../guide/tutorial_4.html#introduction" class="header">Introduction</a></li>
      <li><a href="../guide/tutorial_4.html#device-manager-hierarchy" class="header">Device manager hierarchy</a></li>
      <li><a href="../guide/tutorial_4.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
      <li><a href="../guide/tutorial_4.html#adding-registration-support-to-device-actors" class="header">Adding registration support to device actors</a></li>
      <li><a href="../guide/tutorial_4.html#adding-registration-support-to-device-group-actors" class="header">Adding registration support to device group actors</a></li>
      <li><a href="../guide/tutorial_4.html#creating-device-manager-actors" class="header">Creating device manager actors</a></li>
      <li><a href="../guide/tutorial_4.html#whats-next-" class="header">What&rsquo;s next?</a></li>
    </ul></li>
    <li><a href="../guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a>
  <ul>
    <li><a href="../guide/introduction.html" class="page">Introduction to Akka</a></li>
    <li><a href="../guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
    <li><a href="../guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
    <li><a href="../guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
    <li><a href="../guide/tutorial.html" class="page">Introduction to the Example</a></li>
    <li><a href="../guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
    <li><a href="../guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
    <li><a href="../guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
    <li><a href="../guide/tutorial_4.html#part-4-working-with-device-groups" class="active page">Part 4: Working with Device Groups</a>
    <ul>
      <li><a href="../guide/tutorial_4.html#dependency" class="header">Dependency</a></li>
      <li><a href="../guide/tutorial_4.html#introduction" class="header">Introduction</a></li>
      <li><a href="../guide/tutorial_4.html#device-manager-hierarchy" class="header">Device manager hierarchy</a></li>
      <li><a href="../guide/tutorial_4.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
      <li><a href="../guide/tutorial_4.html#adding-registration-support-to-device-actors" class="header">Adding registration support to device actors</a></li>
      <li><a href="../guide/tutorial_4.html#adding-registration-support-to-device-group-actors" class="header">Adding registration support to device group actors</a></li>
      <li><a href="../guide/tutorial_4.html#creating-device-manager-actors" class="header">Creating device manager actors</a></li>
      <li><a href="../guide/tutorial_4.html#whats-next-" class="header">What&rsquo;s next?</a></li>
    </ul></li>
    <li><a href="../guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
  </ul></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-4-working-with-device-groups" name="part-4-working-with-device-groups" class="anchor"><span class="anchor-link"></span></a>Part 4: Working with Device Groups</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>Add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Let&rsquo;s take a closer look at the main functionality required by our use case. In a complete IoT system for monitoring home temperatures, the steps for connecting a device sensor to our system might look like this:</p>
<ol>
  <li>A sensor device in the home connects through some protocol.</li>
  <li>The component managing network connections accepts the connection.</li>
  <li>The sensor provides its group and device ID to register with the device manager component of our system.</li>
  <li>The device manager component handles registration by looking up or creating the actor responsible for keeping sensor state.</li>
  <li>The actor responds with an acknowledgement, exposing its <code>ActorRef</code>.</li>
  <li>The networking component now uses the <code>ActorRef</code> for communication between the sensor and device actor without going through the device manager.</li>
</ol>
<p>Steps 1 and 2 take place outside the boundaries of our tutorial system. In this chapter, we will start addressing steps 3-6 and create a way for sensors to register with our system and to communicate with actors. But first, we have another architectural decision &#8212; how many levels of actors should we use to represent device groups and device sensors?</p>
<p>One of the main design challenges for Akka programmers is choosing the best granularity for actors. In practice, depending on the characteristics of the interactions between actors, there are usually several valid ways to organize a system. In our use case, for example, it would be possible to have a single actor maintain all the groups and devices &#8212; perhaps using hash maps. It would also be reasonable to have an actor for each group that tracks the state of all devices in the same home.</p>
<p>The following guidelines help us choose the most appropriate actor hierarchy:</p>
<ul>
  <li>In general, prefer larger granularity. Introducing more fine-grained actors than needed causes more problems than it solves.</li>
  <li>Add finer granularity when the system requires:
    <ul>
      <li>Higher concurrency.</li>
      <li>Complex conversations between actors that have many states. We will see a very good example for this in the next chapter.</li>
      <li>Sufficient state that it makes sense to divide into smaller actors.</li>
      <li>Multiple unrelated responsibilities. Using separate actors allows individuals to fail and be restored with little impact on others.</li>
    </ul>
  </li>
</ul>
<h2><a href="#device-manager-hierarchy" name="device-manager-hierarchy" class="anchor"><span class="anchor-link"></span></a>Device manager hierarchy</h2>
<p>Considering the principles outlined in the previous section, We will model the device manager component as an actor tree with three levels:</p>
<ul>
  <li>The top level supervisor actor represents the system component for devices. It is also the entry point to look up and create device group and device actors.</li>
  <li>At the next level, group actors each supervise the device actors for one group id (e.g. one home). They also provide services, such as querying temperature readings from all of the available devices in their group.</li>
  <li>Device actors manage all the interactions with the actual device sensors, such as storing temperature readings.</li>
</ul>
<p><img src="diagrams/device_manager_tree.png" alt="device manager tree" /></p>
<p>We chose this three-layered architecture for these reasons:</p>
<ul>
  <li>
    <p>Having groups of individual actors:</p>
    <ul>
      <li>Isolates failures that occur in a group. If a single actor managed all device groups, an error in one group that causes a restart would wipe out the state of groups that are otherwise non-faulty.</li>
      <li>Simplifies the problem of querying all the devices belonging to a group. Each group actor only contains state related to its group.</li>
      <li>Increases parallelism in the system. Since each group has a dedicated actor, they run concurrently and we can query multiple groups concurrently.</li>
    </ul>
  </li>
  <li>
    <p>Having sensors modeled as individual device actors:</p>
    <ul>
      <li>Isolates failures of one device actor from the rest of the devices in the group.</li>
      <li>Increases the parallelism of collecting temperature readings. Network connections from different sensors communicate with their individual device actors directly, reducing contention points.</li>
    </ul>
  </li>
</ul>
<p>With the architecture defined, we can start working on the protocol for registering sensors.</p>
<h2><a href="#the-registration-protocol" name="the-registration-protocol" class="anchor"><span class="anchor-link"></span></a>The Registration Protocol</h2>
<p>As the first step, we need to design the protocol both for registering a device and for creating the group and device actors that will be responsible for it. This protocol will be provided by the <code>DeviceManager</code> component itself because that is the only actor that is known and available up front: device groups and device actors are created on-demand.</p>
<p>Looking at registration in more detail, we can outline the necessary functionality:</p>
<ol>
  <li>When a <code>DeviceManager</code> receives a request with a group and device id:
    <ul>
      <li>If the manager already has an actor for the device group, it forwards the request to it.</li>
      <li>Otherwise, it creates a new device group actor and then forwards the request.</li>
    </ul>
  </li>
  <li>The <code>DeviceGroup</code> actor receives the request to register an actor for the given device:
    <ul>
      <li>If the group already has an actor for the device, the group actor forwards the request to the device actor.</li>
      <li>Otherwise, the <code>DeviceGroup</code> actor first creates a device actor and then forwards the request.</li>
    </ul>
  </li>
  <li>The device actor receives the request and sends an acknowledgement to the original sender. Since the device actor acknowledges receipt (instead of the group actor), the sensor will now have the <code>ActorRef</code> to send messages directly to its actor.</li>
</ol>
<p>The messages that we will use to communicate registration requests and their acknowledgement have a simple definition:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceManager.scala#L15-L16" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class RequestTrackDevice(groupId: String, deviceId: String)
case object DeviceRegistered</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceManager.java#L26-L37" target="_blank" title="Go to snippet source"></a><code class="language-java">public static final class RequestTrackDevice {
  public final String groupId;
  public final String deviceId;

  public RequestTrackDevice(String groupId, String deviceId) {
    this.groupId = groupId;
    this.deviceId = deviceId;
  }
}

public static final class DeviceRegistered {}
</code></pre></dd>
</dl>
<p>In this case we have not included a request ID field in the messages. Since registration happens once, when the component connects the system to some network protocol, the ID is not important. However, it is usually a best practice to include a request ID.</p>
<p>Now, we&rsquo;ll start implementing the protocol from the bottom up. In practice, both a top-down and bottom-up approach can work, but in our case, we benefit from the bottom-up approach as it allows us to immediately write tests for the new features without mocking out parts that we will need to build later.</p>
<h2><a href="#adding-registration-support-to-device-actors" name="adding-registration-support-to-device-actors" class="anchor"><span class="anchor-link"></span></a>Adding registration support to device actors</h2>
<p>At the bottom of our hierarchy are the <code>Device</code> actors. Their job in the registration process is simple: reply to the registration request with an acknowledgment to the sender. It is also prudent to add a safeguard against requests that come with a mismatched group or device ID.</p>
<p><em>We will assume that the ID of the sender of the registration message is preserved in the upper layers.</em> We will show you in the next section how this can be achieved.</p>
<p>The device actor registration code looks like the following. Modify your example to match.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/Device.scala#L10-L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">object Device {
  def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))

  final case class RecordTemperature(requestId: Long, value: Double)
  final case class TemperatureRecorded(requestId: Long)

  final case class ReadTemperature(requestId: Long)
  final case class RespondTemperature(requestId: Long, value: Option[Double])
}

class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
  import Device._

  var lastTemperatureReading: Option[Double] = None

  override def preStart(): Unit = log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId)

  override def postStop(): Unit = log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId)

  override def receive: Receive = {
    case DeviceManager.RequestTrackDevice(`groupId`, `deviceId`) ⇒
      sender() ! DeviceManager.DeviceRegistered

    case DeviceManager.RequestTrackDevice(groupId, deviceId) ⇒
      log.warning(
        &quot;Ignoring TrackDevice request for {}-{}.This actor is responsible for {}-{}.&quot;,
        groupId, deviceId, this.groupId, this.deviceId
      )

    case RecordTemperature(id, value) ⇒
      log.info(&quot;Recorded temperature reading {} with {}&quot;, value, id)
      lastTemperatureReading = Some(value)
      sender() ! TemperatureRecorded(id)

    case ReadTemperature(id) ⇒
      sender() ! RespondTemperature(id, lastTemperatureReading)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/Device.java#L8-L115" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>import akka.actor.AbstractActor;
import akka.actor.Props;
import akka.event.Logging;
import akka.event.LoggingAdapter;

import jdocs.tutorial_4.DeviceManager.DeviceRegistered;
import jdocs.tutorial_4.DeviceManager.RequestTrackDevice;

import java.util.Optional;

public class Device extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  final String deviceId;

  public Device(String groupId, String deviceId) {
    this.groupId = groupId;
    this.deviceId = deviceId;
  }

  public static Props props(String groupId, String deviceId) {
    return Props.create(Device.class, () -&gt; new Device(groupId, deviceId));
  }

  public static final class RecordTemperature {
    final long requestId;
    final double value;

    public RecordTemperature(long requestId, double value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  public static final class TemperatureRecorded {
    final long requestId;

    public TemperatureRecorded(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReadTemperature {
    final long requestId;

    public ReadTemperature(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class RespondTemperature {
    final long requestId;
    final Optional&lt;Double&gt; value;

    public RespondTemperature(long requestId, Optional&lt;Double&gt; value) {
      this.requestId = requestId;
      this.value = value;
    }
  }

  Optional&lt;Double&gt; lastTemperatureReading = Optional.empty();

  @Override
  public void preStart() {
    log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId);
  }

  @Override
  public void postStop() {
    log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(
            RequestTrackDevice.class,
            r -&gt; {
              if (this.groupId.equals(r.groupId) &amp;&amp; this.deviceId.equals(r.deviceId)) {
                getSender().tell(new DeviceRegistered(), getSelf());
              } else {
                log.warning(
                    &quot;Ignoring TrackDevice request for {}-{}.This actor is responsible for {}-{}.&quot;,
                    r.groupId,
                    r.deviceId,
                    this.groupId,
                    this.deviceId);
              }
            })
        .match(
            RecordTemperature.class,
            r -&gt; {
              log.info(&quot;Recorded temperature reading {} with {}&quot;, r.value, r.requestId);
              lastTemperatureReading = Optional.of(r.value);
              getSender().tell(new TemperatureRecorded(r.requestId), getSelf());
            })
        .match(
            ReadTemperature.class,
            r -&gt; {
              getSender()
                  .tell(new RespondTemperature(r.requestId, lastTemperatureReading), getSelf());
            })
        .build();
  }
}</code></pre></dd>
</dl><div class="callout note group-scala"><div class="callout-title">Note</div>
<p>We used a feature of scala pattern matching where we can check to see if a certain field equals an expected value. By bracketing variables with backticks, like <code>`variable`</code>, the pattern will only match if it contains the value of <code>variable</code> in that position.</p></div>
<p>We can now write two new test cases, one exercising successful registration, the other testing the case when IDs don&rsquo;t match:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceSpec.scala#L16-L34" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;reply to registration requests&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  probe.lastSender should ===(deviceActor)
}

&quot;ignore wrong registration requests&quot; in {
  val probe = TestProbe()
  val deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;))

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device&quot;), probe.ref)
  probe.expectNoMessage(500.milliseconds)

  deviceActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;Wrongdevice&quot;), probe.ref)
  probe.expectNoMessage(500.milliseconds)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceTest.java#L36-L56" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReplyToRegistrationRequests() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  assertEquals(deviceActor, probe.getLastSender());
}

@Test
public void testIgnoreWrongRegistrationRequests() {
  TestKit probe = new TestKit(system);
  ActorRef deviceActor = system.actorOf(Device.props(&quot;group&quot;, &quot;device&quot;));

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device&quot;), probe.getRef());
  probe.expectNoMessage();

  deviceActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;wrongDevice&quot;), probe.getRef());
  probe.expectNoMessage();
}</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p>We used the <code>expectNoMsg()</code> helper method from <span class="group-scala"><code>TestProbe</code></span><span class="group-java"><code>TestKit</code></span>. This assertion waits until the defined time-limit and fails if it receives any messages during this period. If no messages are received during the waiting period, the assertion passes. It is usually a good idea to keep these timeouts low (but not too low) because they add significant test execution time.</p></div>
<h2><a href="#adding-registration-support-to-device-group-actors" name="adding-registration-support-to-device-group-actors" class="anchor"><span class="anchor-link"></span></a>Adding registration support to device group actors</h2>
<p>We are done with registration support at the device level, now we have to implement it at the group level. A group actor has more work to do when it comes to registrations, including:</p>
<ul>
  <li>Handling the registration request by either forwarding it to an existing device actor or by creating a new actor and forwarding the message.</li>
  <li>Tracking which device actors exist in the group and removing them from the group when they are stopped.</li>
</ul>
<h3><a href="#handling-the-registration-request" name="handling-the-registration-request" class="anchor"><span class="anchor-link"></span></a>Handling the registration request</h3>
<p>A device group actor must either forward the request to an existing child, or it should create one. To look up child actors by their device IDs we will use a <span class="group-scala"><code>Map[String, ActorRef]</code></span><span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span>.</p>
<p>We also want to keep the ID of the original sender of the request so that our device actor can reply directly. This is possible by using <code>forward</code> instead of the <span class="group-scala"><code>!</code></span> <span class="group-java"><code>tell</code></span> operator. The only difference between the two is that <code>forward</code> keeps the original sender while <span class="group-scala"><code>!</code></span> <span class="group-java"><code>tell</code></span> sets the sender to be the current actor. Just like with our device actor, we ensure that we don&rsquo;t respond to wrong group IDs. Add the following to your source file:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroup.scala#L15-L73" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroup {
  def props(groupId: String): Props = Props(new DeviceGroup(groupId))
}

class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) ⇒
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) ⇒
          deviceActor forward trackMsg
        case None ⇒
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) ⇒
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroup.java#L24-L127" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  public DeviceGroup(String groupId) {
    this.groupId = groupId;
  }

  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, () -&gt; new DeviceGroup(groupId));
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            getContext()
                .actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          groupId,
          this.groupId);
    }
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
        .build();
  }
}</code></pre></dd>
</dl>
<p>Just as we did with the device, we test this new functionality. We also test that the actors returned for the two different IDs are actually different, and we also attempt to record a temperature reading for each of the devices to see if the actors are responding.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroupSpec.scala#L17-L43" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to register a device actor&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor1 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor2 = probe.lastSender
  deviceActor1 should !==(deviceActor2)

  // Check that the device actors are working
  deviceActor1.tell(Device.RecordTemperature(requestId = 0, 1.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 0))
  deviceActor2.tell(Device.RecordTemperature(requestId = 1, 2.0), probe.ref)
  probe.expectMsg(Device.TemperatureRecorded(requestId = 1))
}

&quot;ignore requests for wrong groupId&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;), probe.ref)
  probe.expectNoMsg(500.milliseconds)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroupTest.java#L39-L67" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testRegisterDeviceActor() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor1 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor2 = probe.getLastSender();
  assertNotEquals(deviceActor1, deviceActor2);

  // Check that the device actors are working
  deviceActor1.tell(new Device.RecordTemperature(0L, 1.0), probe.getRef());
  assertEquals(0L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
  deviceActor2.tell(new Device.RecordTemperature(1L, 2.0), probe.getRef());
  assertEquals(1L, probe.expectMsgClass(Device.TemperatureRecorded.class).requestId);
}

@Test
public void testIgnoreRequestsForWrongGroupId() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectNoMessage();
}</code></pre></dd>
</dl>
<p>If a device actor already exists for the registration request, we would like to use the existing actor instead of a new one. We have not tested this yet, so we need to fix this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroupSpec.scala#L47-L60" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return same actor for same deviceId&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor1 = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val deviceActor2 = probe.lastSender

  deviceActor1 should ===(deviceActor2)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroupTest.java#L71-L84" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnSameActorForSameDeviceId() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor1 = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef deviceActor2 = probe.getLastSender();
  assertEquals(deviceActor1, deviceActor2);
}</code></pre></dd>
</dl>
<h3><a href="#keeping-track-of-the-device-actors-in-the-group" name="keeping-track-of-the-device-actors-in-the-group" class="anchor"><span class="anchor-link"></span></a>Keeping track of the device actors in the group</h3>
<p>So far, we have implemented logic for registering device actors in the group. Devices come and go, however, so we will need a way to remove device actors from the <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span>. We will assume that when a device is removed, its corresponding device actor is stopped. Supervision, as we discussed earlier, only handles error scenarios &#8212; not graceful stopping. So we need to notify the parent when one of the device actors is stopped.</p>
<p>Akka provides a <em>Death Watch</em> feature that allows an actor to <em>watch</em> another actor and be notified if the other actor is stopped. Unlike supervision, watching is not limited to parent-child relationships, any actor can watch any other actor as long as it knows the <code>ActorRef</code>. After a watched actor stops, the watcher receives a <code>Terminated(actorRef)</code> message which also contains the reference to the watched actor. The watcher can either handle this message explicitly or will fail with a <code>DeathPactException</code>. This latter is useful if the actor can no longer perform its own duties after the watched actor has been stopped. In our case, the group should still function after one device have been stopped, so we need to handle the <code>Terminated(actorRef)</code> message.</p>
<p>Our device group actor needs to include functionality that:</p>
<ol>
  <li>Starts watching new device actors when they are created.</li>
  <li>Removes a device actor from the <span class="group-scala"><code>Map[String, ActorRef]</code></span> <span class="group-java"><code>Map&lt;String, ActorRef&gt;</code></span> &#8212; which maps devices to device actors &#8212; when the notification indicates it has stopped.</li>
</ol>
<p>Unfortunately, the <code>Terminated</code> message only contains the <code>ActorRef</code> of the child actor. We need the actor&rsquo;s ID to remove it from the map of existing device to device actor mappings. To be able to do this removal, we need to introduce another placeholder, <span class="group-scala"><code>Map[ActorRef, String]</code></span> <span class="group-java"><code>Map&lt;ActorRef, String&gt;</code></span>, that allow us to find out the device ID corresponding to a given <code>ActorRef</code>.</p>
<p>Adding the functionality to identify the actor results in this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroup.scala#L26-L73" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]
  var actorToDeviceId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) ⇒
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) ⇒
          deviceActor forward trackMsg
        case None ⇒
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          context.watch(deviceActor)
          actorToDeviceId += deviceActor -&gt; trackMsg.deviceId
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) ⇒
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )

    case Terminated(deviceActor) ⇒
      val deviceId = actorToDeviceId(deviceActor)
      log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
      actorToDeviceId -= deviceActor
      deviceIdToActor -= deviceId

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroup.java#L24-L127" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  public DeviceGroup(String groupId) {
    this.groupId = groupId;
  }

  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, () -&gt; new DeviceGroup(groupId));
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            getContext()
                .actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        getContext().watch(deviceActor);
        actorToDeviceId.put(deviceActor, trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          groupId,
          this.groupId);
    }
  }

  private void onTerminated(Terminated t) {
    ActorRef deviceActor = t.getActor();
    String deviceId = actorToDeviceId.get(deviceActor);
    log.info(&quot;Device actor for {} has been terminated&quot;, deviceId);
    actorToDeviceId.remove(deviceActor);
    deviceIdToActor.remove(deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
        .match(Terminated.class, this::onTerminated)
        .build();
  }
}</code></pre></dd>
</dl>
<p>So far we have no means to get which devices the group device actor keeps track of and, therefore, we cannot test our new functionality yet. To make it testable, we add a new query capability (message <span class="group-scala"><code>RequestDeviceList(requestId: Long)</code></span> <span class="group-java"><code>RequestDeviceList</code></span>) that lists the currently active device IDs:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroup.scala#L15-L73" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroup {
  def props(groupId: String): Props = Props(new DeviceGroup(groupId))

  final case class RequestDeviceList(requestId: Long)
  final case class ReplyDeviceList(requestId: Long, ids: Set[String])
}

class DeviceGroup(groupId: String) extends Actor with ActorLogging {
  var deviceIdToActor = Map.empty[String, ActorRef]
  var actorToDeviceId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def postStop(): Unit = log.info(&quot;DeviceGroup {} stopped&quot;, groupId)

  override def receive: Receive = {
    case trackMsg @ RequestTrackDevice(`groupId`, _) ⇒
      deviceIdToActor.get(trackMsg.deviceId) match {
        case Some(deviceActor) ⇒
          deviceActor forward trackMsg
        case None ⇒
          log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
          val deviceActor = context.actorOf(Device.props(groupId, trackMsg.deviceId), s&quot;device-${trackMsg.deviceId}&quot;)
          context.watch(deviceActor)
          actorToDeviceId += deviceActor -&gt; trackMsg.deviceId
          deviceIdToActor += trackMsg.deviceId -&gt; deviceActor
          deviceActor forward trackMsg
      }

    case RequestTrackDevice(groupId, deviceId) ⇒
      log.warning(
        &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
        groupId, this.groupId
      )

    case RequestDeviceList(requestId) ⇒
      sender() ! ReplyDeviceList(requestId, deviceIdToActor.keySet)

    case Terminated(deviceActor) ⇒
      val deviceId = actorToDeviceId(deviceActor)
      log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
      actorToDeviceId -= deviceActor
      deviceIdToActor -= deviceId

  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroup.java#L24-L127" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  final String groupId;

  public DeviceGroup(String groupId) {
    this.groupId = groupId;
  }

  public static Props props(String groupId) {
    return Props.create(DeviceGroup.class, () -&gt; new DeviceGroup(groupId));
  }

  public static final class RequestDeviceList {
    final long requestId;

    public RequestDeviceList(long requestId) {
      this.requestId = requestId;
    }
  }

  public static final class ReplyDeviceList {
    final long requestId;
    final Set&lt;String&gt; ids;

    public ReplyDeviceList(long requestId, Set&lt;String&gt; ids) {
      this.requestId = requestId;
      this.ids = ids;
    }
  }

  final Map&lt;String, ActorRef&gt; deviceIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToDeviceId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceGroup {} stopped&quot;, groupId);
  }

  private void onTrackDevice(DeviceManager.RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        deviceActor.forward(trackMsg, getContext());
      } else {
        log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            getContext()
                .actorOf(Device.props(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        getContext().watch(deviceActor);
        actorToDeviceId.put(deviceActor, trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        deviceActor.forward(trackMsg, getContext());
      }
    } else {
      log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          groupId,
          this.groupId);
    }
  }

  private void onDeviceList(RequestDeviceList r) {
    getSender().tell(new ReplyDeviceList(r.requestId, deviceIdToActor.keySet()), getSelf());
  }

  private void onTerminated(Terminated t) {
    ActorRef deviceActor = t.getActor();
    String deviceId = actorToDeviceId.get(deviceActor);
    log.info(&quot;Device actor for {} has been terminated&quot;, deviceId);
    actorToDeviceId.remove(deviceActor);
    deviceIdToActor.remove(deviceId);
  }

  @Override
  public Receive createReceive() {
    return receiveBuilder()
        .match(DeviceManager.RequestTrackDevice.class, this::onTrackDevice)
        .match(RequestDeviceList.class, this::onDeviceList)
        .match(Terminated.class, this::onTerminated)
        .build();
  }
}</code></pre></dd>
</dl>
<p>We are almost ready to test the removal of devices. But, we still need the following capabilities:</p>
<ul>
  <li>To stop a device actor from our test case. From the outside, any actor can be stopped by sending a special  the built-in message, <code>PoisonPill</code>, which instructs the actor to stop.</li>
  <li>To be notified once the device actor is stopped. We can use the <em>Death Watch</em> facility for this purpose, too. The <span class="group-scala"><code>TestProbe</code></span> <span class="group-java"><code>TestKit</code></span> has two messages that we can easily use, <code>watch()</code> to watch a specific actor, and <code>expectTerminated</code>  to assert that the watched actor has been terminated.</li>
</ul>
<p>We add two more test cases now. In the first, we test that we get back the list of proper IDs once we have added a few devices. The second test case makes sure that the device ID is properly removed after the device actor has been stopped:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceGroupSpec.scala#L64-L102" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to list active devices&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 0), probe.ref)
  probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))
}

&quot;be able to list active devices after one shuts down&quot; in {
  val probe = TestProbe()
  val groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;))

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)
  val toShutDown = probe.lastSender

  groupActor.tell(DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.ref)
  probe.expectMsg(DeviceManager.DeviceRegistered)

  groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 0), probe.ref)
  probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))

  probe.watch(toShutDown)
  toShutDown ! PoisonPill
  probe.expectTerminated(toShutDown)

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  probe.awaitAssert {
    groupActor.tell(DeviceGroup.RequestDeviceList(requestId = 1), probe.ref)
    probe.expectMsg(DeviceGroup.ReplyDeviceList(requestId = 1, Set(&quot;device2&quot;)))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceGroupTest.java#L88-L136" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testListActiveDevices() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceGroup.RequestDeviceList(0L), probe.getRef());
  DeviceGroup.ReplyDeviceList reply = probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);
}

@Test
public void testListActiveDevicesAfterOneShutsDown() {
  TestKit probe = new TestKit(system);
  ActorRef groupActor = system.actorOf(DeviceGroup.props(&quot;group&quot;));

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);
  ActorRef toShutDown = probe.getLastSender();

  groupActor.tell(new DeviceManager.RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;), probe.getRef());
  probe.expectMsgClass(DeviceManager.DeviceRegistered.class);

  groupActor.tell(new DeviceGroup.RequestDeviceList(0L), probe.getRef());
  DeviceGroup.ReplyDeviceList reply = probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);

  probe.watch(toShutDown);
  toShutDown.tell(PoisonPill.getInstance(), ActorRef.noSender());
  probe.expectTerminated(toShutDown);

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  probe.awaitAssert(
      () -&gt; {
        groupActor.tell(new DeviceGroup.RequestDeviceList(1L), probe.getRef());
        DeviceGroup.ReplyDeviceList r = probe.expectMsgClass(DeviceGroup.ReplyDeviceList.class);
        assertEquals(1L, r.requestId);
        assertEquals(Stream.of(&quot;device2&quot;).collect(Collectors.toSet()), r.ids);
        return null;
      });
}</code></pre></dd>
</dl>
<h2><a href="#creating-device-manager-actors" name="creating-device-manager-actors" class="anchor"><span class="anchor-link"></span></a>Creating device manager actors</h2>
<p>Going up to the next level in our hierarchy, we need to create the entry point for our device manager component in the <code>DeviceManager</code> source file. This actor is very similar to the device group actor, but creates device group actors instead of device actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/tutorial_4/DeviceManager.scala#L11-L50" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceManager {
  def props(): Props = Props(new DeviceManager)

  final case class RequestTrackDevice(groupId: String, deviceId: String)
  case object DeviceRegistered
}

class DeviceManager extends Actor with ActorLogging {
  var groupIdToActor = Map.empty[String, ActorRef]
  var actorToGroupId = Map.empty[ActorRef, String]

  override def preStart(): Unit = log.info(&quot;DeviceManager started&quot;)

  override def postStop(): Unit = log.info(&quot;DeviceManager stopped&quot;)

  override def receive = {
    case trackMsg @ RequestTrackDevice(groupId, _) ⇒
      groupIdToActor.get(groupId) match {
        case Some(ref) ⇒
          ref forward trackMsg
        case None ⇒
          log.info(&quot;Creating device group actor for {}&quot;, groupId)
          val groupActor = context.actorOf(DeviceGroup.props(groupId), &quot;group-&quot; + groupId)
          context.watch(groupActor)
          groupActor forward trackMsg
          groupIdToActor += groupId -&gt; groupActor
          actorToGroupId += groupActor -&gt; groupId
      }

    case Terminated(groupActor) ⇒
      val groupId = actorToGroupId(groupActor)
      log.info(&quot;Device group actor for {} has been terminated&quot;, groupId)
      actorToGroupId -= groupActor
      groupIdToActor -= groupId

  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/tutorial_4/DeviceManager.java#L18-L81" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceManager extends AbstractActor {
  private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this);

  public static Props props() {
    return Props.create(DeviceManager.class, DeviceManager::new);
  }

  public static final class RequestTrackDevice {
    public final String groupId;
    public final String deviceId;

    public RequestTrackDevice(String groupId, String deviceId) {
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  public static final class DeviceRegistered {}

  final Map&lt;String, ActorRef&gt; groupIdToActor = new HashMap&lt;&gt;();
  final Map&lt;ActorRef, String&gt; actorToGroupId = new HashMap&lt;&gt;();

  @Override
  public void preStart() {
    log.info(&quot;DeviceManager started&quot;);
  }

  @Override
  public void postStop() {
    log.info(&quot;DeviceManager stopped&quot;);
  }

  private void onTrackDevice(RequestTrackDevice trackMsg) {
    String groupId = trackMsg.groupId;
    ActorRef ref = groupIdToActor.get(groupId);
    if (ref != null) {
      ref.forward(trackMsg, getContext());
    } else {
      log.info(&quot;Creating device group actor for {}&quot;, groupId);
      ActorRef groupActor = getContext().actorOf(DeviceGroup.props(groupId), &quot;group-&quot; + groupId);
      getContext().watch(groupActor);
      groupActor.forward(trackMsg, getContext());
      groupIdToActor.put(groupId, groupActor);
      actorToGroupId.put(groupActor, groupId);
    }
  }

  private void onTerminated(Terminated t) {
    ActorRef groupActor = t.getActor();
    String groupId = actorToGroupId.get(groupActor);
    log.info(&quot;Device group actor for {} has been terminated&quot;, groupId);
    actorToGroupId.remove(groupActor);
    groupIdToActor.remove(groupId);
  }

  public Receive createReceive() {
    return receiveBuilder()
        .match(RequestTrackDevice.class, this::onTrackDevice)
        .match(Terminated.class, this::onTerminated)
        .build();
  }
}</code></pre></dd>
</dl>
<p>We leave tests of the device manager as an exercise for you since it is very similar to the tests we have already written for the group actor.</p>
<h2><a href="#whats-next-" name="whats-next-" class="anchor"><span class="anchor-link"></span></a>What&rsquo;s next?</h2>
<p>We have now a hierarchical component for registering and tracking devices and recording measurements. We have seen how to implement different types of conversation patterns, such as:</p>
<ul>
  <li>Request-respond (for temperature recordings)</li>
  <li>Delegate-respond (for registration of devices)</li>
  <li>Create-watch-terminate (for creating the group and device actor as children)</li>
</ul>
<p>In the next chapter, we will introduce group query capabilities, which will establish a new conversation pattern of scatter-gather. In particular, we will implement the functionality that allows users to query the status of all the devices belonging to a group.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../guide/tutorial_3.html"><i class="icon-prev"></i> <span class="link-prev">Part 3: Working with Device Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../guide/tutorial_5.html">Part 5: Querying Device Groups <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/guide/tutorial_4.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
