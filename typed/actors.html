<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Actors &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/typed/actors.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../typed/actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="../typed/actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="../typed/actors.html#relation-to-akka-untyped-actors" class="header">Relation to Akka (untyped) Actors</a></li>
      <li><a href="../typed/actors.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
    </ul></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../typed/actors.html#actors" class="active page">Actors</a>
    <ul>
      <li><a href="../typed/actors.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/actors.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/actors.html#a-more-complex-example" class="header">A More Complex Example</a></li>
      <li><a href="../typed/actors.html#relation-to-akka-untyped-actors" class="header">Relation to Akka (untyped) Actors</a></li>
      <li><a href="../typed/actors.html#a-little-bit-of-theory" class="header">A Little Bit of Theory</a></li>
    </ul></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#actors" name="actors" class="anchor"><span class="anchor-link"></span></a>Actors</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Actor Typed, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor-typed" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor-typed_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../common/may-change.html">may change</a> in the sense  of being the subject of final development. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet.</p></div>
<p>As discussed in <a href="../general/actor-systems.html">Actor Systems</a> Actors are about sending messages between independent units of computation, but how does that look like?</p>
<p>In all of the following these imports are assumed:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L9-L11" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.NotUsed
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, DispatcherSelector, Terminated }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L8-L16" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.Behavior;
import akka.actor.typed.Terminated;
import akka.actor.typed.Props;
import akka.actor.typed.DispatcherSelector;
import akka.actor.typed.javadsl.Behaviors;
</code></pre></dd>
</dl>
<p>With these in place we can define our first Actor, and it will say hello!</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L26-L40" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  val greeter: Behavior[Greet] = Behaviors.receive { (context, message) ⇒
    context.log.info(&quot;Hello {}!&quot;, message.whom)
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L27-L59" target="_blank" title="Go to snippet source"></a><code class="language-java">public abstract static class HelloWorld {
  // no instances of this class, it&#39;s only a name space for messages
  // and static methods
  private HelloWorld() {}

  public static final class Greet {
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;
    public final ActorRef&lt;Greet&gt; from;

    public Greeted(String whom, ActorRef&lt;Greet&gt; from) {
      this.whom = whom;
      this.from = from;
    }
  }

  public static final Behavior&lt;Greet&gt; greeter =
      Behaviors.receive(
          (context, message) -&gt; {
            context.getLog().info(&quot;Hello {}!&quot;, message.whom);
            message.replyTo.tell(new Greeted(message.whom, context.getSelf()));
            return Behaviors.same();
          });
}</code></pre></dd>
</dl>
<p>This small piece of code defines two message types, one for commanding the Actor to greet someone and one that the Actor will use to confirm that it has done so. The <code>Greet</code> type contains not only the information of whom to greet, it also holds an <code>ActorRef</code> that the sender of the message supplies so that the <code>HelloWorld</code> Actor can send back the confirmation message.</p>
<p>The behavior of the Actor is defined as the <code>greeter</code> value with the help of the <code>receive</code> behavior factory. Processing the next message then results in a new behavior that can potentially be different from this one. State is updated by returning a new behavior that holds the new immutable state. In this case we don&rsquo;t need to update any state, so we return <code>same</code>, which means the next behavior is &ldquo;the same as the current one&rdquo;.</p>
<p>The type of the messages handled by this behavior is declared to be of class <code>Greet</code>, meaning that <code>message</code> argument is also typed as such. This is why we can access the <code>whom</code> and <code>replyTo</code> members without needing to use a pattern match.</p>
<p>On the last line we see the <code>HelloWorld</code> Actor send a message to another Actor, which is done using the <span class="group-scala"><code>!</code> operator (pronounced “bang” or “tell”).</span><span class="group-java"><code>tell</code> method.</span> Since the <code>replyTo</code> address is declared to be of type <span class="group-scala"><code>ActorRef[Greeted]</code></span><span class="group-java"><code>ActorRef&lt;Greeted&gt;</code></span>, the compiler will only permit us to send messages of this type, other usage will not be accepted.</p>
<p>The accepted message types of an Actor together with all reply types defines the protocol spoken by this Actor; in this case it is a simple request–reply protocol but Actors can model arbitrarily complex protocols when needed. The protocol is bundled together with the behavior that implements it in a nicely wrapped scope—the <code>HelloWorld</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>As Carl Hewitt said, one Actor is no Actor—it would be quite lonely with nobody to talk to. We need another Actor that interacts with the <code>greeter</code>. Let&rsquo;s make a <code>bot</code> that receives the reply from the <code>greeter</code> and sends a number of additional greeting messages and collect the replies until a given max number of messages have been reached.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L44-L62" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorldBot {

  def bot(greetingCounter: Int, max: Int): Behavior[HelloWorld.Greeted] =
    Behaviors.receive { (context, message) ⇒
      val n = greetingCounter + 1
      context.log.info(&quot;Greeting {} for {}&quot;, n, message.whom)
      if (n == max) {
        Behaviors.stopped
      } else {
        message.from ! HelloWorld.Greet(message.whom, context.self)
        bot(n, max)
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L63-L79" target="_blank" title="Go to snippet source"></a><code class="language-java">public abstract static class HelloWorldBot {
  private HelloWorldBot() {}

  public static final Behavior&lt;HelloWorld.Greeted&gt; bot(int greetingCounter, int max) {
    return Behaviors.receive(
        (context, message) -&gt; {
          int n = greetingCounter + 1;
          context.getLog().info(&quot;Greeting {} for {}&quot;, n, message.whom);
          if (n == max) {
            return Behaviors.stopped();
          } else {
            message.from.tell(new HelloWorld.Greet(message.whom, context.getSelf()));
            return bot(n, max);
          }
        });
  }
}</code></pre></dd>
</dl>
<p>Note how this Actor manages the counter by changing the behavior for each <code>Greeted</code> reply rather than using any variables.</p>
<p>A third actor spawns the <code>greeter</code> and the <code>bot</code> and starts the interaction between those.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L66-L80" target="_blank" title="Go to snippet source"></a><code class="language-scala">object HelloWorldMain {

  final case class Start(name: String)

  val main: Behavior[Start] =
    Behaviors.setup { context ⇒
      val greeter = context.spawn(HelloWorld.greeter, &quot;greeter&quot;)

      Behaviors.receiveMessage { message ⇒
        val replyTo = context.spawn(HelloWorldBot.bot(greetingCounter = 0, max = 3), message.name)
        greeter ! HelloWorld.Greet(message.name, replyTo)
        Behaviors.same
      }
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L83-L108" target="_blank" title="Go to snippet source"></a><code class="language-java">public abstract static class HelloWorldMain {
  private HelloWorldMain() {}

  public static class Start {
    public final String name;

    public Start(String name) {
      this.name = name;
    }
  }

  public static final Behavior&lt;Start&gt; main =
      Behaviors.setup(
          context -&gt; {
            final ActorRef&lt;HelloWorld.Greet&gt; greeter =
                context.spawn(HelloWorld.greeter, &quot;greeter&quot;);

            return Behaviors.receiveMessage(
                message -&gt; {
                  ActorRef&lt;HelloWorld.Greeted&gt; replyTo =
                      context.spawn(HelloWorldBot.bot(0, 3), message.name);
                  greeter.tell(new HelloWorld.Greet(message.name, replyTo));
                  return Behaviors.same();
                });
          });
}</code></pre></dd>
</dl>
<p>Now we want to try out this Actor, so we must start an ActorSystem to host it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L180-L186" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>val system: ActorSystem[HelloWorldMain.Start] =
  ActorSystem(HelloWorldMain.main, &quot;hello&quot;)

system ! HelloWorldMain.Start(&quot;World&quot;)
system ! HelloWorldMain.Start(&quot;Akka&quot;)
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L145-L149" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem&lt;HelloWorldMain.Start&gt; system =
    ActorSystem.create(HelloWorldMain.main, &quot;hello&quot;);

system.tell(new HelloWorldMain.Start(&quot;World&quot;));
system.tell(new HelloWorldMain.Start(&quot;Akka&quot;));</code></pre></dd>
</dl>
<p>We start an Actor system from the defined <code>main</code> behavior and send two <code>Start</code> messages that will kick-off the interaction between two separate <code>bot</code> actors and the single <code>greeter</code> actor.</p>
<p>An application normally consists of a single <code>ActorSystem</code>, running many actors, per JVM. </p>
<p>The console output may look like this:</p>
<pre><code>[INFO] [03/13/2018 15:50:05.814] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-2] [akka://hello/user/World] Greeting 1 for World
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/Akka] Greeting 1 for Akka
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/World] Greeting 2 for World
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello World!
[INFO] [03/13/2018 15:50:05.815] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/Akka] Greeting 2 for Akka
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-5] [akka://hello/user/greeter] Hello Akka!
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-4] [akka://hello/user/World] Greeting 3 for World
[INFO] [03/13/2018 15:50:05.816] [hello-akka.actor.default-dispatcher-6] [akka://hello/user/Akka] Greeting 3 for Akka
</code></pre><div class="group-scala">
<h4><a href="#here-is-another-example-that-you-can-edit-and-run-in-the-browser-" name="here-is-another-example-that-you-can-edit-and-run-in-the-browser-" class="anchor"><span class="anchor-link"></span></a>Here is another example that you can edit and run in the browser:</h4>

        <div data-scalafiddle    data-template=Akka  data-minheight=400px data-layout=v75>
          <pre class="prettyprint"><code class="language-scala">import akka.NotUsed
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, DispatcherSelector, Terminated }

object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  val greeter: Behavior[Greet] = Behaviors.receive { (context, message) ⇒
    println(s"Hello ${message.whom}!")
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}

object HelloWorldBot {

  def bot(greetingCounter: Int, max: Int): Behavior[HelloWorld.Greeted] =
    Behaviors.receive { (context, message) ⇒
      val n = greetingCounter + 1
      println(s"Greeting ${n} for ${message.whom}")
      if (n == max) {
        Behaviors.stopped
      } else {
        message.from ! HelloWorld.Greet(message.whom, context.self)
        bot(n, max)
      }
    }
}

object HelloWorldMain {

  final case class Start(name: String)

  val main: Behavior[Start] =
    Behaviors.setup { context ⇒
      val greeter = context.spawn(HelloWorld.greeter, "greeter")

      Behaviors.receiveMessage { message ⇒
        val replyTo = context.spawn(HelloWorldBot.bot(greetingCounter = 0, max = 3), message.name)
        greeter ! HelloWorld.Greet(message.name, replyTo)
        Behaviors.same
      }
    }
}

    val system: ActorSystem[HelloWorldMain.Start] =
      ActorSystem(HelloWorldMain.main, "hello")

    system ! HelloWorldMain.Start("World")
    system ! HelloWorldMain.Start("Akka")
</code></pre>
          </pre>
        </div>
        <script defer src="https://embed.scalafiddle.io/integration.js"></script>
        </div>
<h2><a href="#a-more-complex-example" name="a-more-complex-example" class="anchor"><span class="anchor-link"></span></a>A More Complex Example</h2>
<p>The next example is more realistic and demonstrates some important patterns:</p>
<ul>
  <li>Using a sealed trait and case class/objects to represent multiple messages an actor can receive</li>
  <li>Handle sessions by using child actors</li>
  <li>Handling state by changing behavior</li>
  <li>Using multiple typed actors to represent different parts of a protocol in a type safe way</li>
</ul>
<h3><a href="#functional-style" name="functional-style" class="anchor"><span class="anchor-link"></span></a>Functional Style</h3>
<p>First we will show this example in a functional style, and then the same example is shown with an <a href="actors.html#object-oriented-style">Object-oriented style</a>. Which style you choose to use is a matter of taste and both styles can be mixed depending on which is best for a specific actor.</p>
<p>Consider an Actor that runs a chat room: client Actors may connect by sending a message that contains their screen name and then they can post messages. The chat room Actor will disseminate all posted messages to all currently connected client Actors. The protocol definition could look like the following:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L109-L126" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait RoomCommand
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent])
  extends RoomCommand

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

trait SessionCommand
final case class PostMessage(message: String) extends SessionCommand
private final case class NotifyClient(message: MessagePosted) extends SessionCommand</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L159-L228" target="_blank" title="Go to snippet source"></a><code class="language-java">static interface RoomCommand {}

public static final class GetSession implements RoomCommand {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;

  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

static interface SessionEvent {}

public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;

  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}

public static final class SessionDenied implements SessionEvent {
  public final String reason;

  public SessionDenied(String reason) {
    this.reason = reason;
  }
}

public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;

  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

static interface SessionCommand {}

public static final class PostMessage implements SessionCommand {
  public final String message;

  public PostMessage(String message) {
    this.message = message;
  }
}

private static final class NotifyClient implements SessionCommand {
  final MessagePosted message;

  NotifyClient(MessagePosted message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. Here&rsquo;s the implementation of the chat room protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L114-L165" target="_blank" title="Go to snippet source"></a><code class="language-scala">private final case class PublishSessionMessage(screenName: String, message: String)
  extends RoomCommand

val behavior: Behavior[RoomCommand] =
  chatRoom(List.empty)

private def chatRoom(sessions: List[ActorRef[SessionCommand]]): Behavior[RoomCommand] =
  Behaviors.receive { (context, message) ⇒
    message match {
      case GetSession(screenName, client) ⇒
        // create a child actor for further interaction with the client
        val ses = context.spawn(
          session(context.self, screenName, client),
          name = URLEncoder.encode(screenName, StandardCharsets.UTF_8.name))
        client ! SessionGranted(ses)
        chatRoom(ses :: sessions)
      case PublishSessionMessage(screenName, message) ⇒
        val notification = NotifyClient(MessagePosted(screenName, message))
        sessions foreach (_ ! notification)
        Behaviors.same
    }
  }

private def session(
  room:       ActorRef[PublishSessionMessage],
  screenName: String,
  client:     ActorRef[SessionEvent]): Behavior[SessionCommand] =
  Behaviors.receive { (context, message) ⇒
    message match {
      case PostMessage(message) ⇒
        // from client, publish to others via the room
        room ! PublishSessionMessage(screenName, message)
        Behaviors.same
      case NotifyClient(message) ⇒
        // published from the room
        client ! message
        Behaviors.same
    }
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L172-L281" target="_blank" title="Go to snippet source"></a><code class="language-java">private static final class PublishSessionMessage implements RoomCommand {
  public final String screenName;
  public final String message;

  public PublishSessionMessage(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

public static Behavior&lt;RoomCommand&gt; behavior() {
  return chatRoom(new ArrayList&lt;ActorRef&lt;SessionCommand&gt;&gt;());
}

private static Behavior&lt;RoomCommand&gt; chatRoom(List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions) {
  return Behaviors.receive(RoomCommand.class)
      .onMessage(
          GetSession.class,
          (context, getSession) -&gt; {
            ActorRef&lt;SessionEvent&gt; client = getSession.replyTo;
            ActorRef&lt;SessionCommand&gt; ses =
                context.spawn(
                    session(context.getSelf(), getSession.screenName, client),
                    URLEncoder.encode(getSession.screenName, StandardCharsets.UTF_8.name()));
            // narrow to only expose PostMessage
            client.tell(new SessionGranted(ses.narrow()));
            List&lt;ActorRef&lt;SessionCommand&gt;&gt; newSessions = new ArrayList&lt;&gt;(sessions);
            newSessions.add(ses);
            return chatRoom(newSessions);
          })
      .onMessage(
          PublishSessionMessage.class,
          (context, pub) -&gt; {
            NotifyClient notification =
                new NotifyClient((new MessagePosted(pub.screenName, pub.message)));
            sessions.forEach(s -&gt; s.tell(notification));
            return Behaviors.same();
          })
      .build();
}

public static Behavior&lt;ChatRoom.SessionCommand&gt; session(
    ActorRef&lt;RoomCommand&gt; room, String screenName, ActorRef&lt;SessionEvent&gt; client) {
  return Behaviors.receive(ChatRoom.SessionCommand.class)
      .onMessage(
          PostMessage.class,
          (context, post) -&gt; {
            // from client, publish to others via the room
            room.tell(new PublishSessionMessage(screenName, post.message));
            return Behaviors.same();
          })
      .onMessage(
          NotifyClient.class,
          (context, notification) -&gt; {
            // published from the room
            client.tell(notification.message);
            return Behaviors.same();
          })
      .build();
}</code></pre></dd>
</dl>
<p>The state is managed by changing behavior rather than using any variables.</p>
<p>When a new <code>GetSession</code> command comes in we add that client to the list that is in the returned behavior. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that repackages the <code>PostMessage</code> command into a <code>PublishSessionMessage</code> command which also includes the screen name.</p>
<p>The behavior that we declare here can handle both subtypes of <code>RoomCommand</code>. <code>GetSession</code> has been explained already and the <code>PublishSessionMessage</code> commands coming from the session Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PublishSessionMessage</code> commands to arbitrary clients, we reserve that right to the internal session actors we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PublishSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the <code>ChatRoom</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> to send to. In this case no session actor would be needed and we could use <span class="group-scala"><code>context.self</code></span><span class="group-java"><code>context.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> is required will lead to a type error.</p>
<h4><a href="#trying-it-out" name="trying-it-out" class="anchor"><span class="anchor-link"></span></a>Trying it out</h4>
<p>In order to see this chat room in action we need to write a client Actor that can use it:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L196-L212" target="_blank" title="Go to snippet source"></a><code class="language-scala">import ChatRoom._

val gabbler: Behavior[SessionEvent] =
  Behaviors.receiveMessage {
    case SessionGranted(handle) ⇒
      handle ! PostMessage(&quot;Hello World!&quot;)
      Behaviors.same
    case MessagePosted(screenName, message) ⇒
      println(s&quot;message has been posted by &#39;$screenName&#39;: $message&quot;)
      Behaviors.stopped
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L288-L314" target="_blank" title="Go to snippet source"></a><code class="language-java">public abstract static class Gabbler {
  private Gabbler() {}

  public static Behavior&lt;ChatRoom.SessionEvent&gt; behavior() {
    return Behaviors.receive(ChatRoom.SessionEvent.class)
        .onMessage(
            ChatRoom.SessionDenied.class,
            (context, message) -&gt; {
              System.out.println(&quot;cannot start chat room session: &quot; + message.reason);
              return Behaviors.stopped();
            })
        .onMessage(
            ChatRoom.SessionGranted.class,
            (context, message) -&gt; {
              message.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
              return Behaviors.same();
            })
        .onMessage(
            ChatRoom.MessagePosted.class,
            (context, message) -&gt; {
              System.out.println(
                  &quot;message has been posted by &#39;&quot; + message.screenName + &quot;&#39;: &quot; + message.message);
              return Behaviors.stopped();
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>From this behavior we can create an Actor that will accept a chat room session, post a message, wait to see it published, and then terminate. The last step requires the ability to change behavior, we need to transition from the normal running behavior into the terminated state. This is why here we do not return <code>same</code>, as above, but another special value <code>stopped</code>.</p><div class="group-scala">
<p>Since <code>SessionEvent</code> is a sealed trait the Scala compiler will warn us if we forget to handle one of the subtypes; in this case it reminded us that alternatively to <code>SessionGranted</code> we may also receive a <code>SessionDenied</code> event.</p></div>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one guardian supervisor we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/IntroSpec.scala#L216-L229" target="_blank" title="Go to snippet source"></a><code class="language-scala">val main: Behavior[NotUsed] =
  Behaviors.setup { context ⇒
    val chatRoom = context.spawn(ChatRoom.behavior, &quot;chatroom&quot;)
    val gabblerRef = context.spawn(gabbler, &quot;gabbler&quot;)
    context.watch(gabblerRef)
    chatRoom ! GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)

    Behaviors.receiveSignal {
      case (_, Terminated(ref)) ⇒
        Behaviors.stopped
    }
  }

val system = ActorSystem(main, &quot;ChatRoomDemo&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/IntroTest.java#L320-L337" target="_blank" title="Go to snippet source"></a><code class="language-java">Behavior&lt;Void&gt; main =
    Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ChatRoom.RoomCommand&gt; chatRoom =
              context.spawn(ChatRoom.behavior(), &quot;chatRoom&quot;);
          ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler =
              context.spawn(Gabbler.behavior(), &quot;gabbler&quot;);
          context.watch(gabbler);
          chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

          return Behaviors.&lt;Void&gt;receiveSignal(
              (c, sig) -&gt; {
                if (sig instanceof Terminated) return Behaviors.stopped();
                else return Behaviors.unhandled();
              });
        });

final ActorSystem&lt;Void&gt; system = ActorSystem.create(main, &quot;ChatRoomDemo&quot;);</code></pre></dd>
</dl>
<p>In good tradition we call the <code>main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>receive</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>main</code> Actor is created using <code>Behaviors.setup</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Behaviors.receive</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>setup</code> is passed the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>context.watch</code> for it. This allows us to shut down the Actor system: when the main Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>main</code> Actor’s <code>Behavior</code> we can let the <code>main</code> method return, the <code>ActorSystem</code> will continue running and the JVM alive until the root actor stops.</p>
<h3><a href="#object-oriented-style" name="object-oriented-style" class="anchor"><span class="anchor-link"></span></a>Object-oriented style</h3>
<p>The samples shown so far are all based on a functional programming style where you pass a function to a factory which then constructs a behavior, for stateful actors this means passing immutable state around as parameters and switching to a new behavior whenever you need to act on a changed state. An alternative way to express the same is a more object oriented style where a concrete class for the actor behavior is defined and mutable state is kept inside of it as fields. Which style you choose to use is a matter of taste and both styles can be mixed depending on which is best for a specific actor.</p>
<p>Some reasons why you may want to use the object-oriented style:</p><div class="group-java">
<ul>
  <li>you are more familiar with an object-oriented style of structuring the code with methods  in a class rather than functions</li>
  <li>Java lambdas can only close over final or effectively final fields, making it  impractical to use this style in behaviors that mutate their fields</li>
  <li>some state is not immutable, e.g. immutable collections are not widely used in Java</li>
  <li>it could be more familiar and easier to migrate existing untyped actors to this style</li>
  <li>mutable state can sometimes have better performance, e.g. mutable collections and  avoiding allocating new instance for next behavior (be sure to benchmark if this is your  motivation)</li>
</ul></div><div class="group-scala">
<ul>
  <li>you are more familiar with an object-oriented style of structuring the code with methods  in a class rather than functions</li>
  <li>some state is not immutable</li>
  <li>it could be more familiar and easier to migrate existing untyped actors to this style</li>
  <li>mutable state can sometimes have better performance, e.g. mutable collections and  avoiding allocating new instance for next behavior (be sure to benchmark if this is your  motivation)</li>
</ul></div>
<h4><a href="#abstractbehavior-api" name="abstractbehavior-api" class="anchor"><span class="anchor-link"></span></a>AbstractBehavior API</h4>
<p>Defining a class based actor behavior starts with extending <span class="group-scala"><code>akka.actor.typed.scaladsl.AbstractBehavior[T]</code></span> <span class="group-java"><code>akka.actor.typed.javadsl.AbstractBehavior&lt;T&gt;</code></span> where <code>T</code> is the type of messages the behavior will accept.</p>
<p>Let&rsquo;s repeat the chat room sample from <a href="actors.html#a-more-complex-example">A more complex example above</a> but implemented using <code>AbstractBehavior</code>. The protocol for interacting with the actor looks the same:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L23-L40" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait RoomCommand
final case class GetSession(screenName: String, replyTo: ActorRef[SessionEvent])
  extends RoomCommand

sealed trait SessionEvent
final case class SessionGranted(handle: ActorRef[PostMessage]) extends SessionEvent
final case class SessionDenied(reason: String) extends SessionEvent
final case class MessagePosted(screenName: String, message: String) extends SessionEvent

trait SessionCommand
final case class PostMessage(message: String) extends SessionCommand
private final case class NotifyClient(message: MessagePosted) extends SessionCommand</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L28-L97" target="_blank" title="Go to snippet source"></a><code class="language-java">static interface RoomCommand {}

public static final class GetSession implements RoomCommand {
  public final String screenName;
  public final ActorRef&lt;SessionEvent&gt; replyTo;

  public GetSession(String screenName, ActorRef&lt;SessionEvent&gt; replyTo) {
    this.screenName = screenName;
    this.replyTo = replyTo;
  }
}

static interface SessionEvent {}

public static final class SessionGranted implements SessionEvent {
  public final ActorRef&lt;PostMessage&gt; handle;

  public SessionGranted(ActorRef&lt;PostMessage&gt; handle) {
    this.handle = handle;
  }
}

public static final class SessionDenied implements SessionEvent {
  public final String reason;

  public SessionDenied(String reason) {
    this.reason = reason;
  }
}

public static final class MessagePosted implements SessionEvent {
  public final String screenName;
  public final String message;

  public MessagePosted(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

static interface SessionCommand {}

public static final class PostMessage implements SessionCommand {
  public final String message;

  public PostMessage(String message) {
    this.message = message;
  }
}

private static final class NotifyClient implements SessionCommand {
  final MessagePosted message;

  NotifyClient(MessagePosted message) {
    this.message = message;
  }
}</code></pre></dd>
</dl>
<p>Initially the client Actors only get access to an <span class="group-scala"><code>ActorRef[GetSession]</code></span><span class="group-java"><code>ActorRef&lt;GetSession&gt;</code></span> which allows them to make the first step. Once a client’s session has been established it gets a <code>SessionGranted</code> message that contains a <code>handle</code> to unlock the next protocol step, posting messages. The <code>PostMessage</code> command will need to be sent to this particular address that represents the session that has been added to the chat room. The other aspect of a session is that the client has revealed its own address, via the <code>replyTo</code> argument, so that subsequent <code>MessagePosted</code> events can be sent to it.</p>
<p>This illustrates how Actors can express more than just the equivalent of method calls on Java objects. The declared message types and their contents describe a full protocol that can involve multiple Actors and that can evolve over multiple steps. Here&rsquo;s the <code>AbstractBehavior</code> implementation of the chat room protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L28-L81" target="_blank" title="Go to snippet source"></a><code class="language-scala">private final case class PublishSessionMessage(screenName: String, message: String)
  extends RoomCommand

def behavior(): Behavior[RoomCommand] =
  Behaviors.setup[RoomCommand](context ⇒ new ChatRoomBehavior(context))

class ChatRoomBehavior(context: ActorContext[RoomCommand]) extends AbstractBehavior[RoomCommand] {
  private var sessions: List[ActorRef[SessionCommand]] = List.empty

  override def onMessage(message: RoomCommand): Behavior[RoomCommand] = {
    message match {
      case GetSession(screenName, client) ⇒
        // create a child actor for further interaction with the client
        val ses = context.spawn(
          session(context.self, screenName, client),
          name = URLEncoder.encode(screenName, StandardCharsets.UTF_8.name))
        client ! SessionGranted(ses)
        sessions = ses :: sessions
        this
      case PublishSessionMessage(screenName, message) ⇒
        val notification = NotifyClient(MessagePosted(screenName, message))
        sessions foreach (_ ! notification)
        this
    }
  }
}

private def session(
  room:       ActorRef[PublishSessionMessage],
  screenName: String,
  client:     ActorRef[SessionEvent]): Behavior[SessionCommand] =
  Behaviors.receiveMessage {
    case PostMessage(message) ⇒
      // from client, publish to others via the room
      room ! PublishSessionMessage(screenName, message)
      Behaviors.same
    case NotifyClient(message) ⇒
      // published from the room
      client ! message
      Behaviors.same
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L41-L159" target="_blank" title="Go to snippet source"></a><code class="language-java">private static final class PublishSessionMessage implements RoomCommand {
  public final String screenName;
  public final String message;

  public PublishSessionMessage(String screenName, String message) {
    this.screenName = screenName;
    this.message = message;
  }
}

public static Behavior&lt;RoomCommand&gt; behavior() {
  return Behaviors.setup(ChatRoomBehavior::new);
}

public static class ChatRoomBehavior extends AbstractBehavior&lt;RoomCommand&gt; {
  final ActorContext&lt;RoomCommand&gt; context;
  final List&lt;ActorRef&lt;SessionCommand&gt;&gt; sessions = new ArrayList&lt;&gt;();

  public ChatRoomBehavior(ActorContext&lt;RoomCommand&gt; context) {
    this.context = context;
  }

  @Override
  public Receive&lt;RoomCommand&gt; createReceive() {
    return receiveBuilder()
        .onMessage(
            GetSession.class,
            getSession -&gt; {
              ActorRef&lt;SessionEvent&gt; client = getSession.replyTo;
              ActorRef&lt;SessionCommand&gt; ses =
                  context.spawn(
                      session(context.getSelf(), getSession.screenName, client),
                      URLEncoder.encode(getSession.screenName, StandardCharsets.UTF_8.name()));
              // narrow to only expose PostMessage
              client.tell(new SessionGranted(ses.narrow()));
              sessions.add(ses);
              return this;
            })
        .onMessage(
            PublishSessionMessage.class,
            pub -&gt; {
              NotifyClient notification =
                  new NotifyClient((new MessagePosted(pub.screenName, pub.message)));
              sessions.forEach(s -&gt; s.tell(notification));
              return this;
            })
        .build();
  }
}

public static Behavior&lt;ChatRoom.SessionCommand&gt; session(
    ActorRef&lt;RoomCommand&gt; room, String screenName, ActorRef&lt;SessionEvent&gt; client) {
  return Behaviors.receive(ChatRoom.SessionCommand.class)
      .onMessage(
          PostMessage.class,
          (context, post) -&gt; {
            // from client, publish to others via the room
            room.tell(new PublishSessionMessage(screenName, post.message));
            return Behaviors.same();
          })
      .onMessage(
          NotifyClient.class,
          (context, notification) -&gt; {
            // published from the room
            client.tell(notification.message);
            return Behaviors.same();
          })
      .build();
}</code></pre></dd>
</dl>
<p>The state is managed through fields in the class, just like with a regular object oriented class. As the state is mutable, we never return a different behavior from the message logic, but can return the <code>AbstractBehavior</code> instance itself (<code>this</code>) as a behavior to use for processing the next message coming in. We could also return <code>Behavior.same</code> to achieve the same.</p>
<p>It is also possible to return a new different <code>AbstractBehavior</code>, for example to represent a different state in a finite state machine (FSM), or use one of the functional behavior factories to combine the object oriented with the functional style for different parts of the lifecycle of the same Actor behavior.</p>
<p>When a new <code>GetSession</code> command comes in we add that client to the list of current sessions. Then we also need to create the session’s <code>ActorRef</code> that will be used to post messages. In this case we want to create a very simple Actor that repackages the <code>PostMessage</code> command into a <code>PublishSessionMessage</code> command which also includes the screen name.</p>
<p>To implement the logic where we spawn a child for the session we need access to the <code>ActorContext</code>. This is injected as a constructor parameter upon creation of the behavior, note how we combine the <code>AbstractBehavior</code> with <code>Behaviors.setup</code> to do this in the <code>behavior</code> method. </p>
<p>The behavior that we declare here can handle both subtypes of <code>RoomCommand</code>. <code>GetSession</code> has been explained already and the <code>PublishSessionMessage</code> commands coming from the session Actors will trigger the dissemination of the contained chat room message to all connected clients. But we do not want to give the ability to send <code>PublishSessionMessage</code> commands to arbitrary clients, we reserve that right to the internal session actors we create—otherwise clients could pose as completely different screen names (imagine the <code>GetSession</code> protocol to include authentication information to further secure this). Therefore <code>PublishSessionMessage</code> has <code>private</code> visibility and can&rsquo;t be created outside the <code>ChatRoom</code> <span class="group-scala">object</span><span class="group-java">class</span>.</p>
<p>If we did not care about securing the correspondence between a session and a screen name then we could change the protocol such that <code>PostMessage</code> is removed and all clients just get an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> to send to. In this case no session actor would be needed and we could use <span class="group-scala"><code>context.self</code></span><span class="group-java"><code>context.getSelf()</code></span>. The type-checks work out in that case because <span class="group-scala"><code>ActorRef[-T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> is contravariant in its type parameter, meaning that we can use a <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> wherever an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> is needed—this makes sense because the former simply speaks more languages than the latter. The opposite would be problematic, so passing an <span class="group-scala"><code>ActorRef[PublishSessionMessage]</code></span><span class="group-java"><code>ActorRef&lt;PublishSessionMessage&gt;</code></span> where <span class="group-scala"><code>ActorRef[RoomCommand]</code></span><span class="group-java"><code>ActorRef&lt;RoomCommand&gt;</code></span> is required will lead to a type error.</p>
<h4><a href="#trying-it-out" name="trying-it-out" class="anchor"><span class="anchor-link"></span></a>Trying it out</h4>
<p>In order to see this chat room in action we need to write a client Actor that can use it, for this stateless actor it doesn&rsquo;t make much sense to use the <code>AbstractBehavior</code> so let&rsquo;s just reuse the functional style gabbler from the sample above:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L95-L108" target="_blank" title="Go to snippet source"></a><code class="language-scala">import ChatRoom._

val gabbler =
  Behaviors.receiveMessage[SessionEvent] {
    case SessionDenied(reason) ⇒
      println(s&quot;cannot start chat room session: $reason&quot;)
      Behaviors.stopped
    case SessionGranted(handle) ⇒
      handle ! PostMessage(&quot;Hello World!&quot;)
      Behaviors.same
    case MessagePosted(screenName, message) ⇒
      println(s&quot;message has been posted by &#39;$screenName&#39;: $message&quot;)
      Behaviors.stopped
  }</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L165-L191" target="_blank" title="Go to snippet source"></a><code class="language-java">public abstract static class Gabbler {
  private Gabbler() {}

  public static Behavior&lt;ChatRoom.SessionEvent&gt; behavior() {
    return Behaviors.receive(ChatRoom.SessionEvent.class)
        .onMessage(
            ChatRoom.SessionDenied.class,
            (context, message) -&gt; {
              System.out.println(&quot;cannot start chat room session: &quot; + message.reason);
              return Behaviors.stopped();
            })
        .onMessage(
            ChatRoom.SessionGranted.class,
            (context, message) -&gt; {
              message.handle.tell(new ChatRoom.PostMessage(&quot;Hello World!&quot;));
              return Behaviors.same();
            })
        .onMessage(
            ChatRoom.MessagePosted.class,
            (context, message) -&gt; {
              System.out.println(
                  &quot;message has been posted by &#39;&quot; + message.screenName + &quot;&#39;: &quot; + message.message);
              return Behaviors.stopped();
            })
        .build();
  }
}</code></pre></dd>
</dl>
<p>Now to try things out we must start both a chat room and a gabbler and of course we do this inside an Actor system. Since there can be only one guardian supervisor we could either start the chat room from the gabbler (which we don’t want—it complicates its logic) or the gabbler from the chat room (which is nonsensical) or we start both of them from a third Actor—our only sensible choice:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/OOIntroSpec.scala#L112-L130" target="_blank" title="Go to snippet source"></a><code class="language-scala">val main: Behavior[String] =
  Behaviors.setup { context ⇒
    val chatRoom = context.spawn(ChatRoom.behavior(), &quot;chatroom&quot;)
    val gabblerRef = context.spawn(gabbler, &quot;gabbler&quot;)
    context.watch(gabblerRef)

    Behaviors.receiveMessagePartial[String] {
      case &quot;go&quot; ⇒
        chatRoom ! GetSession(&quot;ol’ Gabbler&quot;, gabblerRef)
        Behaviors.same
    } receiveSignal {
      case (_, Terminated(_)) ⇒
        println(&quot;Stopping guardian&quot;)
        Behaviors.stopped
    }
  }

val system = ActorSystem(main, &quot;ChatRoomDemo&quot;)
system ! &quot;go&quot;</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/OOIntroTest.java#L197-L214" target="_blank" title="Go to snippet source"></a><code class="language-java">Behavior&lt;Void&gt; main =
    Behaviors.setup(
        context -&gt; {
          ActorRef&lt;ChatRoom.RoomCommand&gt; chatRoom =
              context.spawn(ChatRoom.behavior(), &quot;chatRoom&quot;);
          ActorRef&lt;ChatRoom.SessionEvent&gt; gabbler =
              context.spawn(Gabbler.behavior(), &quot;gabbler&quot;);
          context.watch(gabbler);
          chatRoom.tell(new ChatRoom.GetSession(&quot;ol’ Gabbler&quot;, gabbler));

          return Behaviors.&lt;Void&gt;receiveSignal(
              (c, sig) -&gt; {
                if (sig instanceof Terminated) return Behaviors.stopped();
                else return Behaviors.unhandled();
              });
        });

final ActorSystem&lt;Void&gt; system = ActorSystem.create(main, &quot;ChatRoomDemo&quot;);</code></pre></dd>
</dl>
<p>In good tradition we call the <code>main</code> Actor what it is, it directly corresponds to the <code>main</code> method in a traditional Java application. This Actor will perform its job on its own accord, we do not need to send messages from the outside, so we declare it to be of type <span class="group-scala"><code>NotUsed</code></span><span class="group-java"><code>Void</code></span>. Actors receive not only external messages, they also are notified of certain system events, so-called Signals. In order to get access to those we choose to implement this particular one using the <code>receive</code> behavior decorator. The provided <code>onSignal</code> function will be invoked for signals (subclasses of <code>Signal</code>) or the <code>onMessage</code> function for user messages.</p>
<p>This particular <code>main</code> Actor is created using <code>Behaviors.setup</code>, which is like a factory for a behavior. Creation of the behavior instance is deferred until the actor is started, as opposed to <code>Behaviors.receive</code> that creates the behavior instance immediately before the actor is running. The factory function in <code>setup</code> is passed the <code>ActorContext</code> as parameter and that can for example be used for spawning child actors. This <code>main</code> Actor creates the chat room and the gabbler and the session between them is initiated, and when the gabbler is finished we will receive the <code>Terminated</code> event due to having called <code>context.watch</code> for it. This allows us to shut down the Actor system: when the main Actor terminates there is nothing more to do.</p>
<p>Therefore after creating the Actor system with the <code>main</code> Actor’s <code>Behavior</code> we can let the <code>main</code> method return, the <code>ActorSystem</code> will continue running and the JVM alive until the root actor stops.</p>
<h2><a href="#relation-to-akka-untyped-actors" name="relation-to-akka-untyped-actors" class="anchor"><span class="anchor-link"></span></a>Relation to Akka (untyped) Actors</h2>
<p>The most prominent difference is the removal of the <code>sender()</code> functionality. The solution chosen in Akka Typed is to explicitly include the properly typed reply-to address in the message, which both burdens the user with this task but also places this aspect of protocol design where it belongs.</p>
<p>The other prominent difference is the removal of the <code>Actor</code> trait. In order to avoid closing over unstable references from different execution contexts (e.g. Future transformations) we turned all remaining methods that were on this trait into messages: the behavior receives the <code>ActorContext</code> as an argument during processing and the lifecycle hooks have been converted into Signals.</p>
<p>A side-effect of this is that behaviors can now be tested in isolation without having to be packaged into an Actor, tests can run fully synchronously without having to worry about timeouts and spurious failures. Another side-effect is that behaviors can nicely be composed and decorated, for example <code>Behaviors.tap</code> is not special or using something internal. New operators can be written as external libraries or tailor-made for each project.</p>
<h2><a href="#a-little-bit-of-theory" name="a-little-bit-of-theory" class="anchor"><span class="anchor-link"></span></a>A Little Bit of Theory</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a> as defined by Hewitt, Bishop and Steiger in 1973 is a computational model that expresses exactly what it means for computation to be distributed. The processing units—Actors—can only communicate by exchanging messages and upon reception of a message an Actor can do the following three fundamental actions:</p>
<ol>
  <li>send a finite number of messages to Actors it knows</li>
  <li>create a finite number of new Actors</li>
  <li>designate the behavior to be applied to the next message</li>
</ol>
<p>The Akka Typed project expresses these actions using behaviors and addresses. Messages can be sent to an address and behind this façade there is a behavior that receives the message and acts upon it. The binding between address and behavior can change over time as per the third point above, but that is not visible on the outside.</p>
<p>With this preamble we can get to the unique property of this project, namely that it introduces static type checking to Actor interactions: addresses are parameterized and only messages that are of the specified type can be sent to them. The association between an address and its type parameter must be made when the address (and its Actor) is created. For this purpose each behavior is also parameterized with the type of messages it is able to process. Since the behavior can change behind the address façade, designating the next behavior is a constrained operation: the successor must handle the same type of messages as its predecessor. This is necessary in order to not invalidate the addresses that refer to this Actor.</p>
<p>What this enables is that whenever a message is sent to an Actor we can statically ensure that the type of the message is one that the Actor declares to handle—we can avoid the mistake of sending completely pointless messages. What we cannot statically ensure, though, is that the behavior behind the address will be in a given state when our message is received. The fundamental reason is that the association between address and behavior is a dynamic runtime property, the compiler cannot know it while it translates the source code.</p>
<p>This is the same as for normal Java objects with internal variables: when compiling the program we cannot know what their value will be, and if the result of a method call depends on those variables then the outcome is uncertain to a degree—we can only be certain that the returned value is of a given type.</p>
<p>We have seen above that the return type of an Actor command is described by the type of reply-to address that is contained within the message. This allows a conversation to be described in terms of its types: the reply will be of type A, but it might also contain an address of type B, which then allows the other Actor to continue the conversation by sending a message of type B to this new address. While we cannot statically express the “current” state of an Actor, we can express the current state of a protocol between two Actors, since that is just given by the last message type that was received or sent.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/guide/tutorial_5.html"><i class="icon-prev"></i> <span class="link-prev">Part 5: Querying Device Groups</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/dispatchers.html">Dispatchers <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/typed/actors.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
