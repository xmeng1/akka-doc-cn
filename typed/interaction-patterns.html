<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Interaction Patterns &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/typed/interaction-patterns.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
<link rel="manifest" href="../images/manifest.json">
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html#interaction-patterns" class="active page">Interaction Patterns</a>
    <ul>
      <li><a href="../typed/interaction-patterns.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/interaction-patterns.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/interaction-patterns.html#fire-and-forget" class="header">Fire and Forget</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response" class="header">Request-Response</a></li>
      <li><a href="../typed/interaction-patterns.html#adapted-response" class="header">Adapted Response</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-between-two-actors" class="header">Request-Response with ask between two actors</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-from-outside-an-actor" class="header">Request-Response with ask from outside an Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#per-session-child-actor" class="header">Per session child Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#scheduling-messages-to-self" class="header">Scheduling messages to self</a></li>
    </ul></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../index-actors.html" class="page">Actors</a></li>
  <li><a href="../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../typed/guide/index.html" class="page">Getting Started Guide</a></li>
    <li><a href="../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../typed/interaction-patterns.html#interaction-patterns" class="active page">Interaction Patterns</a>
    <ul>
      <li><a href="../typed/interaction-patterns.html#dependency" class="header">Dependency</a></li>
      <li><a href="../typed/interaction-patterns.html#introduction" class="header">Introduction</a></li>
      <li><a href="../typed/interaction-patterns.html#fire-and-forget" class="header">Fire and Forget</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response" class="header">Request-Response</a></li>
      <li><a href="../typed/interaction-patterns.html#adapted-response" class="header">Adapted Response</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-between-two-actors" class="header">Request-Response with ask between two actors</a></li>
      <li><a href="../typed/interaction-patterns.html#request-response-with-ask-from-outside-an-actor" class="header">Request-Response with ask from outside an Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#per-session-child-actor" class="header">Per session child Actor</a></li>
      <li><a href="../typed/interaction-patterns.html#scheduling-messages-to-self" class="header">Scheduling messages to self</a></li>
    </ul></li>
    <li><a href="../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../stream/index.html" class="page">Streams</a></li>
  <li><a href="../index-network.html" class="page">Networking</a></li>
  <li><a href="../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../project/index.html" class="page">Project Information</a></li>
  <li><a href="../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#interaction-patterns" name="interaction-patterns" class="anchor"><span class="anchor-link"></span></a>Interaction Patterns</h1>
<h2><a href="#dependency" name="dependency" class="anchor"><span class="anchor-link"></span></a>Dependency</h2>
<p>To use Akka Actor Typed, you must add the following dependency in your project:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "com.typesafe.akka" %% "akka-actor-typed" % "2.5-SNAPSHOT"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor-typed_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.5-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'com.typesafe.akka', name: 'akka-actor-typed_2.12', version: '2.5-SNAPSHOT'
}</code></pre></dd></dl>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2>
<p>Interacting with an Actor in Akka Typed is done through an <span class="group-scala"><code>ActorRef[T]</code></span><span class="group-java"><code>ActorRef&lt;T&gt;</code></span> where <code>T</code> is the type of messages the actor accepts, also known as the &ldquo;protocol&rdquo;. This ensures that only the right kind of messages can be sent to an actor and also that no one else but the Actor itself can access the Actor instance internals.</p>
<p>Message exchange with Actors follow a few common patterns, let&rsquo;s go through each one of them. </p>
<h2><a href="#fire-and-forget" name="fire-and-forget" class="anchor"><span class="anchor-link"></span></a>Fire and Forget</h2>
<p>The fundamental way to interact with an actor is through <span class="group-scala">&ldquo;tell&rdquo;, which is so common that it has a special symbolic method name: <code>actorRef ! message</code></span><span class="group-java"><code>actorRef.tell(message)</code></span>. Sending a message with tell can safely be done from any thread.</p>
<p>Tell is asynchronous which means that the method returns right away, when the statement after it is executed there is no guarantee that the message has been processed by the recipient yet. It also means there is no way to know if the message was received, the processing succeeded or failed.</p>
<p>With the given protocol and actor behavior:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L27-L33" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class PrintMe(message: String)

val printerBehavior: Behavior[PrintMe] = Behaviors.receive {
  case (context, PrintMe(message)) ⇒
    context.log.info(message)
    Behaviors.same
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L27-L43" target="_blank" title="Go to snippet source"></a><code class="language-java">class PrintMe {
  public final String message;

  public PrintMe(String message) {
    this.message = message;
  }
}

static final Behavior&lt;PrintMe&gt; printerBehavior =
    Behaviors.receive(PrintMe.class)
        .onMessage(
            PrintMe.class,
            (context, printMe) -&gt; {
              context.getLog().info(printMe.message);
              return Behaviors.same();
            })
        .build();</code></pre></dd>
</dl>
<p>Fire and forget looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L37-L44" target="_blank" title="Go to snippet source"></a><code class="language-scala">val system = ActorSystem(printerBehavior, &quot;fire-and-forget-sample&quot;)

// note how the system is also the top level actor ref
val printer: ActorRef[PrintMe] = system

// these are all fire and forget
printer ! PrintMe(&quot;message 1&quot;)
printer ! PrintMe(&quot;not message 2&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L253-L261" target="_blank" title="Go to snippet source"></a><code class="language-java">final ActorSystem&lt;PrintMe&gt; system =
    ActorSystem.create(printerBehavior, &quot;printer-sample-system&quot;);

// note that system is also the ActorRef to the guardian actor
final ActorRef&lt;PrintMe&gt; ref = system;

// these are all fire and forget
ref.tell(new PrintMe(&quot;message 1&quot;));
ref.tell(new PrintMe(&quot;message 2&quot;));</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>It is not critical to be sure that the message was processed</li>
  <li>There is no way to act on non successful delivery or processing</li>
  <li>We want to minimize the number of messages created to get higher throughput (sending a response would require creating twice the number of messages)</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>If the inflow of messages is higher than the actor can process the inbox will fill up and can in the worst case cause the JVM crash with an <code>OutOfMemoryError</code></li>
  <li>If the message gets lost, the sender will not know</li>
</ul>
<h2><a href="#request-response" name="request-response" class="anchor"><span class="anchor-link"></span></a>Request-Response</h2>
<p>Many interactions between actors requires one or more response message being sent back from the receiving actor. A response message can be a result of a query, some form of acknowledgment that the message was received and processed or events that the request subscribed to. </p>
<p>In Akka Typed the recipient of responses has to be encoded as a field in the message itself, which the recipient can then use to send (tell) a response back.</p>
<p>With the following protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L53-L54" target="_blank" title="Go to snippet source"></a><code class="language-scala">case class Request(query: String, respondTo: ActorRef[Response])
case class Response(result: String)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L47-L63" target="_blank" title="Go to snippet source"></a><code class="language-java">class Request {
  public final String query;
  public final ActorRef&lt;Response&gt; respondTo;

  public Request(String query, ActorRef&lt;Response&gt; respondTo) {
    this.query = query;
    this.respondTo = respondTo;
  }
}

class Response {
  public final String result;

  public Response(String result) {
    this.result = result;
  }
}</code></pre></dd>
</dl>
<p>The sender would use its own <span class="group-scala"><code>ActorRef[Response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span>, which it can access through <span class="group-scala"><code>ActorContext.self</code></span><span class="group-java"><code>ActorContext.getSelf()</code></span>, for the <code>respondTo</code>. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L74" target="_blank" title="Go to snippet source"></a><code class="language-scala">otherActor ! Request(&quot;give me cookies&quot;, context.self)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L85" target="_blank" title="Go to snippet source"></a><code class="language-java">otherActor.tell(new Request(&quot;give me cookies&quot;, context.getSelf()));</code></pre></dd>
</dl>
<p>On the receiving side the <span class="group-scala"><code>ActorRef[response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span> can then be used to send one or more responses back:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L58-L63" target="_blank" title="Go to snippet source"></a><code class="language-scala">val otherBehavior = Behaviors.receiveMessage[Request] {
  case Request(query, respondTo) ⇒
    // ... process query ...
    respondTo ! Response(&quot;Here&#39;s your cookies!&quot;)
    Behaviors.same
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L69-L78" target="_blank" title="Go to snippet source"></a><code class="language-java">// actor behavior
Behaviors.receive(Request.class)
    .onMessage(
        Request.class,
        (context, request) -&gt; {
          // ... process request ...
          request.respondTo.tell(new Response(&quot;Here&#39;s your response!&quot;));
          return Behaviors.same();
        })
    .build();</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Subscribing to an actor that will send many response messages back</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Actors seldom have a response message from another actor as a part of their protocol (see <a href="interaction-patterns.html#adapted-response">adapted response</a>)</li>
  <li>It is hard to detect that a message request was not delivered or processed (see <a href="interaction-patterns.html#request-response-with-ask-between-two-actors">ask</a>)</li>
  <li>Unless the protocol already includes a way to provide context, for example a request id that is also sent in the  response, it is not possible to tie an interaction to some specific context without introducing a new,  separate, actor (see ask or per session child actor)</li>
</ul>
<h2><a href="#adapted-response" name="adapted-response" class="anchor"><span class="anchor-link"></span></a>Adapted Response</h2>
<p>Most often the sending actor does not, and should not, support receiving the response messages of another actor. In such cases we need to provide an <code>ActorRef</code> of the right type and adapt the response message to a type that the sending actor can handle.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L82-L134" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>object Backend {
  sealed trait Request
  final case class StartTranslationJob(
    taskId:  Int,
    site:    URI,
    replyTo: ActorRef[Response]
  ) extends Request

  sealed trait Response
  final case class JobStarted(taskId: Int) extends Response
  final case class JobProgress(taskId: Int, progress: Double) extends Response
  final case class JobCompleted(taskId: Int, result: URI) extends Response
}

object Frontend {

  sealed trait Command
  final case class Translate(site: URI, replyTo: ActorRef[URI]) extends Command
  private final case class WrappedBackendResponse(response: Backend.Response) extends Command

  def translator(backend: ActorRef[Backend.Request]): Behavior[Command] =
    Behaviors.setup[Command] { context ⇒
      val backendResponseMapper: ActorRef[Backend.Response] =
        context.messageAdapter(rsp ⇒ WrappedBackendResponse(rsp))

      def active(
        inProgress: Map[Int, ActorRef[URI]],
        count:      Int): Behavior[Command] = {
        Behaviors.receiveMessage[Command] {
          case Translate(site, replyTo) ⇒
            val taskId = count + 1
            backend ! Backend.StartTranslationJob(taskId, site, backendResponseMapper)
            active(inProgress.updated(taskId, replyTo), taskId)

          case wrapped: WrappedBackendResponse ⇒ wrapped.response match {
            case Backend.JobStarted(taskId) ⇒
              context.log.info(&quot;Started {}&quot;, taskId)
              Behaviors.same
            case Backend.JobProgress(taskId, progress) ⇒
              context.log.info(&quot;Progress {}: {}&quot;, taskId, progress)
              Behaviors.same
            case Backend.JobCompleted(taskId, result) ⇒
              context.log.info(&quot;Completed {}: {}&quot;, taskId, result)
              inProgress(taskId) ! result
              active(inProgress - taskId, count)
          }
        }
      }

      active(inProgress = Map.empty, count = 0)
    }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L90-L247" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>public static class Backend {
  interface Request {}

  public static class StartTranslationJob implements Request {
    public final int taskId;
    public final URI site;
    public final ActorRef&lt;Response&gt; replyTo;

    public StartTranslationJob(int taskId, URI site, ActorRef&lt;Response&gt; replyTo) {
      this.taskId = taskId;
      this.site = site;
      this.replyTo = replyTo;
    }
  }

  interface Response {}

  public static class JobStarted implements Response {
    public final int taskId;

    public JobStarted(int taskId) {
      this.taskId = taskId;
    }
  }

  public static class JobProgress implements Response {
    public final int taskId;
    public final double progress;

    public JobProgress(int taskId, double progress) {
      this.taskId = taskId;
      this.progress = progress;
    }
  }

  public static class JobCompleted implements Response {
    public final int taskId;
    public final URI result;

    public JobCompleted(int taskId, URI result) {
      this.taskId = taskId;
      this.result = result;
    }
  }
}

public static class Frontend {

  interface Command {}

  public static class Translate implements Command {
    public final URI site;
    public final ActorRef&lt;URI&gt; replyTo;

    public Translate(URI site, ActorRef&lt;URI&gt; replyTo) {
      this.site = site;
      this.replyTo = replyTo;
    }
  }

  private static class WrappedJobStarted implements Command {
    final Backend.JobStarted response;

    public WrappedJobStarted(Backend.JobStarted response) {
      this.response = response;
    }
  }

  private static class WrappedJobProgress implements Command {
    final Backend.JobProgress response;

    public WrappedJobProgress(Backend.JobProgress response) {
      this.response = response;
    }
  }

  private static class WrappedJobCompleted implements Command {
    final Backend.JobCompleted response;

    public WrappedJobCompleted(Backend.JobCompleted response) {
      this.response = response;
    }
  }

  private static class OtherResponse implements Command {
    final Backend.Response response;

    public OtherResponse(Backend.Response response) {
      this.response = response;
    }
  }

  public static class Translator extends AbstractBehavior&lt;Command&gt; {
    private final ActorContext&lt;Command&gt; context;
    private final ActorRef&lt;Backend.Request&gt; backend;
    private final ActorRef&lt;Backend.Response&gt; backendResponseAdapter;

    private int taskIdCounter = 0;
    private Map&lt;Integer, ActorRef&lt;URI&gt;&gt; inProgress = new HashMap&lt;&gt;();

    public Translator(ActorContext&lt;Command&gt; context, ActorRef&lt;Backend.Request&gt; backend) {
      this.context = context;
      this.backend = backend;
      this.backendResponseAdapter =
          context.messageAdapter(
              Backend.Response.class,
              rsp -&gt; {
                if (rsp instanceof Backend.JobStarted)
                  return new WrappedJobStarted((Backend.JobStarted) rsp);
                else if (rsp instanceof Backend.JobProgress)
                  return new WrappedJobProgress((Backend.JobProgress) rsp);
                else if (rsp instanceof Backend.JobCompleted)
                  return new WrappedJobCompleted((Backend.JobCompleted) rsp);
                else return new OtherResponse(rsp);
              });
    }

    @Override
    public Receive&lt;Command&gt; createReceive() {
      return receiveBuilder()
          .onMessage(
              Translate.class,
              cmd -&gt; {
                taskIdCounter += 1;
                inProgress.put(taskIdCounter, cmd.replyTo);
                backend.tell(
                    new Backend.StartTranslationJob(
                        taskIdCounter, cmd.site, backendResponseAdapter));
                return this;
              })
          .onMessage(
              WrappedJobStarted.class,
              wrapped -&gt; {
                context.getLog().info(&quot;Started {}&quot;, wrapped.response.taskId);
                return this;
              })
          .onMessage(
              WrappedJobProgress.class,
              wrapped -&gt; {
                context
                    .getLog()
                    .info(&quot;Progress {}: {}&quot;, wrapped.response.taskId, wrapped.response.progress);
                return this;
              })
          .onMessage(
              WrappedJobCompleted.class,
              wrapped -&gt; {
                context
                    .getLog()
                    .info(&quot;Completed {}: {}&quot;, wrapped.response.taskId, wrapped.response.result);
                return this;
              })
          .onMessage(OtherResponse.class, other -&gt; Behaviors.unhandled())
          .build();
    }
  }
}</code></pre></dd>
</dl>
<p>You can register several message adapters for different message classes. It&rsquo;s only possible to have one message adapter per message class to make sure that the number of adapters are not growing unbounded if registered repeatedly. That also means that a registered adapter will replace an existing adapter for the same message class.</p>
<p>A message adapter will be used if the message class matches the given class or is a subclass thereof. The registered adapters are tried in reverse order of their registration order, i.e. the last registered first.</p>
<p>A message adapter (and the returned <code>ActorRef</code>) has the same lifecycle as the receiving actor. It&rsquo;s recommended to register the adapters in a top level <code>Behaviors.setup</code> or constructor of <code>AbstractBehavior</code> but it&rsquo;s possible to register them later also if needed.</p>
<p>The adapter function is running in the receiving actor and can safely access state of it, but if it throws an exception the actor is stopped.</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Translating between different actor message protocols</li>
  <li>Subscribing to an actor that will send many response messages back</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>It is hard to detect that a message request was not delivered or processed (see <a href="interaction-patterns.html#request-response-with-ask-between-two-actors">ask</a>)</li>
  <li>Only one adaption can be made per response message type, if a new one is registered the old one is replaced,  for example different target actors can&rsquo;t have different adaption if they use the same response types, unless some  correlation is encoded in the messages</li>
  <li>Unless the protocol already includes a way to provide context, for example a request id that is also sent in the  response, it is not possible to tie an interaction to some specific context without introducing a new,  separate, actor</li>
</ul>
<h2><a href="#request-response-with-ask-between-two-actors" name="request-response-with-ask-between-two-actors" class="anchor"><span class="anchor-link"></span></a>Request-Response with ask between two actors</h2>
<p>In an interaction where there is a 1:1 mapping between a request and a response we can use <code>ask</code> on the <code>ActorContext</code> to interact with another actor.</p>
<p>The interaction has two steps, first we need to construct the outgoing message, to do that we need an <span class="group-scala"><code>ActorRef[Response]</code></span><span class="group-java"><code>ActorRef&lt;Response&gt;</code></span> to put as recipient in the outgoing message. The second step is to transform the successful <code>Response</code> or failure into a message that is part of the protocol of the sending actor.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L205-L251" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait HalCommand
case class OpenThePodBayDoorsPlease(respondTo: ActorRef[HalResponse]) extends HalCommand
case class HalResponse(message: String)

val halBehavior = Behaviors.receiveMessage[HalCommand] {
  case OpenThePodBayDoorsPlease(respondTo) ⇒
    respondTo ! HalResponse(&quot;I&#39;m sorry, Dave. I&#39;m afraid I can&#39;t do that.&quot;)
    Behaviors.same
}

sealed trait DaveMessage
// this is a part of the protocol that is internal to the actor itself
case class AdaptedResponse(message: String) extends DaveMessage

def daveBehavior(hal: ActorRef[HalCommand]) = Behaviors.setup[DaveMessage] { context ⇒

  // asking someone requires a timeout, if the timeout hits without response
  // the ask is failed with a TimeoutException
  implicit val timeout: Timeout = 3.seconds

  // Note: The second parameter list takes a function `ActorRef[T] =&gt; Message`,
  // as OpenThePodBayDoorsPlease is a case class it has a factory apply method
  // that is what we are passing as the second parameter here it could also be written
  // as `ref =&gt; OpenThePodBayDoorsPlease(ref)`
  context.ask(hal)(OpenThePodBayDoorsPlease) {
    case Success(HalResponse(message)) ⇒ AdaptedResponse(message)
    case Failure(ex)                   ⇒ AdaptedResponse(&quot;Request failed&quot;)
  }

  // we can also tie in request context into an interaction, it is safe to look at
  // actor internal state from the transformation function, but remember that it may have
  // changed at the time the response arrives and the transformation is done, best is to
  // use immutable state we have closed over like here.
  val requestId = 1
  context.ask(hal)(OpenThePodBayDoorsPlease) {
    case Success(HalResponse(message)) ⇒ AdaptedResponse(s&quot;$requestId: $message&quot;)
    case Failure(ex)                   ⇒ AdaptedResponse(s&quot;$requestId: Request failed&quot;)
  }

  Behaviors.receiveMessage {
    // the adapted message ends up being processed like any other
    // message sent to the actor
    case AdaptedResponse(message) ⇒
      context.log.info(&quot;Got response from hal: {}&quot;, message)
      Behaviors.same
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L380-L474" target="_blank" title="Go to snippet source"></a><code class="language-java">interface HalCommand {}

static final class OpenThePodBayDoorsPlease implements HalCommand {
  public final ActorRef&lt;HalResponse&gt; respondTo;

  OpenThePodBayDoorsPlease(ActorRef&lt;HalResponse&gt; respondTo) {
    this.respondTo = respondTo;
  }
}

static final class HalResponse {
  public final String message;

  HalResponse(String message) {
    this.message = message;
  }
}

static final Behavior&lt;HalCommand&gt; halBehavior =
    Behaviors.receive(HalCommand.class)
        .onMessage(
            OpenThePodBayDoorsPlease.class,
            (context, message) -&gt; {
              message.respondTo.tell(
                  new HalResponse(&quot;I&#39;m sorry, Dave. I&#39;m afraid I can&#39;t do that.&quot;));
              return Behaviors.same();
            })
        .build();

interface DaveProtocol {}

// this is a part of the protocol that is internal to the actor itself
private static final class AdaptedResponse implements DaveProtocol {
  public final String message;

  public AdaptedResponse(String message) {
    this.message = message;
  }
}

public static Behavior&lt;DaveProtocol&gt; daveBehavior(final ActorRef&lt;HalCommand&gt; hal) {
  return Behaviors.setup(
      (ActorContext&lt;DaveProtocol&gt; context) -&gt; {

        // asking someone requires a timeout, if the timeout hits without response
        // the ask is failed with a TimeoutException
        final Duration timeout = Duration.ofSeconds(3);

        context.ask(
            HalResponse.class,
            hal,
            timeout,
            // construct the outgoing message
            (ActorRef&lt;HalResponse&gt; ref) -&gt; new OpenThePodBayDoorsPlease(ref),
            // adapt the response (or failure to respond)
            (response, throwable) -&gt; {
              if (response != null) {
                return new AdaptedResponse(response.message);
              } else {
                return new AdaptedResponse(&quot;Request failed&quot;);
              }
            });

        // we can also tie in request context into an interaction, it is safe to look at
        // actor internal state from the transformation function, but remember that it may have
        // changed at the time the response arrives and the transformation is done, best is to
        // use immutable state we have closed over like here.
        final int requestId = 1;
        context.ask(
            HalResponse.class,
            hal,
            timeout,
            // construct the outgoing message
            (ActorRef&lt;HalResponse&gt; ref) -&gt; new OpenThePodBayDoorsPlease(ref),
            // adapt the response (or failure to respond)
            (response, throwable) -&gt; {
              if (response != null) {
                return new AdaptedResponse(requestId + &quot;: &quot; + response.message);
              } else {
                return new AdaptedResponse(requestId + &quot;: Request failed&quot;);
              }
            });

        return Behaviors.receive(DaveProtocol.class)
            // the adapted message ends up being processed like any other
            // message sent to the actor
            .onMessage(
                AdaptedResponse.class,
                (innerCtx, response) -&gt; {
                  innerCtx.getLog().info(&quot;Got response from HAL: {}&quot;, response.message);
                  return Behaviors.same();
                })
            .build();
      });
}</code></pre></dd>
</dl>
<p>The response adapting function is running in the receiving actor and can safely access state of it, but if it throws an exception the actor is stopped.</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Single response queries</li>
  <li>An actor needs to know that the message was processed before continuing</li>
  <li>To allow an actor to resend if a timely response is not produced</li>
  <li>To keep track of outstanding requests and not overwhelm a recipient with messages (&ldquo;backpressure&rdquo;)</li>
  <li>Context should be attached to the interaction but the protocol does not support that (request id, what query the response was for)</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>There can only be a single response to one <code>ask</code> (see <a href="interaction-patterns.html#per-session-child-actor">per session child Actor</a>)</li>
  <li>When <code>ask</code> times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact</li>
  <li>Finding a good value for the timeout, especially when <code>ask</code> is triggers chained <code>ask</code>s in the receiving actor. You want a short timeout to be responsive and answer back to the requester, but at the same time you do not want to have many false positives</li>
</ul>
<a id="outside-ask"></a>
<h2><a href="#request-response-with-ask-from-outside-an-actor" name="request-response-with-ask-from-outside-an-actor" class="anchor"><span class="anchor-link"></span></a>Request-Response with ask from outside an Actor</h2>
<p>Some times you need to interact with actors from outside of the actor system, this can be done with fire-and-forget as described above or through another version of <code>ask</code> that returns a <span class="group-scala"><code>Future[Response]</code></span><span class="group-java"><code>CompletionStage&lt;Response&gt;</code></span> that is either completed with a successful response or failed with a <code>TimeoutException</code> if there was no response within the specified timeout.</p>
<p>To do this we use <span class="group-scala"><code>ActorRef.ask</code> (or the symbolic <code>ActorRef.?</code>) implicitly provided by <code>akka.actor.typed.scaladsl.AskPattern</code></span><span class="group-java"><code>akka.actor.typed.javadsl.AskPattern.ask</code></span> to send a message to an actor and get a <span class="group-scala"><code>Future[Response]</code></span><span class="group-java"><code>CompletionState[Response]</code></span> back.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L351-L379" target="_blank" title="Go to snippet source"></a><code class="language-scala">trait CookieCommand {}
case class GiveMeCookies(replyTo: ActorRef[Cookies]) extends CookieCommand
case class Cookies(count: Int)

import akka.actor.typed.scaladsl.AskPattern._

// asking someone requires a timeout and a scheduler, if the timeout hits without response
// the ask is failed with a TimeoutException
implicit val timeout: Timeout = 3.seconds
implicit val scheduler = system.scheduler

val result: Future[Cookies] = cookieActorRef ? (ref ⇒ GiveMeCookies(ref))

// the response callback will be executed on this execution context
implicit val ec = system.executionContext

result.onComplete {
  case Success(cookies) ⇒ println(&quot;Yay, cookies!&quot;)
  case Failure(ex)      ⇒ println(&quot;Boo! didn&#39;t get cookies in time.&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L478-L506" target="_blank" title="Go to snippet source"></a><code class="language-java">interface CookieCommand {}

static class GiveMeCookies implements CookieCommand {
  public final ActorRef&lt;Cookies&gt; cookies;

  GiveMeCookies(ActorRef&lt;Cookies&gt; cookies) {
    this.cookies = cookies;
  }
};

static class Cookies {}

public void askAndPrint(ActorSystem&lt;Object&gt; system, ActorRef&lt;CookieCommand&gt; cookieActorRef) {
  CompletionStage&lt;Cookies&gt; result =
      AskPattern.ask(
          cookieActorRef,
          GiveMeCookies::new,
          // asking someone requires a timeout and a scheduler, if the timeout hits without
          // response
          // the ask is failed with a TimeoutException
          Duration.ofSeconds(3),
          system.scheduler());

  result.whenComplete(
      (cookies, failure) -&gt; {
        if (cookies != null) System.out.println(&quot;Yay, cookies!&quot;);
        else System.out.println(&quot;Boo! didn&#39;t get cookies in time.&quot;);
      });
}</code></pre></dd>
</dl>
<p><strong>Useful when:</strong></p>
<ul>
  <li>Querying an actor from outside of the actor system</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>It is easy to accidentally close over and unsafely mutable state with the callbacks on the returned <span class="group-scala"><code>Future</code></span><span class="group-java"><code>CompletionStage</code></span> as those will be executed on a different thread</li>
  <li>There can only be a single response to one <code>ask</code> (see <a href="interaction-patterns.html#per-session-child-actor">per session child Actor</a>)</li>
  <li>When <code>ask</code> times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact</li>
</ul>
<h2><a href="#per-session-child-actor" name="per-session-child-actor" class="anchor"><span class="anchor-link"></span></a>Per session child Actor</h2>
<p>In some cases a complete response to a request can only be created and sent back after collecting multiple answers from other actors. For these kinds of interaction it can be good to delegate the work to a per &ldquo;session&rdquo; child actor. The child could also contain arbitrary logic to implement retrying, failing on timeout, tail chopping, progress inspection etc.</p>
<p>Note that this in fact essentially how <code>ask</code> is implemented, if all you need is a single response with a timeout it is better to use <code>ask</code>.</p>
<p>The child is created with the context it needs to do the work, including an <code>ActorRef</code> that it can respond to. When the complete result is there the child responds with the result and stops itself.</p>
<p>As the protocol of the session actor is not a public API but rather an implementation detail of the parent actor, it may not always make sense to have an explicit protocol and adapt the messages of the actors that the session actor interacts with. For this use case it is possible to express that the actor can receive any message (<span class="group-scala"><code>Any</code></span><span class="group-java"><code>Object</code></span>).</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L264-L339" target="_blank" title="Go to snippet source"></a><code class="language-scala">// dummy data types just for this sample
case class Keys()
case class Wallet()

// messages for the two services we interact with
trait HomeCommand
case class LeaveHome(who: String, respondTo: ActorRef[ReadyToLeaveHome]) extends HomeCommand
case class ReadyToLeaveHome(who: String, keys: Keys, wallet: Wallet)

case class GetKeys(whoseKeys: String, respondTo: ActorRef[Keys])
case class GetWallet(whoseWallet: String, respondTo: ActorRef[Wallet])

def homeBehavior = Behaviors.receive[HomeCommand] { (context, message) ⇒
  val keyCabinet: ActorRef[GetKeys] = context.spawn(keyCabinetBehavior, &quot;key-cabinet&quot;)
  val drawer: ActorRef[GetWallet] = context.spawn(drawerBehavior, &quot;drawer&quot;)

  message match {
    case LeaveHome(who, respondTo) ⇒
      context.spawn(prepareToLeaveHome(who, respondTo, keyCabinet, drawer), s&quot;leaving-$who&quot;)
      Behavior.same
  }
}

// per session actor behavior
def prepareToLeaveHome(
  whoIsLeaving: String,
  respondTo:    ActorRef[ReadyToLeaveHome],
  keyCabinet:   ActorRef[GetKeys],
  drawer:       ActorRef[GetWallet]): Behavior[NotUsed] =
  // we don&#39;t _really_ care about the actor protocol here as nobody will send us
  // messages except for responses to our queries, so we just accept any kind of message
  // but narrow that to more limited types then we interact
  Behaviors.setup[AnyRef] { context ⇒
    var wallet: Option[Wallet] = None
    var keys: Option[Keys] = None

    // we narrow the ActorRef type to any subtype of the actual type we accept
    keyCabinet ! GetKeys(whoIsLeaving, context.self.narrow[Keys])
    drawer ! GetWallet(whoIsLeaving, context.self.narrow[Wallet])

    def nextBehavior: Behavior[AnyRef] =
      (keys, wallet) match {
        case (Some(w), Some(k)) ⇒
          // we got both, &quot;session&quot; is completed!
          respondTo ! ReadyToLeaveHome(whoIsLeaving, w, k)
          Behavior.stopped

        case _ ⇒
          Behavior.same
      }

    Behaviors.receiveMessage {
      case w: Wallet ⇒
        wallet = Some(w)
        nextBehavior
      case k: Keys ⇒
        keys = Some(k)
        nextBehavior
      case _ ⇒
        Behaviors.unhandled
    }
  }.narrow[NotUsed] // we don&#39;t let anyone else know we accept anything</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L510-L630" target="_blank" title="Go to snippet source"></a><code class="language-java">// dummy data types just for this sample
interface Keys {}

interface Wallet {}
// messages for the two services we interact with
class GetKeys {
  public final String whoseKeys;
  public final ActorRef&lt;Keys&gt; respondTo;

  public GetKeys(String whoseKeys, ActorRef&lt;Keys&gt; respondTo) {
    this.whoseKeys = whoseKeys;
    this.respondTo = respondTo;
  }
}

class GetWallet {
  public final String whoseWallet;
  public final ActorRef&lt;Wallet&gt; respondTo;

  public GetWallet(String whoseWallet, ActorRef&lt;Wallet&gt; respondTo) {
    this.whoseWallet = whoseWallet;
    this.respondTo = respondTo;
  }
}

interface HomeCommand {}

class LeaveHome implements HomeCommand {
  public final String who;
  public final ActorRef&lt;ReadyToLeaveHome&gt; respondTo;

  public LeaveHome(String who, ActorRef&lt;ReadyToLeaveHome&gt; respondTo) {
    this.who = who;
    this.respondTo = respondTo;
  }
}

class ReadyToLeaveHome {
  public final String who;
  public final Keys keys;
  public final Wallet wallet;

  public ReadyToLeaveHome(String who, Keys keys, Wallet wallet) {
    this.who = who;
    this.keys = keys;
    this.wallet = wallet;
  }
}

// actor behavior
public Behavior&lt;HomeCommand&gt; homeBehavior() {
  return Behaviors.setup(
      (context) -&gt; {
        final ActorRef&lt;GetKeys&gt; keyCabinet = context.spawn(keyCabinetBehavior, &quot;key-cabinet&quot;);
        final ActorRef&lt;GetWallet&gt; drawer = context.spawn(drawerBehavior, &quot;drawer&quot;);

        return Behaviors.receive(HomeCommand.class)
            .onMessage(
                LeaveHome.class,
                (innerCtx, message) -&gt; {
                  context.spawn(
                      new PrepareToLeaveHome(message.who, message.respondTo, keyCabinet, drawer),
                      &quot;leaving&quot; + message.who);
                  return Behavior.same();
                })
            .build();
      });
}

// per session actor behavior
class PrepareToLeaveHome extends AbstractBehavior&lt;Object&gt; {
  private final String whoIsLeaving;
  private final ActorRef&lt;ReadyToLeaveHome&gt; respondTo;
  private final ActorRef&lt;GetKeys&gt; keyCabinet;
  private final ActorRef&lt;GetWallet&gt; drawer;
  private Optional&lt;Wallet&gt; wallet = Optional.empty();
  private Optional&lt;Keys&gt; keys = Optional.empty();

  public PrepareToLeaveHome(
      String whoIsLeaving,
      ActorRef&lt;ReadyToLeaveHome&gt; respondTo,
      ActorRef&lt;GetKeys&gt; keyCabinet,
      ActorRef&lt;GetWallet&gt; drawer) {
    this.whoIsLeaving = whoIsLeaving;
    this.respondTo = respondTo;
    this.keyCabinet = keyCabinet;
    this.drawer = drawer;
  }

  @Override
  public Receive&lt;Object&gt; createReceive() {
    return receiveBuilder()
        .onMessage(
            Wallet.class,
            (wallet) -&gt; {
              this.wallet = Optional.of(wallet);
              return completeOrContinue();
            })
        .onMessage(
            Keys.class,
            (keys) -&gt; {
              this.keys = Optional.of(keys);
              return completeOrContinue();
            })
        .build();
  }

  private Behavior&lt;Object&gt; completeOrContinue() {
    if (wallet.isPresent() &amp;&amp; keys.isPresent()) {
      respondTo.tell(new ReadyToLeaveHome(whoIsLeaving, keys.get(), wallet.get()));
      return Behaviors.stopped();
    } else {
      return this;
    }
  }
}</code></pre></dd>
</dl>
<p>In an actual session child you would likely want to include some form of timeout as well (see <a href="interaction-patterns.html#scheduling-messages-to-self">scheduling messages to self</a>).</p>
<p><strong>Useful when:</strong></p>
<ul>
  <li>A single incoming request should result in multiple interactions with other actors before a result can be built,  for example aggregation of several results</li>
  <li>You need to handle acknowledgement and retry messages for at-least-once delivery</li>
</ul>
<p><strong>Problems:</strong></p>
<ul>
  <li>Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped</li>
  <li>It increases complexity, since each such child can execute concurrently with other children and the parent</li>
</ul>
<h2><a href="#scheduling-messages-to-self" name="scheduling-messages-to-self" class="anchor"><span class="anchor-link"></span></a>Scheduling messages to self</h2>
<p>The following example demonstrates how to use timers to schedule messages to an actor. </p>
<p>The <code>Buncher</code> actor buffers a burst of incoming messages and delivers them as a batch after a timeout or when the number of batched messages exceeds a maximum size.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala#L158-L192" target="_blank" title="Go to snippet source"></a><code class="language-scala">case object TimerKey

trait Msg
case class ExcitingMessage(message: String) extends Msg
final case class Batch(messages: Vector[Msg])
case object Timeout extends Msg

def behavior(target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
  Behaviors.withTimers(timers ⇒ idle(timers, target, after, maxSize))
}

def idle(timers: TimerScheduler[Msg], target: ActorRef[Batch],
         after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
  Behaviors.receiveMessage[Msg] { message ⇒
    timers.startSingleTimer(TimerKey, Timeout, after)
    active(Vector(message), timers, target, after, maxSize)
  }
}

def active(buffer: Vector[Msg], timers: TimerScheduler[Msg],
           target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
  Behaviors.receiveMessage[Msg] {
    case Timeout ⇒
      target ! Batch(buffer)
      idle(timers, target, after, maxSize)
    case m ⇒
      val newBuffer = buffer :+ m
      if (newBuffer.size == maxSize) {
        timers.cancel(TimerKey)
        target ! Batch(newBuffer)
        idle(timers, target, after, maxSize)
      } else
        active(newBuffer, timers, target, after, maxSize)
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java#L269-L352" target="_blank" title="Go to snippet source"></a><code class="language-java">interface Msg {}

public static final class Batch {
  private final List&lt;Msg&gt; messages;

  public Batch(List&lt;Msg&gt; messages) {
    this.messages = Collections.unmodifiableList(messages);
  }

  public List&lt;Msg&gt; getMessages() {
    return messages;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Batch batch = (Batch) o;
    return Objects.equals(messages, batch.messages);
  }

  @Override
  public int hashCode() {
    return Objects.hash(messages);
  }
}

public static final class ExcitingMessage implements Msg {
  private final String message;

  public ExcitingMessage(String message) {
    this.message = message;
  }
}

private static final Object TIMER_KEY = new Object();

private static class TimeoutMsg implements Msg {}

public static Behavior&lt;Msg&gt; behavior(ActorRef&lt;Batch&gt; target, Duration after, int maxSize) {
  return Behaviors.withTimers(timers -&gt; idle(timers, target, after, maxSize));
}

private static Behavior&lt;Msg&gt; idle(
    TimerScheduler&lt;Msg&gt; timers, ActorRef&lt;Batch&gt; target, Duration after, int maxSize) {
  return Behaviors.receive(Msg.class)
      .onMessage(
          Msg.class,
          (context, message) -&gt; {
            timers.startSingleTimer(TIMER_KEY, new TimeoutMsg(), after);
            List&lt;Msg&gt; buffer = new ArrayList&lt;&gt;();
            buffer.add(message);
            return active(buffer, timers, target, after, maxSize);
          })
      .build();
}

private static Behavior&lt;Msg&gt; active(
    List&lt;Msg&gt; buffer,
    TimerScheduler&lt;Msg&gt; timers,
    ActorRef&lt;Batch&gt; target,
    Duration after,
    int maxSize) {
  return Behaviors.receive(Msg.class)
      .onMessage(
          TimeoutMsg.class,
          (context, message) -&gt; {
            target.tell(new Batch(buffer));
            return idle(timers, target, after, maxSize);
          })
      .onMessage(
          Msg.class,
          (context, message) -&gt; {
            buffer.add(message);
            if (buffer.size() == maxSize) {
              timers.cancel(TIMER_KEY);
              target.tell(new Batch(buffer));
              return idle(timers, target, after, maxSize);
            } else {
              return active(buffer, timers, target, after, maxSize);
            }
          })
      .build();
}</code></pre></dd>
</dl>
<p>There are a few things worth noting here:</p>
<ul>
  <li>To get access to the timers you start with <code>Behaviors.withTimers</code> that will pass a <code>TimerScheduler</code> instance to the function. This can be used with any type of <code>Behavior</code>, including <code>receive</code>, <code>receiveMessage</code>, but also <code>setup</code> or any other behavior.</li>
  <li>Each timer has a key and if a new timer with same key is started the previous is cancelled and it&rsquo;s guaranteed that a message from the previous timer is not received, even though it might already be enqueued in the mailbox when the new timer is started.</li>
  <li>Both periodic and single message timers are supported.</li>
  <li>The <code>TimerScheduler</code> is mutable in itself, because it performs and manages the side effects of registering the scheduled tasks.</li>
  <li>The <code>TimerScheduler</code> is bound to the lifecycle of the actor that owns it and it&rsquo;s cancelled automatically when the actor is stopped.</li>
  <li><code>Behaviors.withTimers</code> can also be used inside <code>Behaviors.supervise</code> and it will automatically cancel the started timers correctly when the actor is restarted, so that the new incarnation will not receive scheduled messages from previous incarnation.</li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../typed/actor-lifecycle.html"><i class="icon-prev"></i> <span class="link-prev">Actor lifecycle</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../typed/fault-tolerance.html">Fault Tolerance <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/typed/interaction-patterns.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../assets/js/scalafiddle.js"></script>


</body>
</html>
