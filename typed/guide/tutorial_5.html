<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 5: Querying Device Groups &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/typed/guide/tutorial_5.html"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>
<link rel="shortcut icon" href="../../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
<link rel="manifest" href="../../images/manifest.json">
<meta name="msapplication-TileImage" content="../../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../index-actors.html" class="page">Actors</a></li>
  <li><a href="../../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../../typed/guide/index.html" class="page">Getting Started Guide</a>
    <ul>
      <li><a href="../../typed/guide/introduction.html" class="page">Introduction to Akka</a></li>
      <li><a href="../../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
      <li><a href="../../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
      <li><a href="../../typed/guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
      <li><a href="../../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
      <li><a href="../../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
      <li><a href="../../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
      <li><a href="../../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
      <li><a href="../../typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
      <li><a href="../../typed/guide/tutorial_5.html#part-5-querying-device-groups" class="active page">Part 5: Querying Device Groups</a>
      <ul>
        <li><a href="../../typed/guide/tutorial_5.html#introduction" class="header">Introduction</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#dealing-with-possible-scenarios" class="header">Dealing with possible scenarios</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#implementing-the-query" class="header">Implementing the query</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#adding-query-capability-to-the-group" class="header">Adding query capability to the group</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#summary" class="header">Summary</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#whats-next-" class="header">What&rsquo;s Next?</a></li>
      </ul></li>
    </ul></li>
    <li><a href="../../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../../stream/index.html" class="page">Streams</a></li>
  <li><a href="../../index-network.html" class="page">Networking</a></li>
  <li><a href="../../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../project/index.html" class="page">Project Information</a></li>
  <li><a href="../../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../index-actors.html" class="page">Actors</a></li>
  <li><a href="../../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../../typed/guide/index.html" class="page">Getting Started Guide</a>
    <ul>
      <li><a href="../../typed/guide/introduction.html" class="page">Introduction to Akka</a></li>
      <li><a href="../../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
      <li><a href="../../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
      <li><a href="../../typed/guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
      <li><a href="../../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
      <li><a href="../../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
      <li><a href="../../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
      <li><a href="../../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
      <li><a href="../../typed/guide/tutorial_4.html" class="page">Part 4: Working with Device Groups</a></li>
      <li><a href="../../typed/guide/tutorial_5.html#part-5-querying-device-groups" class="active page">Part 5: Querying Device Groups</a>
      <ul>
        <li><a href="../../typed/guide/tutorial_5.html#introduction" class="header">Introduction</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#dealing-with-possible-scenarios" class="header">Dealing with possible scenarios</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#implementing-the-query" class="header">Implementing the query</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#adding-query-capability-to-the-group" class="header">Adding query capability to the group</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#summary" class="header">Summary</a></li>
        <li><a href="../../typed/guide/tutorial_5.html#whats-next-" class="header">What&rsquo;s Next?</a></li>
      </ul></li>
    </ul></li>
    <li><a href="../../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../../stream/index.html" class="page">Streams</a></li>
  <li><a href="../../index-network.html" class="page">Networking</a></li>
  <li><a href="../../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../project/index.html" class="page">Project Information</a></li>
  <li><a href="../../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-5-querying-device-groups" name="part-5-querying-device-groups" class="anchor"><span class="anchor-link"></span></a>Part 5: Querying Device Groups</h1>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../../common/may-change.html">may change</a> in the sense  of being the subject of final development. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet.</p></div>
<p>The conversational patterns that we have seen so far are simple in the sense that they require the actor to keep little or no state. Specifically:</p>
<ul>
  <li>Device actors return a reading, which requires no state change</li>
  <li>Record a temperature, which updates a single field</li>
  <li>Device Group actors maintain group membership by adding or removing entries from a map</li>
</ul>
<p>In this part, we will use a more complex example. Since homeowners will be interested in the temperatures throughout their home, our goal is to be able to query all of the device actors in a group. Let us start by investigating how such a query API should behave.</p>
<h2><a href="#dealing-with-possible-scenarios" name="dealing-with-possible-scenarios" class="anchor"><span class="anchor-link"></span></a>Dealing with possible scenarios</h2>
<p>The very first issue we face is that the membership of a group is dynamic. Each sensor device is represented by an actor that can stop at any time. At the beginning of the query, we can ask all of the existing device actors for the current temperature. However, during the lifecycle of the query:</p>
<ul>
  <li>A device actor might stop and not be able to respond back with a temperature reading.</li>
  <li>A new device actor might start up and not be included in the query because we weren&rsquo;t aware of it.</li>
</ul>
<p>These issues can be addressed in many different ways, but the important point is to settle on the desired behavior. The following works well for our use case:</p>
<ul>
  <li>When a query arrives, the group actor takes a <em>snapshot</em> of the existing device actors and will only ask those actors for the temperature.</li>
  <li>Actors that start up <em>after</em> the query arrives are ignored.</li>
  <li>If an actor in the snapshot stops during the query without answering, we will report the fact that it stopped to the sender of the query message.</li>
</ul>
<p>Apart from device actors coming and going dynamically, some actors might take a long time to answer. For example, they could be stuck in an accidental infinite loop, or fail due to a bug and drop our request. We don&rsquo;t want the query to continue indefinitely, so we will consider it complete in either of the following cases:</p>
<ul>
  <li>All actors in the snapshot have either responded or have confirmed being stopped.</li>
  <li>We reach a pre-defined deadline.</li>
</ul>
<p>Given these decisions, along with the fact that a device in the snapshot might have just started and not yet received a temperature to record, we can define four states for each device actor, with respect to a temperature query:</p>
<ul>
  <li>It has a temperature available: <code>Temperature</code>.</li>
  <li>It has responded, but has no temperature available yet: <code>TemperatureNotAvailable</code>.</li>
  <li>It has stopped before answering: <code>DeviceNotAvailable</code>.</li>
  <li>It did not respond before the deadline: <code>DeviceTimedOut</code>.</li>
</ul>
<p>Summarizing these in message types we can add the following to the message protocol:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceManager.scala#L39-L50" target="_blank" title="Go to snippet source"></a><code class="language-scala">import DeviceGroupQuery.DeviceGroupQueryMessage

final case class RequestAllTemperatures(requestId: Long, groupId: String, replyTo: ActorRef[RespondAllTemperatures])
  extends DeviceGroupQueryMessage with DeviceGroupMessage with DeviceManagerMessage

final case class RespondAllTemperatures(requestId: Long, temperatures: Map[String, TemperatureReading])

sealed trait TemperatureReading
final case class Temperature(value: Double) extends TemperatureReading
case object TemperatureNotAvailable extends TemperatureReading
case object DeviceNotAvailable extends TemperatureReading
case object DeviceTimedOut extends TemperatureReading</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceManagerProtocol.java#L63-L131" target="_blank" title="Go to snippet source"></a><code class="language-java">interface DeviceGroupQueryMessage {}

public static final class RequestAllTemperatures
    implements DeviceGroupQueryMessage, DeviceGroupMessage, DeviceManagerMessage {

  final long requestId;
  final String groupId;
  final ActorRef&lt;RespondAllTemperatures&gt; replyTo;

  public RequestAllTemperatures(
      long requestId, String groupId, ActorRef&lt;RespondAllTemperatures&gt; replyTo) {
    this.requestId = requestId;
    this.groupId = groupId;
    this.replyTo = replyTo;
  }
}

public static final class RespondAllTemperatures {
  final long requestId;
  final Map&lt;String, TemperatureReading&gt; temperatures;

  public RespondAllTemperatures(long requestId, Map&lt;String, TemperatureReading&gt; temperatures) {
    this.requestId = requestId;
    this.temperatures = temperatures;
  }
}

public static interface TemperatureReading {}

public static final class Temperature implements TemperatureReading {
  public final double value;

  public Temperature(double value) {
    this.value = value;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Temperature that = (Temperature) o;

    return Double.compare(that.value, value) == 0;
  }

  @Override
  public int hashCode() {
    long temp = Double.doubleToLongBits(value);
    return (int) (temp ^ (temp &gt;&gt;&gt; 32));
  }

  @Override
  public String toString() {
    return &quot;Temperature{&quot; + &quot;value=&quot; + value + &#39;}&#39;;
  }
}

public enum TemperatureNotAvailable implements TemperatureReading {
  INSTANCE
}

public enum DeviceNotAvailable implements TemperatureReading {
  INSTANCE
}

public enum DeviceTimedOut implements TemperatureReading {
  INSTANCE
}</code></pre></dd>
</dl>
<h2><a href="#implementing-the-query" name="implementing-the-query" class="anchor"><span class="anchor-link"></span></a>Implementing the query</h2>
<p>One approach for implementing the query involves adding code to the group device actor. However, in practice this can be very cumbersome and error prone. Remember that when we start a query, we need to take a snapshot of the devices present and start a timer so that we can enforce the deadline. In the meantime, <em>another query</em> can arrive. For the second query we need to keep track of the exact same information but in isolation from the previous query. This would require us to maintain separate mappings between queries and device actors.</p>
<p>Instead, we will implement a simpler, and superior approach. We will create an actor that represents a <em>single query</em> and that performs the tasks needed to complete the query on behalf of the group actor. So far we have created actors that belonged to classical domain objects, but now, we will create an actor that represents a process or a task rather than an entity. We benefit by keeping our group device actor simple and being able to better test query capability in isolation.</p>
<h3><a href="#defining-the-query-actor" name="defining-the-query-actor" class="anchor"><span class="anchor-link"></span></a>Defining the query actor</h3>
<p>First, we need to design the lifecycle of our query actor. This consists of identifying its initial state, the first action it will take, and the cleanup &#8212; if necessary. The query actor will need the following information:</p>
<ul>
  <li>The snapshot and IDs of active device actors to query.</li>
  <li>The ID of the request that started the query (so that we can include it in the reply).</li>
  <li>The reference of the actor who sent the query. We will send the reply to this actor directly.</li>
  <li>A deadline that indicates how long the query should wait for replies. Making this a parameter will simplify testing.</li>
</ul>
<h4><a href="#scheduling-the-query-timeout" name="scheduling-the-query-timeout" class="anchor"><span class="anchor-link"></span></a>Scheduling the query timeout</h4>
<p>Since we need a way to indicate how long we are willing to wait for responses, it is time to introduce a new Akka feature that we have not used yet, the built-in scheduler facility. Using <code>Behaviors.withTimers</code> and <code>startSingleTimer</code> to schedule a message that will be sent after a given delay.</p>
<p>We need to create a message that represents the query timeout. We create a simple message <code>CollectionTimeout</code> without any parameters for this purpose.</p>
<p>At the start of the query, we need to ask each of the device actors for the current temperature. To be able to quickly detect devices that stopped before they got the <code>ReadTemperature</code> message we will also watch each of the actors. This way, we get <code>DeviceTerminated</code> messages for those that stop during the lifetime of the query, so we don&rsquo;t need to wait until the timeout to mark these as not available.</p>
<p>Putting this together, the outline of our <code>DeviceGroupQuery</code> actor looks like this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuery.scala#L27-L127" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroupQuery {

  def apply(
    deviceIdToActor: Map[String, ActorRef[Device.DeviceMessage]],
    requestId:       Long,
    requester:       ActorRef[RespondAllTemperatures],
    timeout:         FiniteDuration
  ): Behavior[DeviceGroupQueryMessage] = {
    Behaviors.setup { context ⇒
      Behaviors.withTimers { timers ⇒
        new DeviceGroupQuery(deviceIdToActor, requestId, requester, timeout, context, timers)
      }
    }
  }

  trait DeviceGroupQueryMessage

  private case object CollectionTimeout extends DeviceGroupQueryMessage

  final case class WrappedRespondTemperature(response: RespondTemperature) extends DeviceGroupQueryMessage

  private final case class DeviceTerminated(deviceId: String) extends DeviceGroupQueryMessage
}

class DeviceGroupQuery(
  deviceIdToActor: Map[String, ActorRef[DeviceMessage]],
  requestId:       Long,
  requester:       ActorRef[RespondAllTemperatures],
  timeout:         FiniteDuration,
  context:         ActorContext[DeviceGroupQuery.DeviceGroupQueryMessage],
  timers:          TimerScheduler[DeviceGroupQuery.DeviceGroupQueryMessage])
  extends AbstractBehavior[DeviceGroupQuery.DeviceGroupQueryMessage] {

  import DeviceGroupQuery._
  timers.startSingleTimer(CollectionTimeout, CollectionTimeout, timeout)

  private val respondTemperatureAdapter = context.messageAdapter(WrappedRespondTemperature.apply)


  deviceIdToActor.foreach {
    case (deviceId, device) ⇒
      context.watchWith(device, DeviceTerminated(deviceId))
      device ! ReadTemperature(0, respondTemperatureAdapter)
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQuery.java#L25-L148" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroupQuery extends AbstractBehavior&lt;DeviceGroupQueryMessage&gt; {

  public static Behavior&lt;DeviceGroupQueryMessage&gt; createBehavior(
      Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor,
      long requestId,
      ActorRef&lt;RespondAllTemperatures&gt; requester,
      Duration timeout) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(
                timers -&gt;
                    new DeviceGroupQuery(
                        deviceIdToActor, requestId, requester, timeout, context, timers)));
  }

  private static enum CollectionTimeout implements DeviceGroupQueryMessage {
    INSTANCE
  }

  static class WrappedRespondTemperature implements DeviceGroupQueryMessage {
    final DeviceProtocol.RespondTemperature response;

    WrappedRespondTemperature(DeviceProtocol.RespondTemperature response) {
      this.response = response;
    }
  }

  private static class DeviceTerminated implements DeviceGroupQueryMessage {
    final String deviceId;

    private DeviceTerminated(String deviceId) {
      this.deviceId = deviceId;
    }
  }

  private final long requestId;
  private final ActorRef&lt;RespondAllTemperatures&gt; requester;

  public DeviceGroupQuery(
      Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor,
      long requestId,
      ActorRef&lt;RespondAllTemperatures&gt; requester,
      Duration timeout,
      ActorContext&lt;DeviceGroupQueryMessage&gt; context,
      TimerScheduler&lt;DeviceGroupQueryMessage&gt; timers) {
    this.requestId = requestId;
    this.requester = requester;

    timers.startSingleTimer(CollectionTimeout.class, CollectionTimeout.INSTANCE, timeout);

    ActorRef&lt;DeviceProtocol.RespondTemperature&gt; respondTemperatureAdapter =
        context.messageAdapter(
            DeviceProtocol.RespondTemperature.class, WrappedRespondTemperature::new);

    for (Map.Entry&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; entry :
        deviceIdToActor.entrySet()) {
      context.watchWith(entry.getValue(), new DeviceTerminated(entry.getKey()));
      entry.getValue().tell(new DeviceProtocol.ReadTemperature(0L, respondTemperatureAdapter));
    }
    stillWaiting = new HashSet&lt;&gt;(deviceIdToActor.keySet());
  }


}</code></pre></dd>
</dl>
<p>Note that we have to convert the <code>RespondTemperature</code> replies from the device actor to the message protocol that the <code>DeviceGroupQuery</code> actor understands, i.e. <code>DeviceGroupQueryMessage</code>. For this we use a <code>messageAdapter</code> that wraps the <code>RespondTemperature</code> in a <code>WrappedRespondTemperature</code>, which <span class="group-scala">extends</span><span class="group-java">implements</span> <code>DeviceGroupQueryMessage</code>.</p>
<h4><a href="#tracking-actor-state" name="tracking-actor-state" class="anchor"><span class="anchor-link"></span></a>Tracking actor state</h4>
<p>The query actor, apart from the pending timer, has one stateful aspect, tracking the set of actors that: have replied, have stopped, or have not replied. We track this state <span class="group-scala">in a <code>var</code> field of an immutable <code>Map</code></span><span class="group-java">in a mutable <code>HashMap</code></span> in the actor.</p>
<p>For our use case:</p>
<ol>
  <li>We keep track state with:
    <ul>
      <li>a <code>Map</code> of already received replies</li>
      <li>a <code>Set</code> of actors that we still wait on</li>
    </ul>
  </li>
  <li>We have three events to act on:
    <ul>
      <li>We can receive a <code>RespondTemperature</code> message from one of the devices.</li>
      <li>We can receive a <code>DeviceTerminated</code> message for a device actor that has been stopped in the meantime.</li>
      <li>We can reach the deadline and receive a <code>CollectionTimeout</code>.</li>
    </ul>
  </li>
</ol>
<p>To accomplish this, add the following to your <code>DeviceGroupQuery</code> source file:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuery.scala#L67-L113" target="_blank" title="Go to snippet source"></a><code class="language-scala">private var repliesSoFar = Map.empty[String, TemperatureReading]
private var stillWaiting = deviceIdToActor.keySet

override def onMessage(msg: DeviceGroupQueryMessage): Behavior[DeviceGroupQueryMessage] =
  msg match {
    case WrappedRespondTemperature(response) ⇒ onRespondTemperature(response)
    case DeviceTerminated(deviceId)          ⇒ onDeviceTerminated(deviceId)
    case CollectionTimeout                   ⇒ onCollectionTimout()
  }

private def onRespondTemperature(response: RespondTemperature): Behavior[DeviceGroupQueryMessage] = {
  val reading = response.value match {
    case Some(value) ⇒ Temperature(value)
    case None        ⇒ TemperatureNotAvailable
  }

  val deviceId = response.deviceId
  repliesSoFar += (deviceId -&gt; reading)
  stillWaiting -= deviceId

  respondWhenAllCollected()
}

private def onDeviceTerminated(deviceId: String): Behavior[DeviceGroupQueryMessage] = {
  if (stillWaiting(deviceId)) {
    repliesSoFar += (deviceId -&gt; DeviceNotAvailable)
    stillWaiting -= deviceId
  }
  respondWhenAllCollected()
}

private def onCollectionTimout(): Behavior[DeviceGroupQueryMessage] = {
  repliesSoFar ++= stillWaiting.map(deviceId ⇒ deviceId -&gt; DeviceTimedOut)
  stillWaiting = Set.empty
  respondWhenAllCollected()
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQuery.java#L64-L133" target="_blank" title="Go to snippet source"></a><code class="language-java">private Map&lt;String, TemperatureReading&gt; repliesSoFar = new HashMap&lt;&gt;();
private final Set&lt;String&gt; stillWaiting;

@Override
public Receive&lt;DeviceGroupQueryMessage&gt; createReceive() {
  return receiveBuilder()
      .onMessage(WrappedRespondTemperature.class, this::onRespondTemperature)
      .onMessage(DeviceTerminated.class, this::onDeviceTerminated)
      .onMessage(CollectionTimeout.class, this::onCollectionTimeout)
      .build();
}

private Behavior&lt;DeviceGroupQueryMessage&gt; onRespondTemperature(WrappedRespondTemperature r) {
  TemperatureReading reading =
      r.response
          .value
          .map(v -&gt; (TemperatureReading) new Temperature(v))
          .orElse(TemperatureNotAvailable.INSTANCE);

  String deviceId = r.response.deviceId;
  repliesSoFar.put(deviceId, reading);
  stillWaiting.remove(deviceId);

  return respondWhenAllCollected();
}

private Behavior&lt;DeviceGroupQueryMessage&gt; onDeviceTerminated(DeviceTerminated terminated) {
  if (stillWaiting.contains(terminated.deviceId)) {
    repliesSoFar.put(terminated.deviceId, DeviceNotAvailable.INSTANCE);
    stillWaiting.remove(terminated.deviceId);
  }
  return respondWhenAllCollected();
}

private Behavior&lt;DeviceGroupQueryMessage&gt; onCollectionTimeout(CollectionTimeout timeout) {
  for (String deviceId : stillWaiting) {
    repliesSoFar.put(deviceId, DeviceTimedOut.INSTANCE);
  }
  stillWaiting.clear();
  return respondWhenAllCollected();
}</code></pre></dd>
</dl>
<p>For <code>RespondTemperature</code> and <code>DeviceTerminated</code> we keep track of the replies by updating <code>repliesSoFar</code> and remove the actor from <code>stillWaiting</code>, and then delegate to a method <code>respondWhenAllCollected</code>, which we will discuss soon.</p>
<p>In the case of timeout, we need to take all the actors that have not yet replied (the members of the set <code>stillWaiting</code>) and put a <code>DeviceTimedOut</code> as the status in the final reply.</p>
<p>We now have to figure out what to do in <code>respondWhenAllCollected</code>. First, we need to record the new result in the map <code>repliesSoFar</code> and remove the actor from <code>stillWaiting</code>. The next step is to check if there are any remaining actors we are waiting for. If there is none, we send the result of the query to the original requester and stop the query actor. Otherwise, we need to update the <code>repliesSoFar</code> and <code>stillWaiting</code> structures and wait for more messages.</p>
<p>With all this knowledge, we can create the <code>respondWhenAllCollected</code> method:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuery.scala#L117-L124" target="_blank" title="Go to snippet source"></a><code class="language-scala">private def respondWhenAllCollected(): Behavior[DeviceGroupQueryMessage] = {
  if (stillWaiting.isEmpty) {
    requester ! RespondAllTemperatures(requestId, repliesSoFar)
    Behaviors.stopped
  } else {
    this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQuery.java#L137-L144" target="_blank" title="Go to snippet source"></a><code class="language-java">private Behavior&lt;DeviceGroupQueryMessage&gt; respondWhenAllCollected() {
  if (stillWaiting.isEmpty()) {
    requester.tell(new RespondAllTemperatures(requestId, repliesSoFar));
    return Behaviors.stopped();
  } else {
    return this;
  }
}</code></pre></dd>
</dl>
<p>Our query actor is now done:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuery.scala#L27-L127" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroupQuery {

  def apply(
    deviceIdToActor: Map[String, ActorRef[Device.DeviceMessage]],
    requestId:       Long,
    requester:       ActorRef[RespondAllTemperatures],
    timeout:         FiniteDuration
  ): Behavior[DeviceGroupQueryMessage] = {
    Behaviors.setup { context ⇒
      Behaviors.withTimers { timers ⇒
        new DeviceGroupQuery(deviceIdToActor, requestId, requester, timeout, context, timers)
      }
    }
  }

  trait DeviceGroupQueryMessage

  private case object CollectionTimeout extends DeviceGroupQueryMessage

  final case class WrappedRespondTemperature(response: RespondTemperature) extends DeviceGroupQueryMessage

  private final case class DeviceTerminated(deviceId: String) extends DeviceGroupQueryMessage
}

class DeviceGroupQuery(
  deviceIdToActor: Map[String, ActorRef[DeviceMessage]],
  requestId:       Long,
  requester:       ActorRef[RespondAllTemperatures],
  timeout:         FiniteDuration,
  context:         ActorContext[DeviceGroupQuery.DeviceGroupQueryMessage],
  timers:          TimerScheduler[DeviceGroupQuery.DeviceGroupQueryMessage])
  extends AbstractBehavior[DeviceGroupQuery.DeviceGroupQueryMessage] {

  import DeviceGroupQuery._
  timers.startSingleTimer(CollectionTimeout, CollectionTimeout, timeout)

  private val respondTemperatureAdapter = context.messageAdapter(WrappedRespondTemperature.apply)

  private var repliesSoFar = Map.empty[String, TemperatureReading]
  private var stillWaiting = deviceIdToActor.keySet


  deviceIdToActor.foreach {
    case (deviceId, device) ⇒
      context.watchWith(device, DeviceTerminated(deviceId))
      device ! ReadTemperature(0, respondTemperatureAdapter)
  }

  override def onMessage(msg: DeviceGroupQueryMessage): Behavior[DeviceGroupQueryMessage] =
    msg match {
      case WrappedRespondTemperature(response) ⇒ onRespondTemperature(response)
      case DeviceTerminated(deviceId)          ⇒ onDeviceTerminated(deviceId)
      case CollectionTimeout                   ⇒ onCollectionTimout()
    }

  private def onRespondTemperature(response: RespondTemperature): Behavior[DeviceGroupQueryMessage] = {
    val reading = response.value match {
      case Some(value) ⇒ Temperature(value)
      case None        ⇒ TemperatureNotAvailable
    }

    val deviceId = response.deviceId
    repliesSoFar += (deviceId -&gt; reading)
    stillWaiting -= deviceId

    respondWhenAllCollected()
  }

  private def onDeviceTerminated(deviceId: String): Behavior[DeviceGroupQueryMessage] = {
    if (stillWaiting(deviceId)) {
      repliesSoFar += (deviceId -&gt; DeviceNotAvailable)
      stillWaiting -= deviceId
    }
    respondWhenAllCollected()
  }

  private def onCollectionTimout(): Behavior[DeviceGroupQueryMessage] = {
    repliesSoFar ++= stillWaiting.map(deviceId ⇒ deviceId -&gt; DeviceTimedOut)
    stillWaiting = Set.empty
    respondWhenAllCollected()
  }

  private def respondWhenAllCollected(): Behavior[DeviceGroupQueryMessage] = {
    if (stillWaiting.isEmpty) {
      requester ! RespondAllTemperatures(requestId, repliesSoFar)
      Behaviors.stopped
    } else {
      this
    }
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQuery.java#L25-L148" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroupQuery extends AbstractBehavior&lt;DeviceGroupQueryMessage&gt; {

  public static Behavior&lt;DeviceGroupQueryMessage&gt; createBehavior(
      Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor,
      long requestId,
      ActorRef&lt;RespondAllTemperatures&gt; requester,
      Duration timeout) {
    return Behaviors.setup(
        context -&gt;
            Behaviors.withTimers(
                timers -&gt;
                    new DeviceGroupQuery(
                        deviceIdToActor, requestId, requester, timeout, context, timers)));
  }

  private static enum CollectionTimeout implements DeviceGroupQueryMessage {
    INSTANCE
  }

  static class WrappedRespondTemperature implements DeviceGroupQueryMessage {
    final DeviceProtocol.RespondTemperature response;

    WrappedRespondTemperature(DeviceProtocol.RespondTemperature response) {
      this.response = response;
    }
  }

  private static class DeviceTerminated implements DeviceGroupQueryMessage {
    final String deviceId;

    private DeviceTerminated(String deviceId) {
      this.deviceId = deviceId;
    }
  }

  private final long requestId;
  private final ActorRef&lt;RespondAllTemperatures&gt; requester;
  private Map&lt;String, TemperatureReading&gt; repliesSoFar = new HashMap&lt;&gt;();
  private final Set&lt;String&gt; stillWaiting;


  public DeviceGroupQuery(
      Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor,
      long requestId,
      ActorRef&lt;RespondAllTemperatures&gt; requester,
      Duration timeout,
      ActorContext&lt;DeviceGroupQueryMessage&gt; context,
      TimerScheduler&lt;DeviceGroupQueryMessage&gt; timers) {
    this.requestId = requestId;
    this.requester = requester;

    timers.startSingleTimer(CollectionTimeout.class, CollectionTimeout.INSTANCE, timeout);

    ActorRef&lt;DeviceProtocol.RespondTemperature&gt; respondTemperatureAdapter =
        context.messageAdapter(
            DeviceProtocol.RespondTemperature.class, WrappedRespondTemperature::new);

    for (Map.Entry&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; entry :
        deviceIdToActor.entrySet()) {
      context.watchWith(entry.getValue(), new DeviceTerminated(entry.getKey()));
      entry.getValue().tell(new DeviceProtocol.ReadTemperature(0L, respondTemperatureAdapter));
    }
    stillWaiting = new HashSet&lt;&gt;(deviceIdToActor.keySet());
  }

  @Override
  public Receive&lt;DeviceGroupQueryMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(WrappedRespondTemperature.class, this::onRespondTemperature)
        .onMessage(DeviceTerminated.class, this::onDeviceTerminated)
        .onMessage(CollectionTimeout.class, this::onCollectionTimeout)
        .build();
  }

  private Behavior&lt;DeviceGroupQueryMessage&gt; onRespondTemperature(WrappedRespondTemperature r) {
    TemperatureReading reading =
        r.response
            .value
            .map(v -&gt; (TemperatureReading) new Temperature(v))
            .orElse(TemperatureNotAvailable.INSTANCE);

    String deviceId = r.response.deviceId;
    repliesSoFar.put(deviceId, reading);
    stillWaiting.remove(deviceId);

    return respondWhenAllCollected();
  }

  private Behavior&lt;DeviceGroupQueryMessage&gt; onDeviceTerminated(DeviceTerminated terminated) {
    if (stillWaiting.contains(terminated.deviceId)) {
      repliesSoFar.put(terminated.deviceId, DeviceNotAvailable.INSTANCE);
      stillWaiting.remove(terminated.deviceId);
    }
    return respondWhenAllCollected();
  }

  private Behavior&lt;DeviceGroupQueryMessage&gt; onCollectionTimeout(CollectionTimeout timeout) {
    for (String deviceId : stillWaiting) {
      repliesSoFar.put(deviceId, DeviceTimedOut.INSTANCE);
    }
    stillWaiting.clear();
    return respondWhenAllCollected();
  }

  private Behavior&lt;DeviceGroupQueryMessage&gt; respondWhenAllCollected() {
    if (stillWaiting.isEmpty()) {
      requester.tell(new RespondAllTemperatures(requestId, repliesSoFar));
      return Behaviors.stopped();
    } else {
      return this;
    }
  }

}</code></pre></dd>
</dl>
<h3><a href="#testing-the-query-actor" name="testing-the-query-actor" class="anchor"><span class="anchor-link"></span></a>Testing the query actor</h3>
<p>Now let&rsquo;s verify the correctness of the query actor implementation. There are various scenarios we need to test individually to make sure everything works as expected. To be able to do this, we need to simulate the device actors somehow to exercise various normal or failure scenarios. Thankfully we took the list of collaborators (actually a <code>Map</code>) as a parameter to the query actor, so we can pass in <code>TestProbe</code> references. In our first test, we try out the case when there are two devices and both report a temperature:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuerySpec.scala#L24-L52" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return temperature value for working devices&quot; in {
  val requester = createTestProbe[RespondAllTemperatures]()

  val device1 = createTestProbe[DeviceMessage]()
  val device2 = createTestProbe[DeviceMessage]()

  val deviceIdToActor = Map(&quot;device1&quot; -&gt; device1.ref, &quot;device2&quot; -&gt; device2.ref)

  val queryActor = spawn(DeviceGroupQuery(
    deviceIdToActor,
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMessageType[Device.ReadTemperature]
  device2.expectMessageType[Device.ReadTemperature]

  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device1&quot;, Some(1.0)))
  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device2&quot;, Some(2.0)))

  requester.expectMessage(RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; Temperature(1.0),
      &quot;device2&quot; -&gt; Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQueryTest.java#L28-L63" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureValueForWorkingDevices() {
  TestProbe&lt;RespondAllTemperatures&gt; requester =
      testKit.createTestProbe(RespondAllTemperatures.class);
  TestProbe&lt;DeviceMessage&gt; device1 = testKit.createTestProbe(DeviceMessage.class);
  TestProbe&lt;DeviceMessage&gt; device2 = testKit.createTestProbe(DeviceMessage.class);

  Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();
  deviceIdToActor.put(&quot;device1&quot;, device1.getRef());
  deviceIdToActor.put(&quot;device2&quot;, device2.getRef());

  ActorRef&lt;DeviceGroupQueryMessage&gt; queryActor =
      testKit.spawn(
          DeviceGroupQuery.createBehavior(
              deviceIdToActor, 1L, requester.getRef(), Duration.ofSeconds(3)));

  device1.expectMessageClass(ReadTemperature.class);
  device2.expectMessageClass(ReadTemperature.class);

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device1&quot;, Optional.of(1.0))));

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device2&quot;, Optional.of(2.0))));

  RespondAllTemperatures response = requester.receiveMessage();
  assertEquals(1L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>That was the happy case, but we know that sometimes devices cannot provide a temperature measurement. This scenario is just slightly different from the previous:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuerySpec.scala#L56-L84" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return TemperatureNotAvailable for devices with no readings&quot; in {
  val requester = createTestProbe[RespondAllTemperatures]()

  val device1 = createTestProbe[DeviceMessage]()
  val device2 = createTestProbe[DeviceMessage]()

  val deviceIdToActor = Map(&quot;device1&quot; -&gt; device1.ref, &quot;device2&quot; -&gt; device2.ref)

  val queryActor = spawn(DeviceGroupQuery(
    deviceIdToActor,
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMessageType[Device.ReadTemperature]
  device2.expectMessageType[Device.ReadTemperature]

  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device1&quot;, None))
  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device2&quot;, Some(2.0)))

  requester.expectMessage(RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; TemperatureNotAvailable,
      &quot;device2&quot; -&gt; Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQueryTest.java#L67-L102" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureNotAvailableForDevicesWithNoReadings() {
  TestProbe&lt;RespondAllTemperatures&gt; requester =
      testKit.createTestProbe(RespondAllTemperatures.class);
  TestProbe&lt;DeviceMessage&gt; device1 = testKit.createTestProbe(DeviceMessage.class);
  TestProbe&lt;DeviceMessage&gt; device2 = testKit.createTestProbe(DeviceMessage.class);

  Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();
  deviceIdToActor.put(&quot;device1&quot;, device1.getRef());
  deviceIdToActor.put(&quot;device2&quot;, device2.getRef());

  ActorRef&lt;DeviceGroupQueryMessage&gt; queryActor =
      testKit.spawn(
          DeviceGroupQuery.createBehavior(
              deviceIdToActor, 1L, requester.getRef(), Duration.ofSeconds(3)));

  assertEquals(0L, device1.expectMessageClass(ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMessageClass(ReadTemperature.class).requestId);

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device1&quot;, Optional.empty())));

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device2&quot;, Optional.of(2.0))));

  RespondAllTemperatures response = requester.receiveMessage();
  assertEquals(1L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, TemperatureNotAvailable.INSTANCE);
  expectedTemperatures.put(&quot;device2&quot;, new Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>We also know, that sometimes device actors stop before answering:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuerySpec.scala#L88-L117" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return DeviceNotAvailable if device stops before answering&quot; in {
  val requester = createTestProbe[RespondAllTemperatures]()

  val device1 = createTestProbe[DeviceMessage]()
  val device2 = createTestProbe[DeviceMessage]()

  val deviceIdToActor = Map(&quot;device1&quot; -&gt; device1.ref, &quot;device2&quot; -&gt; device2.ref)

  val queryActor = spawn(DeviceGroupQuery(
    deviceIdToActor,
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMessageType[Device.ReadTemperature]
  device2.expectMessageType[Device.ReadTemperature]

  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device1&quot;, Some(2.0)))

  device2.stop()

  requester.expectMessage(RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; Temperature(2.0),
      &quot;device2&quot; -&gt; DeviceNotAvailable
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQueryTest.java#L106-L139" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnDeviceNotAvailableIfDeviceStopsBeforeAnswering() {
  TestProbe&lt;RespondAllTemperatures&gt; requester =
      testKit.createTestProbe(RespondAllTemperatures.class);
  TestProbe&lt;DeviceMessage&gt; device1 = testKit.createTestProbe(DeviceMessage.class);
  TestProbe&lt;DeviceMessage&gt; device2 = testKit.createTestProbe(DeviceMessage.class);

  Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();
  deviceIdToActor.put(&quot;device1&quot;, device1.getRef());
  deviceIdToActor.put(&quot;device2&quot;, device2.getRef());

  ActorRef&lt;DeviceGroupQueryMessage&gt; queryActor =
      testKit.spawn(
          DeviceGroupQuery.createBehavior(
              deviceIdToActor, 1L, requester.getRef(), Duration.ofSeconds(3)));

  assertEquals(0L, device1.expectMessageClass(ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMessageClass(ReadTemperature.class).requestId);

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device1&quot;, Optional.of(1.0))));

  device2.stop();

  RespondAllTemperatures response = requester.receiveMessage();
  assertEquals(1L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, DeviceNotAvailable.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>If you remember, there is another case related to device actors stopping. It is possible that we get a normal reply from a device actor, but then receive a <code>Terminated</code> for the same actor later. In this case, we would like to keep the first reply and not mark the device as <code>DeviceNotAvailable</code>. We should test this, too:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuerySpec.scala#L121-L151" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return temperature reading even if device stops after answering&quot; in {
  val requester = createTestProbe[RespondAllTemperatures]()

  val device1 = createTestProbe[DeviceMessage]()
  val device2 = createTestProbe[DeviceMessage]()

  val deviceIdToActor = Map(&quot;device1&quot; -&gt; device1.ref, &quot;device2&quot; -&gt; device2.ref)

  val queryActor = spawn(DeviceGroupQuery(
    deviceIdToActor,
    requestId = 1,
    requester = requester.ref,
    timeout = 3.seconds
  ))

  device1.expectMessageType[Device.ReadTemperature]
  device2.expectMessageType[Device.ReadTemperature]

  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device1&quot;, Some(1.0)))
  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device2&quot;, Some(2.0)))

  device2.stop()

  requester.expectMessage(RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; Temperature(1.0),
      &quot;device2&quot; -&gt; Temperature(2.0)
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQueryTest.java#L143-L180" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnTemperatureReadingEvenIfDeviceStopsAfterAnswering() {
  TestProbe&lt;RespondAllTemperatures&gt; requester =
      testKit.createTestProbe(RespondAllTemperatures.class);
  TestProbe&lt;DeviceMessage&gt; device1 = testKit.createTestProbe(DeviceMessage.class);
  TestProbe&lt;DeviceMessage&gt; device2 = testKit.createTestProbe(DeviceMessage.class);

  Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();
  deviceIdToActor.put(&quot;device1&quot;, device1.getRef());
  deviceIdToActor.put(&quot;device2&quot;, device2.getRef());

  ActorRef&lt;DeviceGroupQueryMessage&gt; queryActor =
      testKit.spawn(
          DeviceGroupQuery.createBehavior(
              deviceIdToActor, 1L, requester.getRef(), Duration.ofSeconds(3)));

  assertEquals(0L, device1.expectMessageClass(ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMessageClass(ReadTemperature.class).requestId);

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device1&quot;, Optional.of(1.0))));

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device2&quot;, Optional.of(2.0))));

  device2.stop();

  RespondAllTemperatures response = requester.receiveMessage();
  assertEquals(1L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new Temperature(2.0));

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>The final case is when not all devices respond in time. To keep our test relatively fast, we will construct the <code>DeviceGroupQuery</code> actor with a smaller timeout:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupQuerySpec.scala#L155-L184" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return DeviceTimedOut if device does not answer in time&quot; in {
  val requester = createTestProbe[RespondAllTemperatures]()

  val device1 = createTestProbe[DeviceMessage]()
  val device2 = createTestProbe[DeviceMessage]()

  val deviceIdToActor = Map(&quot;device1&quot; -&gt; device1.ref, &quot;device2&quot; -&gt; device2.ref)

  val queryActor = spawn(DeviceGroupQuery(
    deviceIdToActor,
    requestId = 1,
    requester = requester.ref,
    timeout = 200.millis
  ))

  device1.expectMessageType[Device.ReadTemperature]
  device2.expectMessageType[Device.ReadTemperature]

  queryActor ! WrappedRespondTemperature(Device.RespondTemperature(requestId = 0, &quot;device1&quot;, Some(1.0)))

  // no reply from device2

  requester.expectMessage(RespondAllTemperatures(
    requestId = 1,
    temperatures = Map(
      &quot;device1&quot; -&gt; Temperature(1.0),
      &quot;device2&quot; -&gt; DeviceTimedOut
    )
  ))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupQueryTest.java#L184-L217" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnDeviceTimedOutIfDeviceDoesNotAnswerInTime() {
  TestProbe&lt;RespondAllTemperatures&gt; requester =
      testKit.createTestProbe(RespondAllTemperatures.class);
  TestProbe&lt;DeviceMessage&gt; device1 = testKit.createTestProbe(DeviceMessage.class);
  TestProbe&lt;DeviceMessage&gt; device2 = testKit.createTestProbe(DeviceMessage.class);

  Map&lt;String, ActorRef&lt;DeviceProtocol.DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();
  deviceIdToActor.put(&quot;device1&quot;, device1.getRef());
  deviceIdToActor.put(&quot;device2&quot;, device2.getRef());

  ActorRef&lt;DeviceGroupQueryMessage&gt; queryActor =
      testKit.spawn(
          DeviceGroupQuery.createBehavior(
              deviceIdToActor, 1L, requester.getRef(), Duration.ofMillis(200)));

  assertEquals(0L, device1.expectMessageClass(ReadTemperature.class).requestId);
  assertEquals(0L, device2.expectMessageClass(ReadTemperature.class).requestId);

  queryActor.tell(
      new DeviceGroupQuery.WrappedRespondTemperature(
          new RespondTemperature(0L, &quot;device1&quot;, Optional.of(1.0))));

  // no reply from device2

  RespondAllTemperatures response = requester.receiveMessage();
  assertEquals(1L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, DeviceTimedOut.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<p>Our query works as expected now, it is time to include this new functionality in the <code>DeviceGroup</code> actor now.</p>
<h2><a href="#adding-query-capability-to-the-group" name="adding-query-capability-to-the-group" class="anchor"><span class="anchor-link"></span></a>Adding query capability to the group</h2>
<p>Including the query feature in the group actor is fairly simple now. We did all the heavy lifting in the query actor itself, the group actor only needs to create it with the right initial parameters and nothing else.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroup.scala#L30-L98" target="_blank" title="Go to snippet source"></a><code class="language-scala">class DeviceGroup(context: ActorContext[DeviceGroup.DeviceGroupMessage], groupId: String)
  extends AbstractBehavior[DeviceGroup.DeviceGroupMessage] {
  import DeviceGroup._
  import DeviceManager._

  private var deviceIdToActor = Map.empty[String, ActorRef[Device.DeviceMessage]]

  context.log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def onMessage(msg: DeviceGroupMessage): Behavior[DeviceGroupMessage] =
    msg match {
      // ... other cases omitted

      case RequestAllTemperatures(requestId, gId, replyTo) ⇒
        if (gId == groupId) {
          context.spawnAnonymous(DeviceGroupQuery(
            deviceIdToActor,
            requestId = requestId,
            requester = replyTo,
            3.seconds
          ))
          this
        } else
          Behaviors.unhandled
    }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceGroupMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;DeviceGroup {} stopped&quot;, groupId)
      this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroup.java#L23-L128" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractBehavior&lt;DeviceGroupMessage&gt; {

  public static Behavior&lt;DeviceGroupMessage&gt; createBehavior(String groupId) {
    return Behaviors.setup(context -&gt; new DeviceGroup(context, groupId));
  }

  private class DeviceTerminated implements DeviceGroupMessage {
    public final ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device;
    public final String groupId;
    public final String deviceId;

    DeviceTerminated(
        ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device, String groupId, String deviceId) {
      this.device = device;
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  private final ActorContext&lt;DeviceGroupMessage&gt; context;
  private final String groupId;
  private final Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();

  public DeviceGroup(ActorContext&lt;DeviceGroupMessage&gt; context, String groupId) {
    this.context = context;
    this.groupId = groupId;
    context.getLog().info(&quot;DeviceGroup {} started&quot;, groupId);
  }


  private DeviceGroup onAllTemperatures(RequestAllTemperatures r) {
    // since Java collections are mutable, we want to avoid sharing them between actors (since
    // multiple Actors (threads)
    // modifying the same mutable data-structure is not safe), and perform a defensive copy of the
    // mutable map:
    //
    // Feel free to use your favourite immutable data-structures library with Akka in Java
    // applications!
    Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt; deviceIdToActorCopy = new HashMap&lt;&gt;(this.deviceIdToActor);

    context.spawnAnonymous(
        DeviceGroupQuery.createBehavior(
            deviceIdToActorCopy, r.requestId, r.replyTo, Duration.ofSeconds(3)));

    return this;
  }

  @Override
  public Receive&lt;DeviceGroupMessage&gt; createReceive() {
    return receiveBuilder()
        // ... other cases omitted
        .onMessage(
            RequestAllTemperatures.class, r -&gt; r.groupId.equals(groupId), this::onAllTemperatures)
        .build();
  }
}</code></pre></dd>
</dl>
<p>It is probably worth restating what we said at the beginning of the chapter. By keeping the temporary state that is only relevant to the query itself in a separate actor we keep the group actor implementation very simple. It delegates everything to child actors and therefore does not have to keep state that is not relevant to its core business. Also, multiple queries can now run parallel to each other, in fact, as many as needed. In our case querying an individual device actor is a fast operation, but if this were not the case, for example, because the remote sensors need to be contacted over the network, this design would significantly improve throughput.</p>
<p>We close this chapter by testing that everything works together. This test is a variant of the previous ones, now exercising the group query feature:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_5/DeviceGroupSpec.scala#L110-L140" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to collect temperatures from all active devices&quot; in {
  val registeredProbe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.ref)
  val deviceActor1 = registeredProbe.receiveMessage().device

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.ref)
  val deviceActor2 = registeredProbe.receiveMessage().device

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device3&quot;, registeredProbe.ref)
  registeredProbe.receiveMessage()

  // Check that the device actors are working
  val recordProbe = createTestProbe[TemperatureRecorded]()
  deviceActor1 ! RecordTemperature(requestId = 0, 1.0, recordProbe.ref)
  recordProbe.expectMessage(TemperatureRecorded(requestId = 0))
  deviceActor2 ! RecordTemperature(requestId = 1, 2.0, recordProbe.ref)
  recordProbe.expectMessage(TemperatureRecorded(requestId = 1))
  // No temperature for device3

  val allTempProbe = createTestProbe[RespondAllTemperatures]()
  groupActor ! RequestAllTemperatures(requestId = 0, groupId = &quot;group&quot;, allTempProbe.ref)
  allTempProbe.expectMessage(
    RespondAllTemperatures(
      requestId = 0,
      temperatures = Map(
        &quot;device1&quot; -&gt; Temperature(1.0),
        &quot;device2&quot; -&gt; Temperature(2.0),
        &quot;device3&quot; -&gt; TemperatureNotAvailable)))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_5/DeviceGroupTest.java#L126-L160" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testCollectTemperaturesFromAllActiveDevices() {
  TestProbe&lt;DeviceRegistered&gt; registeredProbe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.getRef()));
  ActorRef&lt;DeviceMessage&gt; deviceActor1 = registeredProbe.receiveMessage().device;

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.getRef()));
  ActorRef&lt;DeviceMessage&gt; deviceActor2 = registeredProbe.receiveMessage().device;

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device3&quot;, registeredProbe.getRef()));
  ActorRef&lt;DeviceMessage&gt; deviceActor3 = registeredProbe.receiveMessage().device;

  // Check that the device actors are working
  TestProbe&lt;TemperatureRecorded&gt; recordProbe = testKit.createTestProbe(TemperatureRecorded.class);
  deviceActor1.tell(new RecordTemperature(0L, 1.0, recordProbe.getRef()));
  assertEquals(0L, recordProbe.receiveMessage().requestId);
  deviceActor2.tell(new RecordTemperature(1L, 2.0, recordProbe.getRef()));
  assertEquals(1L, recordProbe.receiveMessage().requestId);
  // No temperature for device 3

  TestProbe&lt;RespondAllTemperatures&gt; allTempProbe =
      testKit.createTestProbe(RespondAllTemperatures.class);
  groupActor.tell(new RequestAllTemperatures(0L, &quot;group&quot;, allTempProbe.getRef()));
  RespondAllTemperatures response = allTempProbe.receiveMessage();
  assertEquals(0L, response.requestId);

  Map&lt;String, TemperatureReading&gt; expectedTemperatures = new HashMap&lt;&gt;();
  expectedTemperatures.put(&quot;device1&quot;, new Temperature(1.0));
  expectedTemperatures.put(&quot;device2&quot;, new Temperature(2.0));
  expectedTemperatures.put(&quot;device3&quot;, TemperatureNotAvailable.INSTANCE);

  assertEquals(expectedTemperatures, response.temperatures);
}</code></pre></dd>
</dl>
<h2><a href="#summary" name="summary" class="anchor"><span class="anchor-link"></span></a>Summary</h2>
<p>In the context of the IoT system, this guide introduced the following concepts, among others. You can follow the links to review them if necessary:</p>
<ul>
  <li><a href="tutorial_1.html">The hierarchy of actors and their lifecycle</a></li>
  <li><a href="tutorial_3.html">The importance of designing messages for flexibility</a></li>
  <li><a href="tutorial_4.html#keeping-track-of-the-device-actors-in-the-group">How to watch and stop actors, if necessary</a></li>
</ul>
<h2><a href="#whats-next-" name="whats-next-" class="anchor"><span class="anchor-link"></span></a>What&rsquo;s Next?</h2>
<p>To continue your journey with Akka, we recommend:</p>
<ul>
  <li>Start building your own applications with Akka, make sure you <a href="http://akka.io/get-involved">get involved in our amazing community</a> for help if you get stuck.</li>
  <li>If you’d like some additional background, and detail, read the rest of the <a href="../actors.html">reference documentation</a> and check out some of the <a href="../../additional/books.html">books and videos</a> on Akka.</li>
  <li>If you are interested in functional programming, read how actors can be defined in a <a href="../actors.html#functional-style">functional style</a>. In this guide the object-oriented style was used, but you can mix both as you like.</li>
</ul>
<p>To get from this guide to a complete application you would likely need to provide either an UI or an API. For this we recommend that you look at the following technologies and see what fits you:</p>
<ul>
  <li><a href="https://doc.akka.io/docs/akka-http/current/introduction.html">Akka HTTP</a> is a HTTP server and client library, making it possible to publish and consume HTTP endpoints</li>
  <li><a href="https://www.playframework.com">Play Framework</a> is a full fledged web framework that is built on top of Akka HTTP, it integrates well with Akka and can be used to create a complete modern web UI</li>
  <li><a href="https://www.lagomframework.com">Lagom</a> is an opinionated microservice framework built on top of Akka, encoding many best practices around Akka and Play</li>
</ul>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../typed/guide/tutorial_4.html"><i class="icon-prev"></i> <span class="link-prev">Part 4: Working with Device Groups</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../typed/actors.html">Actors <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/typed/guide/tutorial_5.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/groups.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../../assets/js/scalafiddle.js"></script>


</body>
</html>
