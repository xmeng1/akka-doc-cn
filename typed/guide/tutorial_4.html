<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Part 4: Working with Device Groups &bull; Akka Documentation 中文</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="akka-docs-cn"/>
<link rel="canonical" href="http://doc.akka.io/docs/akka/current/typed/guide/tutorial_4.html"/>
<script type="text/javascript" src="../../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../../css/page.css"/>
<link rel="shortcut icon" href="../../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16.png">
<link rel="manifest" href="../../images/manifest.json">
<meta name="msapplication-TileImage" content="../../images/mstile-150x150.png">
<meta name="msapplication-TileColor" content="#15a9ce">
<meta name="theme-color" content="#15a9ce">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) start -->
<script src="https://optanon.blob.core.windows.net/consent/159bb13d-6748-4399-806e-ac28db879785.js" type="text/javascript" charset="UTF-8"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice (Production Standard, akka.io, en-GB) end -->
<!--Google Analytics-->
<script type="text/plain" class="optanon-category-2">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-21117439-1']);
_gaq.push(['_setDomainName', 'akka.io']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})()
</script>
<script type="text/plain" class="optanon-category-2">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-23127719-1', 'lightbend.com', {'allowLinker': true, 'name': 'tsTracker'});
ga('tsTracker.require', 'linker');
ga('tsTracker.linker:autoLink', ['lightbend.com','playframework.com','scala-lang.org','scaladays.org','spray.io','akka.io','scala-sbt.org','scala-ide.org']);
ga('tsTracker.send', 'pageview');
</script>
<!--Marketo-->
<script type="text/plain" class="optanon-category-3">
(function() {
var didInit = false;
function initMunchkin() {
if(didInit === false) {
didInit = true;
Munchkin.init('558-NCX-702', { 'asyncOnly': true, 'disableClickDelay': true });
}
}
var s = document.createElement('script');
s.type = 'text/javascript';
s.async = true;
s.src = '//munchkin.marketo.net/munchkin.js';
s.onreadystatechange = function() {
if (this.readyState == 'complete' || this.readyState == 'loaded') {
initMunchkin();
}
};
s.onload = initMunchkin;
document.getElementsByTagName('head')[0].appendChild(s);
})();
</script>
</head>

<body id="underlay" data-toggler="nav-open">

<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="http://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div id="overlay-search-container" class="nav-header-search">
<input id="overlay-search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../index-actors.html" class="page">Actors</a></li>
  <li><a href="../../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../../typed/guide/index.html" class="page">Getting Started Guide</a>
    <ul>
      <li><a href="../../typed/guide/introduction.html" class="page">Introduction to Akka</a></li>
      <li><a href="../../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
      <li><a href="../../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
      <li><a href="../../typed/guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
      <li><a href="../../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
      <li><a href="../../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
      <li><a href="../../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
      <li><a href="../../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
      <li><a href="../../typed/guide/tutorial_4.html#part-4-working-with-device-groups" class="active page">Part 4: Working with Device Groups</a>
      <ul>
        <li><a href="../../typed/guide/tutorial_4.html#introduction" class="header">Introduction</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#device-manager-hierarchy" class="header">Device manager hierarchy</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#adding-registration-support-to-device-group-actors" class="header">Adding registration support to device group actors</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#creating-device-manager-actors" class="header">Creating device manager actors</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#whats-next-" class="header">What&rsquo;s next?</a></li>
      </ul></li>
      <li><a href="../../typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
    </ul></li>
    <li><a href="../../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../../stream/index.html" class="page">Streams</a></li>
  <li><a href="../../index-network.html" class="page">Networking</a></li>
  <li><a href="../../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../project/index.html" class="page">Project Information</a></li>
  <li><a href="../../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</nav>
</div>
</header>

<aside class="show-for-large">
<header class="nav-header fixed-sidebar-header">
<div class="nav-header-title">
<h1><a href="../../index.html">Akka Documentation 中文</a></h1>
</div>
<div class="nav-header-version">
Version 2.5-SNAPSHOT
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option><option class="group" value="group-java">Java</option></select>
</div>
<div class="nav-header-search">
<input id="search" type="search" class="search" placeholder="Search"/>
</div>
</header>
<nav class="site-nav fixed-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../../security/index.html" class="page">Security Announcements</a></li>
  <li><a href="../../guide/index.html" class="page">Getting Started Guide</a></li>
  <li><a href="../../general/index.html" class="page">General Concepts</a></li>
  <li><a href="../../index-actors.html" class="page">Actors</a></li>
  <li><a href="../../typed/index.html" class="page">Akka Typed</a>
  <ul>
    <li><a href="../../typed/guide/index.html" class="page">Getting Started Guide</a>
    <ul>
      <li><a href="../../typed/guide/introduction.html" class="page">Introduction to Akka</a></li>
      <li><a href="../../typed/guide/actors-motivation.html" class="page">Why modern systems need a new programming model</a></li>
      <li><a href="../../typed/guide/actors-intro.html" class="page">How the Actor Model Meets the Needs of Modern, Distributed Systems</a></li>
      <li><a href="../../typed/guide/modules.html" class="page">Overview of Akka libraries and modules</a></li>
      <li><a href="../../typed/guide/tutorial.html" class="page">Introduction to the Example</a></li>
      <li><a href="../../typed/guide/tutorial_1.html" class="page">Part 1: Actor Architecture</a></li>
      <li><a href="../../typed/guide/tutorial_2.html" class="page">Part 2: Creating the First Actor</a></li>
      <li><a href="../../typed/guide/tutorial_3.html" class="page">Part 3: Working with Device Actors</a></li>
      <li><a href="../../typed/guide/tutorial_4.html#part-4-working-with-device-groups" class="active page">Part 4: Working with Device Groups</a>
      <ul>
        <li><a href="../../typed/guide/tutorial_4.html#introduction" class="header">Introduction</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#device-manager-hierarchy" class="header">Device manager hierarchy</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#the-registration-protocol" class="header">The Registration Protocol</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#adding-registration-support-to-device-group-actors" class="header">Adding registration support to device group actors</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#creating-device-manager-actors" class="header">Creating device manager actors</a></li>
        <li><a href="../../typed/guide/tutorial_4.html#whats-next-" class="header">What&rsquo;s next?</a></li>
      </ul></li>
      <li><a href="../../typed/guide/tutorial_5.html" class="page">Part 5: Querying Device Groups</a></li>
    </ul></li>
    <li><a href="../../typed/actors.html" class="page">Actors</a></li>
    <li><a href="../../typed/dispatchers.html" class="page">Dispatchers</a></li>
    <li><a href="../../typed/coexisting.html" class="page">Coexistence</a></li>
    <li><a href="../../typed/actor-lifecycle.html" class="page">Actor lifecycle</a></li>
    <li><a href="../../typed/interaction-patterns.html" class="page">Interaction Patterns</a></li>
    <li><a href="../../typed/fault-tolerance.html" class="page">Fault Tolerance</a></li>
    <li><a href="../../typed/actor-discovery.html" class="page">Actor discovery</a></li>
    <li><a href="../../typed/stash.html" class="page">Stash</a></li>
    <li><a href="../../typed/stream.html" class="page">Streams</a></li>
    <li><a href="../../typed/cluster.html" class="page">Cluster</a></li>
    <li><a href="../../typed/distributed-data.html" class="page">Distributed Data</a></li>
    <li><a href="../../typed/cluster-singleton.html" class="page">Cluster Singleton</a></li>
    <li><a href="../../typed/cluster-sharding.html" class="page">Cluster Sharding</a></li>
    <li><a href="../../typed/persistence.html" class="page">Persistence</a></li>
    <li><a href="../../typed/fsm.html" class="page">Behaviors as Finite state machines</a></li>
    <li><a href="../../typed/testing.html" class="page">Testing</a></li>
  </ul></li>
  <li><a href="../../index-cluster.html" class="page">Clustering</a></li>
  <li><a href="../../stream/index.html" class="page">Streams</a></li>
  <li><a href="../../index-network.html" class="page">Networking</a></li>
  <li><a href="../../discovery/index.html" class="page">Discovery</a></li>
  <li><a href="../../index-futures.html" class="page">Futures and Agents</a></li>
  <li><a href="../../index-utilities.html" class="page">Utilities</a></li>
  <li><a href="../../common/other-modules.html" class="page">Other Akka modules</a></li>
  <li><a href="../../howto.html" class="page">HowTo: Common Patterns</a></li>
  <li><a href="../../project/index.html" class="page">Project Information</a></li>
  <li><a href="../../additional/index.html" class="page">Additional Information</a></li>
  <li><a href="../../chinese/index.html" class="page">中文版文档说明</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer fixed-sidebar-footer">
<a href="http://akka.io"><img class="logo" src="../../images/akka-logo-reverse.svg"></a>

</footer>
</aside>

<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">

<article class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#part-4-working-with-device-groups" name="part-4-working-with-device-groups" class="anchor"><span class="anchor-link"></span></a>Part 4: Working with Device Groups</h1>
<h2><a href="#introduction" name="introduction" class="anchor"><span class="anchor-link"></span></a>Introduction</h2><div class="callout warning "><div class="callout-title">Warning</div>
<p>This module is currently marked as <a href="../../common/may-change.html">may change</a> in the sense  of being the subject of final development. This means that API or semantics can  change without warning or deprecation period and it is not recommended to use  this module in production just yet.</p></div>
<p>Let&rsquo;s take a closer look at the main functionality required by our use case. In a complete IoT system for monitoring home temperatures, the steps for connecting a device sensor to our system might look like this:</p>
<ol>
  <li>A sensor device in the home connects through some protocol.</li>
  <li>The component managing network connections accepts the connection.</li>
  <li>The sensor provides its group and device ID to register with the device manager component of our system.</li>
  <li>The device manager component handles registration by looking up or creating the actor responsible for keeping sensor state.</li>
  <li>The actor responds with an acknowledgement, exposing its <code>ActorRef</code>.</li>
  <li>The networking component now uses the <code>ActorRef</code> for communication between the sensor and device actor without going through the device manager.</li>
</ol>
<p>Steps 1 and 2 take place outside the boundaries of our tutorial system. In this chapter, we will start addressing steps 3-6 and create a way for sensors to register with our system and to communicate with actors. But first, we have another architectural decision &#8212; how many levels of actors should we use to represent device groups and device sensors?</p>
<p>One of the main design challenges for Akka programmers is choosing the best granularity for actors. In practice, depending on the characteristics of the interactions between actors, there are usually several valid ways to organize a system. In our use case, for example, it would be possible to have a single actor maintain all the groups and devices &#8212; perhaps using hash maps. It would also be reasonable to have an actor for each group that tracks the state of all devices in the same home.</p>
<p>The following guidelines help us choose the most appropriate actor hierarchy:</p>
<ul>
  <li>In general, prefer larger granularity. Introducing more fine-grained actors than needed causes more problems than it solves.</li>
  <li>Add finer granularity when the system requires:
    <ul>
      <li>Higher concurrency.</li>
      <li>Complex conversations between actors that have many states. We will see a very good example for this in the next chapter.</li>
      <li>Sufficient state that it makes sense to divide into smaller actors.</li>
      <li>Multiple unrelated responsibilities. Using separate actors allows individuals to fail and be restored with little impact on others.</li>
    </ul>
  </li>
</ul>
<h2><a href="#device-manager-hierarchy" name="device-manager-hierarchy" class="anchor"><span class="anchor-link"></span></a>Device manager hierarchy</h2>
<p>Considering the principles outlined in the previous section, We will model the device manager component as an actor tree with three levels:</p>
<ul>
  <li>The top level supervisor actor represents the system component for devices. It is also the entry point to look up and create device group and device actors.</li>
  <li>At the next level, group actors each supervise the device actors for one group id (e.g. one home). They also provide services, such as querying temperature readings from all of the available devices in their group.</li>
  <li>Device actors manage all the interactions with the actual device sensors, such as storing temperature readings.</li>
</ul>
<p><img src="../../guide/diagrams/device_manager_tree.png" alt="device manager tree" /></p>
<p>We chose this three-layered architecture for these reasons:</p>
<ul>
  <li>
    <p>Having groups of individual actors:</p>
    <ul>
      <li>Isolates failures that occur in a group. If a single actor managed all device groups, an error in one group that causes a restart would wipe out the state of groups that are otherwise non-faulty.</li>
      <li>Simplifies the problem of querying all the devices belonging to a group. Each group actor only contains state related to its group.</li>
      <li>Increases parallelism in the system. Since each group has a dedicated actor, they run concurrently and we can query multiple groups concurrently.</li>
    </ul>
  </li>
  <li>
    <p>Having sensors modeled as individual device actors:</p>
    <ul>
      <li>Isolates failures of one device actor from the rest of the devices in the group.</li>
      <li>Increases the parallelism of collecting temperature readings. Network connections from different sensors communicate with their individual device actors directly, reducing contention points.</li>
    </ul>
  </li>
</ul>
<p>With the architecture defined, we can start working on the protocol for registering sensors.</p>
<h2><a href="#the-registration-protocol" name="the-registration-protocol" class="anchor"><span class="anchor-link"></span></a>The Registration Protocol</h2>
<p>As the first step, we need to design the protocol both for registering a device and for creating the group and device actors that will be responsible for it. This protocol will be provided by the <code>DeviceManager</code> component itself because that is the only actor that is known and available up front: device groups and device actors are created on-demand.</p>
<p>Looking at registration in more detail, we can outline the necessary functionality:</p>
<ol>
  <li>When a <code>DeviceManager</code> receives a request with a group and device id:
    <ul>
      <li>If the manager already has an actor for the device group, it forwards the request to it.</li>
      <li>Otherwise, it creates a new device group actor and then forwards the request.</li>
    </ul>
  </li>
  <li>The <code>DeviceGroup</code> actor receives the request to register an actor for the given device:
    <ul>
      <li>If the group already has an actor for the device it replies with the <code>ActorRef</code> of the existing device actor.</li>
      <li>Otherwise, the <code>DeviceGroup</code> actor first creates a device actor and replies with the <code>ActorRef</code> of the newly created device actor.</li>
    </ul>
  </li>
  <li>The sensor will now have the <code>ActorRef</code> of the device actor to send messages directly to it.</li>
</ol>
<p>The messages that we will use to communicate registration requests and their acknowledgement have the definition:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceManager.scala#L26-L29" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class RequestTrackDevice(groupId: String, deviceId: String, replyTo: ActorRef[DeviceRegistered])
  extends DeviceManagerMessage with DeviceGroupMessage

final case class DeviceRegistered(device: ActorRef[Device.DeviceMessage])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceManagerProtocol.java#L12-L66" target="_blank" title="Go to snippet source"></a><code class="language-java">abstract class DeviceManagerProtocol {
  // no instances of DeviceManagerProtocol class
  private DeviceManagerProtocol() {}

  interface DeviceManagerMessage {}

  interface DeviceGroupMessage {}

  public static final class RequestTrackDevice implements DeviceManagerMessage, DeviceGroupMessage {
    public final String groupId;
    public final String deviceId;
    public final ActorRef&lt;DeviceRegistered&gt; replyTo;

    public RequestTrackDevice(String groupId, String deviceId, ActorRef&lt;DeviceRegistered&gt; replyTo) {
      this.groupId = groupId;
      this.deviceId = deviceId;
      this.replyTo = replyTo;
    }
  }

  public static final class DeviceRegistered {
    public final ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device;

    public DeviceRegistered(ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device) {
      this.device = device;
    }
  }
}</code></pre></dd>
</dl>
<p>In this case we have not included a request ID field in the messages. Since registration happens once, when the component connects the system to some network protocol, the ID is not important. However, it is usually a best practice to include a request ID.</p>
<p>Now, we&rsquo;ll start implementing the protocol from the bottom up. In practice, both a top-down and bottom-up approach can work, but in our case, we benefit from the bottom-up approach as it allows us to immediately write tests for the new features without mocking out parts that we will need to build later.</p>
<h2><a href="#adding-registration-support-to-device-group-actors" name="adding-registration-support-to-device-group-actors" class="anchor"><span class="anchor-link"></span></a>Adding registration support to device group actors</h2>
<p>A group actor has some work to do when it comes to registrations, including:</p>
<ul>
  <li>Handling the registration request for existing device actor or by creating a new actor.</li>
  <li>Tracking which device actors exist in the group and removing them from the group when they are stopped.</li>
</ul>
<h3><a href="#handling-the-registration-request" name="handling-the-registration-request" class="anchor"><span class="anchor-link"></span></a>Handling the registration request</h3>
<p>A device group actor must either reply to the request with the <code>ActorRef</code> of an existing child, or it should create one. To look up child actors by their device IDs we will use a .</p>
<p>Add the following to your source file:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroup.scala#L17-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroup {
  def apply(groupId: String): Behavior[DeviceGroupMessage] =
    Behaviors.setup(context ⇒ new DeviceGroup(context, groupId))

  trait DeviceGroupMessage

  private final case class DeviceTerminated(
    device:   ActorRef[Device.DeviceMessage],
    groupId:  String,
    deviceId: String) extends DeviceGroupMessage

}

class DeviceGroup(context: ActorContext[DeviceGroup.DeviceGroupMessage], groupId: String)
  extends AbstractBehavior[DeviceGroup.DeviceGroupMessage] {
  import DeviceGroup._
  import DeviceManager._

  private var deviceIdToActor = Map.empty[String, ActorRef[Device.DeviceMessage]]

  context.log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def onMessage(msg: DeviceGroupMessage): Behavior[DeviceGroupMessage] =
    msg match {
      case trackMsg @ RequestTrackDevice(`groupId`, deviceId, replyTo) ⇒
        deviceIdToActor.get(deviceId) match {
          case Some(deviceActor) ⇒
            replyTo ! DeviceRegistered(deviceActor)
          case None ⇒
            context.log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
            val deviceActor = context.spawn(Device(groupId, deviceId), s&quot;device-$deviceId&quot;)
            deviceIdToActor += deviceId -&gt; deviceActor
            replyTo ! DeviceRegistered(deviceActor)
        }
        this

      case RequestTrackDevice(gId, _, _) ⇒
        context.log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          gId, groupId
        )
        this
    }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceGroupMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;DeviceGroup {} stopped&quot;, groupId)
      this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroup.java#L24-L117" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractBehavior&lt;DeviceGroupMessage&gt; {

  public static Behavior&lt;DeviceGroupMessage&gt; createBehavior(String groupId) {
    return Behaviors.setup(context -&gt; new DeviceGroup(context, groupId));
  }

  private class DeviceTerminated implements DeviceGroupMessage {
    public final ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device;
    public final String groupId;
    public final String deviceId;

    DeviceTerminated(
        ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device, String groupId, String deviceId) {
      this.device = device;
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  private final ActorContext&lt;DeviceGroupMessage&gt; context;
  private final String groupId;
  private final Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();

  public DeviceGroup(ActorContext&lt;DeviceGroupMessage&gt; context, String groupId) {
    this.context = context;
    this.groupId = groupId;
    context.getLog().info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  private DeviceGroup onTrackDevice(RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef&lt;DeviceMessage&gt; deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      } else {
        context.getLog().info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            context.spawn(
                Device.createBehavior(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      }
    } else {
      context
          .getLog()
          .warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId,
              this.groupId);
    }
    return this;
  }


  @Override
  public Receive&lt;DeviceGroupMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(RequestTrackDevice.class, this::onTrackDevice)
        .build();
  }

  private DeviceGroup postStop() {
    context.getLog().info(&quot;DeviceGroup {} stopped&quot;, groupId);
    return this;
  }
}</code></pre></dd>
</dl>
<p>Just as we did with the device, we test this new functionality. We also test that the actors returned for the two different IDs are actually different, and we also attempt to record a temperature reading for each of the devices to see if the actors are responding.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroupSpec.scala#L19-L47" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to register a device actor&quot; in {
  val probe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, probe.ref)
  val registered1 = probe.receiveMessage()
  val deviceActor1 = registered1.device

  // another deviceId
  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, probe.ref)
  val registered2 = probe.receiveMessage()
  val deviceActor2 = registered2.device
  deviceActor1 should !==(deviceActor2)

  // Check that the device actors are working
  val recordProbe = createTestProbe[TemperatureRecorded]()
  deviceActor1 ! RecordTemperature(requestId = 0, 1.0, recordProbe.ref)
  recordProbe.expectMessage(TemperatureRecorded(requestId = 0))
  deviceActor2 ! Device.RecordTemperature(requestId = 1, 2.0, recordProbe.ref)
  recordProbe.expectMessage(Device.TemperatureRecorded(requestId = 1))
}

&quot;ignore requests for wrong groupId&quot; in {
  val probe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;, probe.ref)
  probe.expectNoMessage(500.milliseconds)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroupTest.java#L27-L54" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReplyToRegistrationRequests() {
  TestProbe&lt;DeviceRegistered&gt; probe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device&quot;, probe.getRef()));
  DeviceRegistered registered1 = probe.receiveMessage();

  // another deviceId
  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device3&quot;, probe.getRef()));
  DeviceRegistered registered2 = probe.receiveMessage();
  assertNotEquals(registered1.device, registered2.device);

  // Check that the device actors are working
  TestProbe&lt;TemperatureRecorded&gt; recordProbe = testKit.createTestProbe(TemperatureRecorded.class);
  registered1.device.tell(new RecordTemperature(0L, 1.0, recordProbe.getRef()));
  assertEquals(0L, recordProbe.receiveMessage().requestId);
  registered2.device.tell(new RecordTemperature(1L, 2.0, recordProbe.getRef()));
  assertEquals(1L, recordProbe.receiveMessage().requestId);
}

@Test
public void testIgnoreWrongRegistrationRequests() {
  TestProbe&lt;DeviceRegistered&gt; probe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));
  groupActor.tell(new RequestTrackDevice(&quot;wrongGroup&quot;, &quot;device1&quot;, probe.getRef()));
  probe.expectNoMessage();
}</code></pre></dd>
</dl>
<p>If a device actor already exists for the registration request, we would like to use the existing actor instead of a new one. We have not tested this yet, so we need to fix this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroupSpec.scala#L51-L63" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;return same actor for same deviceId&quot; in {
  val probe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, probe.ref)
  val registered1 = probe.receiveMessage()

  // registering same again should be idempotent
  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, probe.ref)
  val registered2 = probe.receiveMessage()

  registered1.device should ===(registered2.device)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroupTest.java#L58-L70" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testReturnSameActorForSameDeviceId() {
  TestProbe&lt;DeviceRegistered&gt; probe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device&quot;, probe.getRef()));
  DeviceRegistered registered1 = probe.receiveMessage();

  // registering same again should be idempotent
  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device&quot;, probe.getRef()));
  DeviceRegistered registered2 = probe.receiveMessage();
  assertEquals(registered1.device, registered2.device);
}</code></pre></dd>
</dl>
<h3><a href="#keeping-track-of-the-device-actors-in-the-group" name="keeping-track-of-the-device-actors-in-the-group" class="anchor"><span class="anchor-link"></span></a>Keeping track of the device actors in the group</h3>
<p>So far, we have implemented logic for registering device actors in the group. Devices come and go, however, so we will need a way to remove device actors from the <span class="group-scala"><code>Map[String, ActorRef[DeviceMessage]]</code></span><span class="group-java"><code>Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt;</code></span>. We will assume that when a device is removed, its corresponding device actor is stopped. Supervision, as we discussed earlier, only handles error scenarios &#8212; not graceful stopping. So we need to notify the parent when one of the device actors is stopped.</p>
<p>Akka provides a <em>Death Watch</em> feature that allows an actor to <em>watch</em> another actor and be notified if the other actor is stopped. Unlike supervision, watching is not limited to parent-child relationships, any actor can watch any other actor as long as it knows the <code>ActorRef</code>. After a watched actor stops, the watcher receives a <code>Terminated(actorRef)</code> signal which also contains the reference to the watched actor. The watcher can either handle this message explicitly or will fail with a <code>DeathPactException</code>. This latter is useful if the actor can no longer perform its own duties after the watched actor has been stopped. In our case, the group should still function after one device have been stopped, so we need to handle the <code>Terminated(actorRef)</code> signal.</p>
<p>Our device group actor needs to include functionality that:</p>
<ol>
  <li>Starts watching new device actors when they are created.</li>
  <li>Removes a device actor from the <span class="group-scala"><code>Map[String, ActorRef[DeviceMessage]]</code></span><span class="group-java"><code>Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt;</code></span> &#8212; which maps devices to device actors &#8212; when the notification indicates it has stopped.</li>
</ol>
<p>Unfortunately, the <code>Terminated</code> signal only contains the <code>ActorRef</code> of the child actor. We need the actor&rsquo;s ID to remove it from the map of existing device to device actor mappings. An alternative to the <code>Terminated</code> signal is to define a custom message that will be sent when the watched actor is stopped. We will use that here because it gives us the possibility to carry the device ID in that message.</p>
<p>Adding the functionality to identify the actor results in this:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroup.scala#L32-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala"><br/>class DeviceGroup(context: ActorContext[DeviceGroup.DeviceGroupMessage], groupId: String)
  extends AbstractBehavior[DeviceGroup.DeviceGroupMessage] {
  import DeviceGroup._
  import DeviceManager._

  private var deviceIdToActor = Map.empty[String, ActorRef[Device.DeviceMessage]]

  context.log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def onMessage(msg: DeviceGroupMessage): Behavior[DeviceGroupMessage] =
    msg match {
      case trackMsg @ RequestTrackDevice(`groupId`, deviceId, replyTo) ⇒
        deviceIdToActor.get(deviceId) match {
          case Some(deviceActor) ⇒
            replyTo ! DeviceRegistered(deviceActor)
          case None ⇒
            context.log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
            val deviceActor = context.spawn(Device(groupId, deviceId), s&quot;device-$deviceId&quot;)
            context.watchWith(deviceActor, DeviceTerminated(deviceActor, groupId, deviceId))
            deviceIdToActor += deviceId -&gt; deviceActor
            replyTo ! DeviceRegistered(deviceActor)
        }
        this

      case RequestTrackDevice(gId, _, _) ⇒
        context.log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          gId, groupId
        )
        this

      case DeviceTerminated(_, _, deviceId) ⇒
        context.log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
        deviceIdToActor -= deviceId
        this

    }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceGroupMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;DeviceGroup {} stopped&quot;, groupId)
      this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroup.java#L24-L117" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractBehavior&lt;DeviceGroupMessage&gt; {

  public static Behavior&lt;DeviceGroupMessage&gt; createBehavior(String groupId) {
    return Behaviors.setup(context -&gt; new DeviceGroup(context, groupId));
  }

  private class DeviceTerminated implements DeviceGroupMessage {
    public final ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device;
    public final String groupId;
    public final String deviceId;

    DeviceTerminated(
        ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device, String groupId, String deviceId) {
      this.device = device;
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  private final ActorContext&lt;DeviceGroupMessage&gt; context;
  private final String groupId;
  private final Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();

  public DeviceGroup(ActorContext&lt;DeviceGroupMessage&gt; context, String groupId) {
    this.context = context;
    this.groupId = groupId;
    context.getLog().info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  private DeviceGroup onTrackDevice(RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef&lt;DeviceMessage&gt; deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      } else {
        context.getLog().info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            context.spawn(
                Device.createBehavior(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        context.watchWith(
            deviceActor, new DeviceTerminated(deviceActor, groupId, trackMsg.deviceId));
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      }
    } else {
      context
          .getLog()
          .warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId,
              this.groupId);
    }
    return this;
  }


  private DeviceGroup onTerminated(DeviceTerminated t) {
    context.getLog().info(&quot;Device actor for {} has been terminated&quot;, t.deviceId);
    deviceIdToActor.remove(t.deviceId);
    return this;
  }

  @Override
  public Receive&lt;DeviceGroupMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(RequestTrackDevice.class, this::onTrackDevice)
        .onMessage(DeviceTerminated.class, this::onTerminated)
        .onSignal(PostStop.class, signal -&gt; postStop())
        .build();
  }

  private DeviceGroup postStop() {
    context.getLog().info(&quot;DeviceGroup {} stopped&quot;, groupId);
    return this;
  }
}</code></pre></dd>
</dl>
<p>So far we have no means to get which devices the group device actor keeps track of and, therefore, we cannot test our new functionality yet. To make it testable, we add a new query capability (message <code>RequestDeviceList</code>) that lists the currently active device IDs:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceManager.scala#L33-L36" target="_blank" title="Go to snippet source"></a><code class="language-scala">final case class RequestDeviceList(requestId: Long, groupId: String, replyTo: ActorRef[ReplyDeviceList])
  extends DeviceManagerMessage with DeviceGroupMessage

final case class ReplyDeviceList(requestId: Long, ids: Set[String])</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceManagerProtocol.java#L42-L62" target="_blank" title="Go to snippet source"></a><code class="language-java">public static final class RequestDeviceList implements DeviceManagerMessage, DeviceGroupMessage {
  final long requestId;
  final String groupId;
  final ActorRef&lt;ReplyDeviceList&gt; replyTo;

  public RequestDeviceList(long requestId, String groupId, ActorRef&lt;ReplyDeviceList&gt; replyTo) {
    this.requestId = requestId;
    this.groupId = groupId;
    this.replyTo = replyTo;
  }
}

public static final class ReplyDeviceList {
  final long requestId;
  final Set&lt;String&gt; ids;

  public ReplyDeviceList(long requestId, Set&lt;String&gt; ids) {
    this.requestId = requestId;
    this.ids = ids;
  }
}</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroup.scala#L17-L89" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceGroup {
  def apply(groupId: String): Behavior[DeviceGroupMessage] =
    Behaviors.setup(context ⇒ new DeviceGroup(context, groupId))

  trait DeviceGroupMessage

  private final case class DeviceTerminated(
    device:   ActorRef[Device.DeviceMessage],
    groupId:  String,
    deviceId: String) extends DeviceGroupMessage

}

class DeviceGroup(context: ActorContext[DeviceGroup.DeviceGroupMessage], groupId: String)
  extends AbstractBehavior[DeviceGroup.DeviceGroupMessage] {
  import DeviceGroup._
  import DeviceManager._

  private var deviceIdToActor = Map.empty[String, ActorRef[Device.DeviceMessage]]

  context.log.info(&quot;DeviceGroup {} started&quot;, groupId)

  override def onMessage(msg: DeviceGroupMessage): Behavior[DeviceGroupMessage] =
    msg match {
      case trackMsg @ RequestTrackDevice(`groupId`, deviceId, replyTo) ⇒
        deviceIdToActor.get(deviceId) match {
          case Some(deviceActor) ⇒
            replyTo ! DeviceRegistered(deviceActor)
          case None ⇒
            context.log.info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId)
            val deviceActor = context.spawn(Device(groupId, deviceId), s&quot;device-$deviceId&quot;)
            context.watchWith(deviceActor, DeviceTerminated(deviceActor, groupId, deviceId))
            deviceIdToActor += deviceId -&gt; deviceActor
            replyTo ! DeviceRegistered(deviceActor)
        }
        this

      case RequestTrackDevice(gId, _, _) ⇒
        context.log.warning(
          &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
          gId, groupId
        )
        this

      case RequestDeviceList(requestId, gId, replyTo) ⇒
        if (gId == groupId) {
          replyTo ! ReplyDeviceList(requestId, deviceIdToActor.keySet)
          this
        } else
          Behaviors.unhandled

      case DeviceTerminated(_, _, deviceId) ⇒
        context.log.info(&quot;Device actor for {} has been terminated&quot;, deviceId)
        deviceIdToActor -= deviceId
        this

    }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceGroupMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;DeviceGroup {} stopped&quot;, groupId)
      this
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroup.java#L24-L117" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceGroup extends AbstractBehavior&lt;DeviceGroupMessage&gt; {

  public static Behavior&lt;DeviceGroupMessage&gt; createBehavior(String groupId) {
    return Behaviors.setup(context -&gt; new DeviceGroup(context, groupId));
  }

  private class DeviceTerminated implements DeviceGroupMessage {
    public final ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device;
    public final String groupId;
    public final String deviceId;

    DeviceTerminated(
        ActorRef&lt;DeviceProtocol.DeviceMessage&gt; device, String groupId, String deviceId) {
      this.device = device;
      this.groupId = groupId;
      this.deviceId = deviceId;
    }
  }

  private final ActorContext&lt;DeviceGroupMessage&gt; context;
  private final String groupId;
  private final Map&lt;String, ActorRef&lt;DeviceMessage&gt;&gt; deviceIdToActor = new HashMap&lt;&gt;();

  public DeviceGroup(ActorContext&lt;DeviceGroupMessage&gt; context, String groupId) {
    this.context = context;
    this.groupId = groupId;
    context.getLog().info(&quot;DeviceGroup {} started&quot;, groupId);
  }

  private DeviceGroup onTrackDevice(RequestTrackDevice trackMsg) {
    if (this.groupId.equals(trackMsg.groupId)) {
      ActorRef&lt;DeviceMessage&gt; deviceActor = deviceIdToActor.get(trackMsg.deviceId);
      if (deviceActor != null) {
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      } else {
        context.getLog().info(&quot;Creating device actor for {}&quot;, trackMsg.deviceId);
        deviceActor =
            context.spawn(
                Device.createBehavior(groupId, trackMsg.deviceId), &quot;device-&quot; + trackMsg.deviceId);
        context.watchWith(
            deviceActor, new DeviceTerminated(deviceActor, groupId, trackMsg.deviceId));
        deviceIdToActor.put(trackMsg.deviceId, deviceActor);
        trackMsg.replyTo.tell(new DeviceRegistered(deviceActor));
      }
    } else {
      context
          .getLog()
          .warning(
              &quot;Ignoring TrackDevice request for {}. This actor is responsible for {}.&quot;,
              groupId,
              this.groupId);
    }
    return this;
  }


  private DeviceGroup onDeviceList(RequestDeviceList r) {
    r.replyTo.tell(new ReplyDeviceList(r.requestId, deviceIdToActor.keySet()));
    return this;
  }

  private DeviceGroup onTerminated(DeviceTerminated t) {
    context.getLog().info(&quot;Device actor for {} has been terminated&quot;, t.deviceId);
    deviceIdToActor.remove(t.deviceId);
    return this;
  }

  @Override
  public Receive&lt;DeviceGroupMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(RequestTrackDevice.class, this::onTrackDevice)
        .onMessage(RequestDeviceList.class, r -&gt; r.groupId.equals(groupId), this::onDeviceList)
        .onMessage(DeviceTerminated.class, this::onTerminated)
        .onSignal(PostStop.class, signal -&gt; postStop())
        .build();
  }

  private DeviceGroup postStop() {
    context.getLog().info(&quot;DeviceGroup {} stopped&quot;, groupId);
    return this;
  }
}</code></pre></dd>
</dl>
<p>We are almost ready to test the removal of devices. But, we still need the following capabilities:</p>
<ul>
  <li>To stop a device actor from our test case, from the outside, we must send a message to it. We add a <code>Passivate</code> message which instructs the actor to stop.</li>
  <li>To be notified once the device actor is stopped. We can use the <em>Death Watch</em> facility for this purpose, too.</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/Device.scala#L31" target="_blank" title="Go to snippet source"></a><code class="language-scala">case object Passivate extends DeviceMessage</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceProtocol.java#L59-L61" target="_blank" title="Go to snippet source"></a><code class="language-java">static enum Passivate implements DeviceMessage {
  INSTANCE
}</code></pre></dd>
</dl>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/Device.scala#L8-L66" target="_blank" title="Go to snippet source"></a><code class="language-scala">import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.PostStop
import akka.actor.typed.Signal
import akka.actor.typed.scaladsl.AbstractBehavior
import akka.actor.typed.scaladsl.ActorContext
import akka.actor.typed.scaladsl.Behaviors

object Device {
  def apply(groupId: String, deviceId: String): Behavior[DeviceMessage] =
    Behaviors.setup(context ⇒ new Device(context, groupId, deviceId))

  sealed trait DeviceMessage

  final case class ReadTemperature(requestId: Long, replyTo: ActorRef[RespondTemperature])
    extends DeviceMessage
  final case class RespondTemperature(requestId: Long, value: Option[Double])

  final case class RecordTemperature(requestId: Long, value: Double, replyTo: ActorRef[TemperatureRecorded])
    extends DeviceMessage
  final case class TemperatureRecorded(requestId: Long)

  case object Passivate extends DeviceMessage
}

class Device(context: ActorContext[Device.DeviceMessage], groupId: String, deviceId: String)
  extends AbstractBehavior[Device.DeviceMessage] {
  import Device._

  var lastTemperatureReading: Option[Double] = None

  context.log.info(&quot;Device actor {}-{} started&quot;, groupId, deviceId)

  override def onMessage(msg: DeviceMessage): Behavior[DeviceMessage] = {
    msg match {
      case RecordTemperature(id, value, replyTo) ⇒
        context.log.info(&quot;Recorded temperature reading {} with {}&quot;, value, id)
        lastTemperatureReading = Some(value)
        replyTo ! TemperatureRecorded(id)
        this

      case ReadTemperature(id, replyTo) ⇒
        replyTo ! RespondTemperature(id, lastTemperatureReading)
        this

      case Passivate ⇒
        Behaviors.stopped
    }
  }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId)
      this
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/Device.java#L8-L73" target="_blank" title="Go to snippet source"></a><code class="language-java"><br/>import java.util.Optional;

import akka.actor.typed.Behavior;
import akka.actor.typed.PostStop;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;

import static com.lightbend.akka.sample.DeviceProtocol.*;

public class Device extends AbstractBehavior&lt;DeviceMessage&gt; {

  public static Behavior&lt;DeviceMessage&gt; createBehavior(String groupId, String deviceId) {
    return Behaviors.setup(context -&gt; new Device(context, groupId, deviceId));
  }

  private final ActorContext&lt;DeviceMessage&gt; context;
  private final String groupId;
  private final String deviceId;

  private Optional&lt;Double&gt; lastTemperatureReading = Optional.empty();

  public Device(ActorContext&lt;DeviceMessage&gt; context, String groupId, String deviceId) {
    this.context = context;
    this.groupId = groupId;
    this.deviceId = deviceId;

    context.getLog().info(&quot;Device actor {}-{} started&quot;, groupId, deviceId);
  }

  @Override
  public Receive&lt;DeviceMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(RecordTemperature.class, this::recordTemperature)
        .onMessage(ReadTemperature.class, this::readTemperature)
        .onMessage(Passivate.class, m -&gt; Behaviors.stopped())
        .onSignal(PostStop.class, signal -&gt; postStop())
        .build();
  }

  private Behavior&lt;DeviceMessage&gt; recordTemperature(RecordTemperature r) {
    context.getLog().info(&quot;Recorded temperature reading {} with {}&quot;, r.value, r.requestId);
    lastTemperatureReading = Optional.of(r.value);
    r.replyTo.tell(new TemperatureRecorded(r.requestId));
    return this;
  }

  private Behavior&lt;DeviceMessage&gt; readTemperature(ReadTemperature r) {
    r.replyTo.tell(new RespondTemperature(r.requestId, lastTemperatureReading));
    return this;
  }

  private Behavior&lt;DeviceMessage&gt; postStop() {
    context.getLog().info(&quot;Device actor {}-{} stopped&quot;, groupId, deviceId);
    return Behaviors.stopped();
  }
}</code></pre></dd>
</dl>
<p>We add two more test cases now. In the first, we test that we get back the list of proper IDs once we have added a few devices. The second test case makes sure that the device ID is properly removed after the device actor has been stopped. The <code>TestProbe</code> has a <code>expectTerminated</code> method that we can easily use to assert that the device actor has been terminated.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceGroupSpec.scala#L67-L106" target="_blank" title="Go to snippet source"></a><code class="language-scala">&quot;be able to list active devices&quot; in {
  val registeredProbe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.ref)
  registeredProbe.receiveMessage()

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.ref)
  registeredProbe.receiveMessage()

  val deviceListProbe = createTestProbe[ReplyDeviceList]()
  groupActor ! RequestDeviceList(requestId = 0, groupId = &quot;group&quot;, deviceListProbe.ref)
  deviceListProbe.expectMessage(ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))
}

&quot;be able to list active devices after one shuts down&quot; in {
  val registeredProbe = createTestProbe[DeviceRegistered]()
  val groupActor = spawn(DeviceGroup(&quot;group&quot;))

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.ref)
  val registered1 = registeredProbe.receiveMessage()
  val toShutDown = registered1.device

  groupActor ! RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.ref)
  registeredProbe.receiveMessage()

  val deviceListProbe = createTestProbe[ReplyDeviceList]()
  groupActor ! RequestDeviceList(requestId = 0, groupId = &quot;group&quot;, deviceListProbe.ref)
  deviceListProbe.expectMessage(ReplyDeviceList(requestId = 0, Set(&quot;device1&quot;, &quot;device2&quot;)))

  toShutDown ! Passivate
  registeredProbe.expectTerminated(toShutDown, registeredProbe.remainingOrDefault)

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  registeredProbe.awaitAssert {
    groupActor ! RequestDeviceList(requestId = 1, groupId = &quot;group&quot;, deviceListProbe.ref)
    deviceListProbe.expectMessage(ReplyDeviceList(requestId = 1, Set(&quot;device2&quot;)))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceGroupTest.java#L74-L126" target="_blank" title="Go to snippet source"></a><code class="language-java">@Test
public void testListActiveDevices() {
  TestProbe&lt;DeviceRegistered&gt; registeredProbe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.getRef()));
  registeredProbe.receiveMessage();

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.getRef()));
  registeredProbe.receiveMessage();

  TestProbe&lt;ReplyDeviceList&gt; deviceListProbe = testKit.createTestProbe(ReplyDeviceList.class);

  groupActor.tell(new RequestDeviceList(0L, &quot;group&quot;, deviceListProbe.getRef()));
  ReplyDeviceList reply = deviceListProbe.receiveMessage();
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);
}

@Test
public void testListActiveDevicesAfterOneShutsDown() {
  TestProbe&lt;DeviceRegistered&gt; registeredProbe = testKit.createTestProbe(DeviceRegistered.class);
  ActorRef&lt;DeviceGroupMessage&gt; groupActor = testKit.spawn(DeviceGroup.createBehavior(&quot;group&quot;));

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device1&quot;, registeredProbe.getRef()));
  DeviceRegistered registered1 = registeredProbe.receiveMessage();

  groupActor.tell(new RequestTrackDevice(&quot;group&quot;, &quot;device2&quot;, registeredProbe.getRef()));
  DeviceRegistered registered2 = registeredProbe.receiveMessage();

  ActorRef&lt;DeviceMessage&gt; toShutDown = registered1.device;

  TestProbe&lt;ReplyDeviceList&gt; deviceListProbe = testKit.createTestProbe(ReplyDeviceList.class);

  groupActor.tell(new RequestDeviceList(0L, &quot;group&quot;, deviceListProbe.getRef()));
  ReplyDeviceList reply = deviceListProbe.receiveMessage();
  assertEquals(0L, reply.requestId);
  assertEquals(Stream.of(&quot;device1&quot;, &quot;device2&quot;).collect(Collectors.toSet()), reply.ids);

  toShutDown.tell(Passivate.INSTANCE);
  registeredProbe.expectTerminated(toShutDown, registeredProbe.getRemainingOrDefault());

  // using awaitAssert to retry because it might take longer for the groupActor
  // to see the Terminated, that order is undefined
  registeredProbe.awaitAssert(
      () -&gt; {
        groupActor.tell(new RequestDeviceList(1L, &quot;group&quot;, deviceListProbe.getRef()));
        ReplyDeviceList r = deviceListProbe.receiveMessage();
        assertEquals(1L, r.requestId);
        assertEquals(Stream.of(&quot;device2&quot;).collect(Collectors.toSet()), r.ids);
        return null;
      });
}</code></pre></dd>
</dl>
<h2><a href="#creating-device-manager-actors" name="creating-device-manager-actors" class="anchor"><span class="anchor-link"></span></a>Creating device manager actors</h2>
<p>Going up to the next level in our hierarchy, we need to create the entry point for our device manager component in the <code>DeviceManager</code> source file. This actor is very similar to the device group actor, but creates device group actors instead of device actors:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/scala/typed/tutorial_4/DeviceManager.scala#L16-L88" target="_blank" title="Go to snippet source"></a><code class="language-scala">object DeviceManager {
  def apply(): Behavior[DeviceManagerMessage] =
    Behaviors.setup(context ⇒ new DeviceManager(context))

  import DeviceGroup.DeviceGroupMessage

  sealed trait DeviceManagerMessage

  final case class RequestTrackDevice(groupId: String, deviceId: String, replyTo: ActorRef[DeviceRegistered])
    extends DeviceManagerMessage with DeviceGroupMessage

  final case class DeviceRegistered(device: ActorRef[Device.DeviceMessage])

  final case class RequestDeviceList(requestId: Long, groupId: String, replyTo: ActorRef[ReplyDeviceList])
    extends DeviceManagerMessage with DeviceGroupMessage

  final case class ReplyDeviceList(requestId: Long, ids: Set[String])

  private final case class DeviceGroupTerminated(groupId: String) extends DeviceManagerMessage
}

class DeviceManager(context: ActorContext[DeviceManager.DeviceManagerMessage])
  extends AbstractBehavior[DeviceManager.DeviceManagerMessage] {
  import DeviceManager._
  import DeviceGroup.DeviceGroupMessage

  var groupIdToActor = Map.empty[String, ActorRef[DeviceGroupMessage]]

  context.log.info(&quot;DeviceManager started&quot;)

  override def onMessage(msg: DeviceManagerMessage): Behavior[DeviceManagerMessage] =
    msg match {
      case trackMsg @ RequestTrackDevice(groupId, _, replyTo) ⇒
        groupIdToActor.get(groupId) match {
          case Some(ref) ⇒
            ref ! trackMsg
          case None ⇒
            context.log.info(&quot;Creating device group actor for {}&quot;, groupId)
            val groupActor = context.spawn(DeviceGroup(groupId), &quot;group-&quot; + groupId)
            context.watchWith(groupActor, DeviceGroupTerminated(groupId))
            groupActor ! trackMsg
            groupIdToActor += groupId -&gt; groupActor
        }
        this

      case req @ RequestDeviceList(requestId, groupId, replyTo) ⇒
        groupIdToActor.get(groupId) match {
          case Some(ref) ⇒
            ref ! req
          case None ⇒
            replyTo ! ReplyDeviceList(requestId, Set.empty)
        }
        this

      case DeviceGroupTerminated(groupId) ⇒
        context.log.info(&quot;Device group actor for {} has been terminated&quot;, groupId)
        groupIdToActor -= groupId
        this
    }

  override def onSignal: PartialFunction[Signal, Behavior[DeviceManagerMessage]] = {
    case PostStop ⇒
      context.log.info(&quot;DeviceManager stopped&quot;)
      this
  }

}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/xmeng1/akka/tree/master/akka-docs/src/test/java/jdocs/typed/tutorial_4/DeviceManager.java#L22-L89" target="_blank" title="Go to snippet source"></a><code class="language-java">public class DeviceManager extends AbstractBehavior&lt;DeviceManagerMessage&gt; {

  public static Behavior&lt;DeviceManagerMessage&gt; createBehavior() {
    return Behaviors.setup(DeviceManager::new);
  }

  private static class DeviceGroupTerminated implements DeviceManagerMessage {
    public final String groupId;

    DeviceGroupTerminated(String groupId) {
      this.groupId = groupId;
    }
  }

  private final ActorContext&lt;DeviceManagerMessage&gt; context;
  private final Map&lt;String, ActorRef&lt;DeviceGroupMessage&gt;&gt; groupIdToActor = new HashMap&lt;&gt;();

  public DeviceManager(ActorContext&lt;DeviceManagerMessage&gt; context) {
    this.context = context;
    context.getLog().info(&quot;DeviceManager started&quot;);
  }

  private DeviceManager onTrackDevice(RequestTrackDevice trackMsg) {
    String groupId = trackMsg.groupId;
    ActorRef&lt;DeviceGroupMessage&gt; ref = groupIdToActor.get(groupId);
    if (ref != null) {
      ref.tell(trackMsg);
    } else {
      context.getLog().info(&quot;Creating device group actor for {}&quot;, groupId);
      ActorRef&lt;DeviceGroupMessage&gt; groupActor =
          context.spawn(DeviceGroup.createBehavior(groupId), &quot;group-&quot; + groupId);
      context.watchWith(groupActor, new DeviceGroupTerminated(groupId));
      groupActor.tell(trackMsg);
      groupIdToActor.put(groupId, groupActor);
    }
    return this;
  }

  private DeviceManager onRequestDeviceList(RequestDeviceList request) {
    ActorRef&lt;DeviceGroupMessage&gt; ref = groupIdToActor.get(request.groupId);
    if (ref != null) {
      ref.tell(request);
    } else {
      request.replyTo.tell(new ReplyDeviceList(request.requestId, Collections.emptySet()));
    }
    return this;
  }

  private DeviceManager onTerminated(DeviceGroupTerminated t) {
    context.getLog().info(&quot;Device group actor for {} has been terminated&quot;, t.groupId);
    groupIdToActor.remove(t.groupId);
    return this;
  }

  public Receive&lt;DeviceManagerMessage&gt; createReceive() {
    return receiveBuilder()
        .onMessage(RequestTrackDevice.class, this::onTrackDevice)
        .onMessage(RequestDeviceList.class, this::onRequestDeviceList)
        .onMessage(DeviceGroupTerminated.class, this::onTerminated)
        .onSignal(PostStop.class, signal -&gt; postStop())
        .build();
  }

  private DeviceManager postStop() {
    context.getLog().info(&quot;DeviceManager stopped&quot;);
    return this;
  }
}</code></pre></dd>
</dl>
<p>We leave tests of the device manager as an exercise for you since it is very similar to the tests we have already written for the group actor.</p>
<h2><a href="#whats-next-" name="whats-next-" class="anchor"><span class="anchor-link"></span></a>What&rsquo;s next?</h2>
<p>We have now a hierarchical component for registering and tracking devices and recording measurements. We have seen how to implement different types of conversation patterns, such as:</p>
<ul>
  <li>Request-respond (for temperature recordings)</li>
  <li>Create-on-demand (for registration of devices)</li>
  <li>Create-watch-terminate (for creating the group and device actor as children)</li>
</ul>
<p>In the next chapter, we will introduce group query capabilities, which will establish a new conversation pattern of scatter-gather. In particular, we will implement the functionality that allows users to query the status of all the devices belonging to a group.</p>
</div>
</article>

<div class="row">
<div class="small-12 large-9 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../../typed/guide/tutorial_3.html"><i class="icon-prev"></i> <span class="link-prev">Part 3: Working with Device Actors</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../../typed/guide/tutorial_5.html">Part 5: Querying Device Groups <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>

<div class="source-github row">
Found an error in this documentation? The source code for this page can be found <a href="https://github.com/xmeng1/akka/tree/master/akka-docs-cn/src/main/paradox/typed/guide/tutorial_4.md">here</a>.
Please feel free to edit and contribute a pull request.
</div>


<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../../images/akka-icon.svg">
<section class="copyright">
<div>Akka is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2011-2019 <a href="https://www.lightbend.com" target="_blank">Lightbend, Inc.</a> | 
<a href="https://www.lightbend.com/legal/licenses" target="_blank">Licenses</a> | 
<a href="https://www.lightbend.com/legal/terms" target="_blank">Terms</a> | 
<a href="https://www.lightbend.com/legal/privacy" target="_blank">Privacy Policy</a> | 
<a href="https://akka.io/cookie/" target="_blank">Cookie Listing</a> | 
<a class="optanon-toggle-display">Cookie Settings</a>
</p>
</section>
</footer>

</section>
</main>

<script type="text/javascript" src="../../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../../js/groups.js"></script>
<script type="text/javascript" src="../../js/page.js"></script>
<script type="text/javascript" src="../../js/magellan.js"></script>

<style type="text/css">@import "../../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

<!-- Algolia docs search -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<style>.algolia-autocomplete { display: block !important }</style>
<script type="text/javascript">
docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#search',
algoliaOptions: {
hitsPerPage: 5
}
});

docsearch({
apiKey: '543bad5ad786495d9ccd445ed34ed082',
indexName: 'akka_io',
inputSelector: '#overlay-search',
algoliaOptions: {
hitsPerPage: 5
}
});

// set up "/" as global shortcut for focusing on search
jQuery(document).keypress(function (event) {
if (event.keyCode == 47) {
jQuery("#search").focus();
return false; // swallow key event, otherwise the / char would be input into the search box
}
});
</script>

<script type="text/javascript" src="../../assets/js/warnOldDocs.js"></script>
<script type="text/javascript" src="../../assets/js/scalafiddle.js"></script>


</body>
</html>
